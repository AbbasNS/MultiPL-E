{"name": "LeetCode_100_findLadders", "language": "rkt", "prompt": "#lang racket\n;; A transformation sequence from word beginWord to word endWord using a hash wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n;; Every adjacent pair of words differs by a single letter.\n;; Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n;; sk == endWord\n;; Given two words, beginWord and endWord, and a hash wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].\n;; Example 1:\n;; Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n;; Output: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\n;; Explanation:\u00a0There are 2 shortest transformation sequences:\n;; \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n;; \"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"\n;; Example 2:\n;; Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n;; Output: []\n;; Explanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n;; Constraints:\n;; 1 <= beginWord.length <= 5\n;; endWord.length == beginWord.length\n;; 1 <= wordList.length <= 500\n;; wordList[i].length == beginWord.length\n;; beginWord, endWord, and wordList[i] consist of lowercase English letters.\n;; beginWord != endWord\n;; All the words in wordList are unique.\n;; The sum of all shortest transformation sequences does not exceed 105.\n(define (findLadders beginWord endWord wordList)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_100_findLadders.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate findLadders))\n    (check-within (candidate \"qaaz\" \"qazz\" (list \"qazz\")) (list (list \"qaaz\" \"qazz\")) 0.001)\n    (check-within (candidate \"abc\" \"def\" (list \"abc\" \"bbc\" \"dbc\" \"dec\")) (list ) 0.001)\n    (check-within (candidate \"abc\" \"def\" (list \"def\")) (list ) 0.001)\n    (check-within (candidate \"hit\" \"cog\" (list \"hot\" \"dot\" \"dog\" \"lot\" \"log\")) (list ) 0.001)\n    (check-within (candidate \"a\" \"d\" (list \"a\" \"b\" \"c\")) (list ) 0.001)\n    (check-within (candidate \"aaa\" \"bbb\" (list \"aaa\" \"aab\" \"abb\" \"bbb\")) (list (list \"aaa\" \"aab\" \"abb\" \"bbb\")) 0.001)\n    (check-within (candidate \"hit\" \"cog\" (list \"hot\" \"dot\" \"dog\" \"lot\" \"log\" \"cog\")) (list (list \"hit\" \"hot\" \"dot\" \"dog\" \"cog\") (list \"hit\" \"hot\" \"lot\" \"log\" \"cog\")) 0.001)\n    (check-within (candidate \"hot\" \"dog\" (list \"hot\" \"dot\" \"dog\" \"lot\" \"log\")) (list (list \"hot\" \"dot\" \"dog\")) 0.001)\n    (check-within (candidate \"ant\" \"act\" (list \"ant\" \"act\" \"tct\")) (list (list \"ant\" \"act\")) 0.001)\n    (check-within (candidate \"a\" \"c\" (list \"a\" \"b\" \"c\")) (list (list \"a\" \"c\")) 0.001)\n    (check-within (candidate \"hot\" \"dot\" (list \"hot\" \"dot\" \"dog\" \"lot\" \"log\" \"cog\")) (list (list \"hot\" \"dot\")) 0.001)\n    (check-within (candidate \"hit\" \"cog\" (list \"hot\" \"dot\" \"dog\" \"lot\" \"log\" \"cog\")) (list (list \"hit\" \"hot\" \"dot\" \"dog\" \"cog\") (list \"hit\" \"hot\" \"lot\" \"log\" \"cog\")) 0.001)\n    (check-within (candidate \"abc\" \"abc\" (list \"abc\")) (list (list \"abc\")) 0.001)\n    (check-within (candidate \"hot\" \"dog\" (list \"hot\" \"dog\" \"dot\")) (list (list \"hot\" \"dot\" \"dog\")) 0.001)\n    (check-within (candidate \"hot\" \"dog\" (list \"hot\" \"dot\" \"dog\" \"lot\" \"log\" \"cog\")) (list (list \"hot\" \"dot\" \"dog\")) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1010_tilingRectangle", "language": "rkt", "prompt": "#lang racket\n;; Given a rectangle of size n x m, return the minimum number of integer-sided squares that tile the rectangle.\n;; Example 1:\n;; Input: n = 2, m = 3\n;; Output: 3\n;; Explanation: 3 squares are necessary to cover the rectangle.\n;; 2 (squares of 1x1)\n;; 1 (square of 2x2)\n;; Example 2:\n;; Input: n = 5, m = 8\n;; Output: 5\n;; Example 3:\n;; Input: n = 11, m = 13\n;; Output: 6\n;; Constraints:\n;; 1 <= n, m <= 13\n(define (tilingRectangle n m)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1010_tilingRectangle.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate tilingRectangle))\n    (check-within (candidate 2 3) 3 0.001)\n    (check-within (candidate 1 4) 4 0.001)\n    (check-within (candidate 1 50) 50 0.001)\n    (check-within (candidate 48 1) 48 0.001)\n    (check-within (candidate 35 35) 1 0.001)\n    (check-within (candidate 30 30) 1 0.001)\n    (check-within (candidate 34 34) 1 0.001)\n    (check-within (candidate 20 20) 1 0.001)\n    (check-within (candidate 15 5) 3 0.001)\n    (check-within (candidate 5 5) 1 0.001)\n    (check-within (candidate 1 6) 6 0.001)\n    (check-within (candidate 39 39) 1 0.001)\n    (check-within (candidate 13 13) 1 0.001)\n    (check-within (candidate 8 7) 7 0.001)\n    (check-within (candidate 1 58) 58 0.001)\n    (check-within (candidate 18 18) 1 0.001)\n    (check-within (candidate 42 42) 1 0.001)\n    (check-within (candidate 6 7) 5 0.001)\n    (check-within (candidate 56 1) 56 0.001)\n    (check-within (candidate 5 1) 5 0.001)\n    (check-within (candidate 4 2) 2 0.001)\n    (check-within (candidate 36 36) 1 0.001)\n    (check-within (candidate 1 20) 20 0.001)\n    (check-within (candidate 37 37) 1 0.001)\n    (check-within (candidate 10 10) 1 0.001)\n    (check-within (candidate 16 16) 1 0.001)\n    (check-within (candidate 55 55) 1 0.001)\n    (check-within (candidate 26 26) 1 0.001)\n    (check-within (candidate 7 1) 7 0.001)\n    (check-within (candidate 17 17) 1 0.001)\n    (check-within (candidate 1 7) 7 0.001)\n    (check-within (candidate 1 5) 5 0.001)\n    (check-within (candidate 30 1) 30 0.001)\n    (check-within (candidate 29 1) 29 0.001)\n    (check-within (candidate 12 12) 1 0.001)\n    (check-within (candidate 24 24) 1 0.001)\n    (check-within (candidate 2 2) 1 0.001)\n    (check-within (candidate 10 1) 10 0.001)\n    (check-within (candidate 40 40) 1 0.001)\n    (check-within (candidate 38 1) 38 0.001)\n    (check-within (candidate 1 3) 3 0.001)\n    (check-within (candidate 15 15) 1 0.001)\n    (check-within (candidate 4 1) 4 0.001)\n    (check-within (candidate 41 41) 1 0.001)\n    (check-within (candidate 28 1) 28 0.001)\n    (check-within (candidate 29 29) 1 0.001)\n    (check-within (candidate 1 2) 2 0.001)\n    (check-within (candidate 1 55) 55 0.001)\n    (check-within (candidate 1 10) 10 0.001)\n    (check-within (candidate 1 40) 40 0.001)\n    (check-within (candidate 2 4) 2 0.001)\n    (check-within (candidate 14 14) 1 0.001)\n    (check-within (candidate 8 8) 1 0.001)\n    (check-within (candidate 27 27) 1 0.001)\n    (check-within (candidate 19 19) 1 0.001)\n    (check-within (candidate 3 2) 3 0.001)\n    (check-within (candidate 7 5) 5 0.001)\n    (check-within (candidate 6 4) 3 0.001)\n    (check-within (candidate 31 31) 1 0.001)\n    (check-within (candidate 15 1) 15 0.001)\n    (check-within (candidate 7 3) 5 0.001)\n    (check-within (candidate 25 25) 1 0.001)\n    (check-within (candidate 3 3) 1 0.001)\n    (check-within (candidate 47 47) 1 0.001)\n    (check-within (candidate 1 30) 30 0.001)\n    (check-within (candidate 32 32) 1 0.001)\n    (check-within (candidate 1 59) 59 0.001)\n    (check-within (candidate 1 1) 1 0.001)\n    (check-within (candidate 21 21) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1015_maxHeight", "language": "rkt", "prompt": "#lang racket\n;; Given n cuboids where the dimensions of the ith cuboid is cuboids[i] = [widthi, lengthi, heighti] (0-indexed). Choose a subset of cuboids and place them on each other.\n;; You can place cuboid i on cuboid j if widthi <= widthj and lengthi <= lengthj and heighti <= heightj. You can rearrange any cuboid's dimensions by rotating it to put it on another cuboid.\n;; Return the maximum height of the stacked cuboids.\n;; Example 1:\n;; Input: cuboids = [[50,45,20],[95,37,53],[45,23,12]]\n;; Output: 190\n;; Explanation:\n;; Cuboid 1 is placed on the bottom with the 53x37 side facing down with height 95.\n;; Cuboid 0 is placed next with the 45x20 side facing down with height 50.\n;; Cuboid 2 is placed next with the 23x12 side facing down with height 45.\n;; The total height is 95 + 50 + 45 = 190.\n;; Example 2:\n;; Input: cuboids = [[38,25,45],[76,35,3]]\n;; Output: 76\n;; Explanation:\n;; You can't place any of the cuboids on the other.\n;; We choose cuboid 1 and rotate it so that the 35x3 side is facing down and its height is 76.\n;; Example 3:\n;; Input: cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]\n;; Output: 102\n;; Explanation:\n;; After rearranging the cuboids, you can see that all cuboids have the same dimension.\n;; You can place the 11x7 side down on all cuboids so their heights are 17.\n;; The maximum height of stacked cuboids is 6 * 17 = 102.\n;; Constraints:\n;; n == cuboids.length\n;; 1 <= n <= 100\n;; 1 <= widthi, lengthi, heighti <= 100\n(define (maxHeight cuboids)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1015_maxHeight.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maxHeight))\n    (check-within (candidate (list (list 1 1 1))) 1 0.001)\n    (check-within (candidate (list (list 1 1 1) (list 1 1 1) (list 1 1 1) (list 1 1 1))) 4 0.001)\n    (check-within (candidate (list (list 1 1 1) (list 2 2 2))) 3 0.001)\n    (check-within (candidate (list (list 50 45 20) (list 95 37 53) (list 45 23 12))) 190 0.001)\n    (check-within (candidate (list (list 1 1 1) (list 2 2 2) (list 3 3 3))) 6 0.001)\n    (check-within (candidate (list (list 1 1 1) (list 1 1 1) (list 1 1 1) (list 1 1 1) (list 1 1 1))) 5 0.001)\n    (check-within (candidate (list (list 3 3 3) (list 2 2 2) (list 1 1 1))) 6 0.001)\n    (check-within (candidate (list (list 1 1 1) (list 1 1 1) (list 1 1 1))) 3 0.001)\n    (check-within (candidate (list (list 4 4 4) (list 3 3 3) (list 2 2 2) (list 1 1 1))) 10 0.001)\n    (check-within (candidate (list (list 38 25 45) (list 76 35 3))) 76 0.001)\n    (check-within (candidate (list (list 10 10 10) (list 20 20 20))) 30 0.001)\n    (check-within (candidate (list (list 1 1 1) (list 2 2 2) (list 3 3 3) (list 4 4 4))) 10 0.001)\n    (check-within (candidate (list (list 7 11 17) (list 7 17 11) (list 11 7 17) (list 11 17 7) (list 17 7 11) (list 17 11 7))) 102 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1016_minCost", "language": "rkt", "prompt": "#lang racket\n;; Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n;; 1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n;; 2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n;; 3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n;; 4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n;; Notice that there could be some signs on the cells of the grid that point outside the grid.\n;; You will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.\n;; You can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\n;; Return the minimum cost to make the grid have at least one valid path.\n;; Example 1:\n;; Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\n;; Output: 3\n;; Explanation: You will start at point (0, 0).\n;; The path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\n;; The total cost = 3.\n;; Example 2:\n;; Input: grid = [[1,1,3],[3,2,2],[1,1,4]]\n;; Output: 0\n;; Explanation: You can follow the path from (0, 0) to (2, 2).\n;; Example 3:\n;; Input: grid = [[1,2],[4,3]]\n;; Output: 1\n;; Constraints:\n;; m == grid.length\n;; n == grid[i].length\n;; 1 <= m, n <= 100\n;; 1 <= grid[i][j] <= 4\n(define (minCost grid)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1016_minCost.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minCost))\n    (check-within (candidate (list (list 1))) 0 0.001)\n    (check-within (candidate (list (list 1 1 1 1 1) (list 1 1 1 1 1) (list 1 1 1 1 1) (list 1 1 1 1 1) (list 1 1 1 1 1))) 4 0.001)\n    (check-within (candidate (list (list 3 3 3 3) (list 2 2 2 2) (list 3 3 3 3) (list 1 1 1 1))) 2 0.001)\n    (check-within (candidate (list (list 1 1 2 2 2) (list 2 2 2 2 2) (list 2 2 2 2 2) (list 4 3 3 3 3) (list 4 4 3 3 2))) 3 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 2 2 2 2) (list 3 3 3 3) (list 4 4 4 4))) 2 0.001)\n    (check-within (candidate (list (list 1 2 2 2 2) (list 2 2 2 2 2) (list 2 2 2 2 2) (list 4 3 3 3 3) (list 4 4 3 3 1))) 4 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1019_is_good_array", "language": "rkt", "prompt": "#lang racket\n;; Given a list nums of\u00a0positive integers. Your task is to select some subset of nums, multiply each element by an integer and add all these numbers.\u00a0The list is said to be\u00a0good\u00a0if you can obtain a sum of\u00a01\u00a0from the list by any possible subset and multiplicand.\n;; Return\u00a0#t\u00a0if the list is good\u00a0otherwise\u00a0return\u00a0#f.\n;; Example 1:\n;; Input: nums = [12,5,7,23]\n;; Output: true\n;; Explanation: Pick numbers 5 and 7.\n;; 5*3 + 7*(-2) = 1\n;; Example 2:\n;; Input: nums = [29,6,10]\n;; Output: true\n;; Explanation: Pick numbers 29, 6 and 10.\n;; 29*1 + 6*(-3) + 10*(-1) = 1\n;; Example 3:\n;; Input: nums = [3,6]\n;; Output: false\n;; Constraints:\n;; 1 <= nums.length <= 10^5\n;; 1 <= nums[i] <= 10^9\n(define (is_good_array nums)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1019_is_good_array.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_good_array))\n    (check-within (candidate (list 3 5 7 11 13 17)) #t 0.001)\n    (check-within (candidate (list 1 3 5 7 9 11 13 15 17)) #t 0.001)\n    (check-within (candidate (list 2 2 2 2)) #f 0.001)\n    (check-within (candidate (list 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50)) #f 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1)) #t 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)) #t 0.001)\n    (check-within (candidate (list 2 2 2 2 2 2 2 2 2 2 2 2)) #f 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1)) #t 0.001)\n    (check-within (candidate (list 3 5 7 11)) #t 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1)) #t 0.001)\n    (check-within (candidate (list 2 4 6 8 10 12)) #f 0.001)\n    (check-within (candidate (list 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)) #t 0.001)\n    (check-within (candidate (list 1 3 5 7 9)) #t 0.001)\n    (check-within (candidate (list 2 4 6 8 10 12 14 16 18 20 22 24)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10 11)) #t 0.001)\n    (check-within (candidate (list 1 1 1 1)) #t 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)) #t 0.001)\n    (check-within (candidate (list 3 5 7 11 13)) #t 0.001)\n    (check-within (candidate (list 2 2 2 2 2 2)) #f 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1 1)) #t 0.001)\n    (check-within (candidate (list 1 1 1 1 1)) #t 0.001)\n    (check-within (candidate (list 2 2 2 2 2)) #f 0.001)\n    (check-within (candidate (list 3 6 9 12 15 18)) #f 0.001)\n    (check-within (candidate (list 10 20 30 40)) #f 0.001)\n    (check-within (candidate (list 2 3 5 7)) #t 0.001)\n    (check-within (candidate (list 1 3 5 7 9 11)) #t 0.001)\n    (check-within (candidate (list 2 4 6 8 10 12 14)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) #t 0.001)\n    (check-within (candidate (list 1 5 7 11)) #t 0.001)\n    (check-within (candidate (list 3 6)) #f 0.001)\n    (check-within (candidate (list 5 10 15 20)) #f 0.001)\n    (check-within (candidate (list 1 3 5 7 9 11 13 15 17 19)) #t 0.001)\n    (check-within (candidate (list 2 4 6 8 10)) #f 0.001)\n    (check-within (candidate (list 2 4 6 8)) #f 0.001)\n    (check-within (candidate (list 1 2 3 4)) #t 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1)) #t 0.001)\n    (check-within (candidate (list 13 26 39 52)) #f 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1)) #t 0.001)\n    (check-within (candidate (list 12 5 7 23)) #t 0.001)\n    (check-within (candidate (list 2 3 4 5 6 7 8 9 10 11)) #t 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1 1 1)) #t 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_101_ladderLength", "language": "rkt", "prompt": "#lang racket\n;; A transformation sequence from word beginWord to word endWord using a hash wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n;; Every adjacent pair of words differs by a single letter.\n;; Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n;; sk == endWord\n;; Given two words, beginWord and endWord, and a hash wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n;; Example 1:\n;; Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n;; Output: 5\n;; Explanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\n;; Example 2:\n;; Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n;; Output: 0\n;; Explanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n;; Constraints:\n;; 1 <= beginWord.length <= 10\n;; endWord.length == beginWord.length\n;; 1 <= wordList.length <= 5000\n;; wordList[i].length == beginWord.length\n;; beginWord, endWord, and wordList[i] consist of lowercase English letters.\n;; beginWord != endWord\n;; All the words in wordList are unique.\n(define (ladderLength beginWord endWord wordList)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_101_ladderLength.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate ladderLength))\n    (check-within (candidate \"hot\" \"dot\" (list \"hot\" \"dot\" \"dog\" \"lot\" \"log\")) 2 0.001)\n    (check-within (candidate \"hot\" \"dog\" (list \"hot\" \"cog\" \"dot\")) 0 0.001)\n    (check-within (candidate \"hot\" \"dog\" (list \"hot\" \"dot\" \"dog\" \"cog\")) 3 0.001)\n    (check-within (candidate \"a\" \"c\" (list \"a\" \"b\")) 0 0.001)\n    (check-within (candidate \"hot\" \"dog\" (list \"hot\" \"dot\" \"dog\" \"lot\" \"log\")) 3 0.001)\n    (check-within (candidate \"hot\" \"dog\" (list \"hot\" \"dot\" \"dog\" \"cog\" \"lot\" \"log\")) 3 0.001)\n    (check-within (candidate \"hot\" \"dog\" (list \"hot\" \"dot\" \"dog\" \"cog\" \"lot\" \"log\" \"bog\")) 3 0.001)\n    (check-within (candidate \"hit\" \"hot\" (list \"hot\" \"dot\" \"dog\" \"cog\" \"lot\" \"log\")) 2 0.001)\n    (check-within (candidate \"banana\" \"banani\" (list \"banana\" \"banani\" \"banane\")) 2 0.001)\n    (check-within (candidate \"hot\" \"dog\" (list \"hot\" \"dot\" \"dog\" \"lot\" \"log\" \"cog\")) 3 0.001)\n    (check-within (candidate \"hot\" \"dot\" (list \"hot\" \"dot\" \"dog\" \"lot\" \"log\" \"cog\")) 2 0.001)\n    (check-within (candidate \"hot\" \"cog\" (list \"hot\" \"dot\" \"dog\" \"cog\" \"lot\" \"log\")) 4 0.001)\n    (check-within (candidate \"hot\" \"dog\" (list \"hot\" \"dog\" \"dot\")) 3 0.001)\n    (check-within (candidate \"drain\" \"boat\" (list \"sail\" \"boat\" \"sacre\" \"coat\" \"dot\" \"crab\" \"crot\" \"brag\" \"cog\")) 0 0.001)\n    (check-within (candidate \"hit\" \"cog\" (list \"hot\" \"dot\" \"dog\" \"cog\" \"lot\" \"log\")) 5 0.001)\n    (check-within (candidate \"a\" \"b\" (list \"b\")) 2 0.001)\n    (check-within (candidate \"hot\" \"cog\" (list \"hot\" \"dot\" \"dog\" \"cog\")) 4 0.001)\n    (check-within (candidate \"hot\" \"dot\" (list \"hot\" \"dot\" \"dog\" \"cog\" \"lot\" \"log\")) 2 0.001)\n    (check-within (candidate \"hit\" \"cog\" (list \"hot\" \"dot\" \"dog\" \"lot\" \"log\")) 0 0.001)\n    (check-within (candidate \"hit\" \"lot\" (list \"hot\" \"dot\" \"dog\" \"cog\" \"lot\" \"log\")) 3 0.001)\n    (check-within (candidate \"hot\" \"cog\" (list \"hot\" \"dot\" \"dog\" \"lot\" \"log\" \"cog\")) 4 0.001)\n    (check-within (candidate \"hit\" \"dot\" (list \"hot\" \"dot\" \"dog\" \"cog\" \"lot\" \"log\")) 3 0.001)\n    (check-within (candidate \"hit\" \"cog\" (list \"hot\" \"dot\" \"dog\" \"lot\" \"log\" \"cog\")) 5 0.001)\n    (check-within (candidate \"hot\" \"dot\" (list \"hot\" \"dot\" \"dog\")) 2 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1023_frogPosition", "language": "rkt", "prompt": "#lang racket\n;; Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\n;; The edges of the undirected tree are given in the list edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\n;; Return the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.\n;; Example 1:\n;; Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\n;; Output: 0.16666666666666666 \n;; Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. \n;; Example 2:\n;; Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\n;; Output: 0.3333333333333333\n;; Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. \n;; Constraints:\n;; 1 <= n <= 100\n;; edges.length == n - 1\n;; edges[i].length == 2\n;; 1 <= ai, bi <= n\n;; 1 <= t <= 50\n;; 1 <= target <= n\n(define (frogPosition n edges t target)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1023_frogPosition.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate frogPosition))\n    (check-within (candidate 7 (list (list 1 2) (list 1 3) (list 1 7) (list 2 4) (list 2 6) (list 3 5)) 2 4) 0.16666666666666666 0.001)\n    (check-within (candidate 7 (list (list 1 2) (list 1 3) (list 1 7) (list 2 4) (list 2 6) (list 3 5)) 2 3) 0.0 0.001)\n    (check-within (candidate 3 (list ) 3 1) 1.0 0.001)\n    (check-within (candidate 3 (list (list 1 2) (list 1 3)) 1 3) 0.5 0.001)\n    (check-within (candidate 1 (list ) 1 1) 1.0 0.001)\n    (check-within (candidate 7 (list (list 1 2) (list 1 3) (list 1 7) (list 2 4) (list 2 6) (list 3 5)) 1 1) 0.0 0.001)\n    (check-within (candidate 3 (list (list 1 2) (list 1 3)) 2 2) 0.5 0.001)\n    (check-within (candidate 3 (list (list 1 2) (list 1 3) (list 2 3)) 2 2) 0.5 0.001)\n    (check-within (candidate 3 (list (list 3 2) (list 3 1)) 1 2) 0.0 0.001)\n    (check-within (candidate 7 (list (list 1 2) (list 1 3) (list 1 7) (list 2 4) (list 2 6) (list 3 5)) 0 1) 1.0 0.001)\n    (check-within (candidate 7 (list (list 1 2) (list 1 3) (list 1 7) (list 2 4) (list 2 6) (list 3 5)) 1 7) 0.3333333333333333 0.001)\n    (check-within (candidate 1 (list ) 5 1) 1.0 0.001)\n    (check-within (candidate 4 (list (list 1 2) (list 1 3) (list 1 4)) 1 4) 0.3333333333333333 0.001)\n    (check-within (candidate 2 (list ) 2 1) 1.0 0.001)\n    (check-within (candidate 5 (list (list 1 2) (list 2 3) (list 3 4) (list 4 5)) 3 5) 0.0 0.001)\n    (check-within (candidate 5 (list (list 1 2) (list 2 3) (list 3 4) (list 4 5)) 4 5) 1.0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1043_stoneGameIII", "language": "rkt", "prompt": "#lang racket\n;; Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the list stoneValue.\n;; Alice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2, or 3 stones from the first remaining stones in the row.\n;; The score of each player is the sum of the values of the stones taken. The score of each player is 0 initially.\n;; The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\n;; Assume Alice and Bob play optimally.\n;; Return \"Alice\" if Alice will win, \"Bob\" if Bob will win, or \"Tie\" if they will end the game with the same score.\n;; Example 1:\n;; Input: stoneValue = [1,2,3,7]\n;; Output: \"Bob\"\n;; Explanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n;; Example 2:\n;; Input: stoneValue = [1,2,3,-9]\n;; Output: \"Alice\"\n;; Explanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.\n;; If Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\n;; If Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\n;; Remember that both play optimally so here Alice will choose the scenario that makes her win.\n;; Example 3:\n;; Input: stoneValue = [1,2,3,6]\n;; Output: \"Tie\"\n;; Explanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\n;; Constraints:\n;; 1 <= stoneValue.length <= 5 * 104\n;; -1000 <= stoneValue[i] <= 1000\n(define (stoneGameIII stoneValue)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1043_stoneGameIII.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate stoneGameIII))\n    (check-within (candidate (list -1 2 -3 4 -5)) \"Bob \" 0.001)\n    (check-within (candidate (list 1 2 3 7)) \"Bob \" 0.001)\n    (check-within (candidate (list 1 2 3 6)) \"Tie \" 0.001)\n    (check-within (candidate (list -1 -2 -3 7)) \"Bob \" 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 -9)) \"Alice \" 0.001)\n    (check-within (candidate (list 1 2 3 -7)) \"Alice \" 0.001)\n    (check-within (candidate (list 1 1 1 1 1 2)) \"Alice \" 0.001)\n    (check-within (candidate (list -1000 -1000 -1000 -1000)) \"Tie \" 0.001)\n    (check-within (candidate (list -9 -2 -3 1 2 3 -1 3)) \"Bob \" 0.001)\n    (check-within (candidate (list 3 2 1 100 4)) \"Bob \" 0.001)\n    (check-within (candidate (list -5 7 -10 10 3 11)) \"Alice \" 0.001)\n    (check-within (candidate (list 8 7 -5 -10 6 1 2 3)) \"Alice \" 0.001)\n    (check-within (candidate (list 1 100 -99 100 -99)) \"Alice \" 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7)) \"Alice \" 0.001)\n    (check-within (candidate (list 1 2 3 -1)) \"Alice \" 0.001)\n    (check-within (candidate (list 2 1 2 1 3)) \"Alice \" 0.001)\n    (check-within (candidate (list 1 -2 3 -7)) \"Alice \" 0.001)\n    (check-within (candidate (list 1 -2 -3 -4 -5)) \"Alice \" 0.001)\n    (check-within (candidate (list 1 1 -100 3 3 3 3 3 3 3)) \"Alice \" 0.001)\n    (check-within (candidate (list 1 -2 -3 -7)) \"Alice \" 0.001)\n    (check-within (candidate (list -100 -200 -300 -1000)) \"Alice \" 0.001)\n    (check-within (candidate (list 1 2 100 3 4)) \"Alice \" 0.001)\n    (check-within (candidate (list -1 -1 -1 -1)) \"Tie \" 0.001)\n    (check-within (candidate (list -3 3 1 2 -5 1 -2 3)) \"Bob \" 0.001)\n    (check-within (candidate (list 1 -1 1 -1 1 -1 1)) \"Alice \" 0.001)\n    (check-within (candidate (list 1 1 3 -2 -3)) \"Alice \" 0.001)\n    (check-within (candidate (list 1 2 3 -9 -8 7 -3 6 5)) \"Alice \" 0.001)\n    (check-within (candidate (list 1 3 3 3 3 1 1 1)) \"Alice \" 0.001)\n    (check-within (candidate (list 1 2 3 -9)) \"Alice \" 0.001)\n    (check-within (candidate (list 1000 -1000 -1000 -1000)) \"Alice \" 0.001)\n    (check-within (candidate (list -1000000000 1 2 3 -7)) \"Bob \" 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1048_shortestPath", "language": "rkt", "prompt": "#lang racket\n;; You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacle). You can move up, down, left, or right from and to an empty cell in one step.\n;; Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1) given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1.\n;; Example 1:\n;; Input: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1\n;; Output: 6\n;; Explanation: \n;; The shortest path without eliminating any obstacle is 10.\n;; The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).\n;; Example 2:\n;; Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1\n;; Output: -1\n;; Explanation: We need to eliminate at least two obstacles to find such a walk.\n;; Constraints:\n;; m == grid.length\n;; n == grid[i].length\n;; 1 <= m, n <= 40\n;; 1 <= k <= m * n\n;; grid[i][j] is either 0 or 1.\n;; grid[0][0] == grid[m - 1][n - 1] == 0\n(define (shortestPath grid k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1048_shortestPath.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate shortestPath))\n    (check-within (candidate (list (list 0 1 1) (list 1 1 1) (list 1 0 0)) 1) -1 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 1 1 0) (list 1 1 0)) 1) 4 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 1 1 1) (list 0 0 0)) 2) 4 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 1 0 1) (list 1 1 0)) 1) 4 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 1 1 1) (list 0 0 0) (list 1 1 1) (list 0 0 0)) 1) -1 0.001)\n    (check-within (candidate (list (list 0 1 1 1 1) (list 0 0 0 0 0) (list 1 1 1 1 0)) 2) 6 0.001)\n    (check-within (candidate (list (list 0 1 1 1 0) (list 0 0 0 1 0) (list 1 1 0 0 0)) 2) 6 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_105_minCut", "language": "rkt", "prompt": "#lang racket\n;; Given a string s, partition s such that every substring of the partition is a palindrome.\n;; Return the minimum cuts needed for a palindrome partitioning of s.\n;; Example 1:\n;; Input: s = \"aab\"\n;; Output: 1\n;; Explanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\n;; Example 2:\n;; Input: s = \"a\"\n;; Output: 0\n;; Example 3:\n;; Input: s = \"ab\"\n;; Output: 1\n;; Constraints:\n;; 1 <= s.length <= 2000\n;; s consists of lowercase English letters only.\n(define (minCut s)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_105_minCut.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minCut))\n    (check-within (candidate \"refer\") 0 0.001)\n    (check-within (candidate \"python\") 5 0.001)\n    (check-within (candidate \"laptop\") 5 0.001)\n    (check-within (candidate \"releveler\") 0 0.001)\n    (check-within (candidate \"deified\") 0 0.001)\n    (check-within (candidate \"computer\") 7 0.001)\n    (check-within (candidate \"level\") 0 0.001)\n    (check-within (candidate \"bbabbcbb\") 2 0.001)\n    (check-within (candidate \"babb\") 1 0.001)\n    (check-within (candidate \"civic\") 0 0.001)\n    (check-within (candidate \"a\") 0 0.001)\n    (check-within (candidate \"deed\") 0 0.001)\n    (check-within (candidate \"redder\") 0 0.001)\n    (check-within (candidate \"aa\") 0 0.001)\n    (check-within (candidate \"madam\") 0 0.001)\n    (check-within (candidate \"substring\") 8 0.001)\n    (check-within (candidate \"aab\") 1 0.001)\n    (check-within (candidate \"reviver\") 0 0.001)\n    (check-within (candidate \"bbb\") 0 0.001)\n    (check-within (candidate \"repaper\") 0 0.001)\n    (check-within (candidate \"dddddd\") 0 0.001)\n    (check-within (candidate \"bbbb\") 0 0.001)\n    (check-within (candidate \"racecar\") 0 0.001)\n    (check-within (candidate \"bcbc\") 1 0.001)\n    (check-within (candidate \"rotator\") 0 0.001)\n    (check-within (candidate \"b\") 0 0.001)\n    (check-within (candidate \"redivider\") 0 0.001)\n    (check-within (candidate \"hannah\") 0 0.001)\n    (check-within (candidate \"ab\") 1 0.001)\n    (check-within (candidate \"rotor\") 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1077_min_taps", "language": "rkt", "prompt": "#lang racket\n;; There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e., the\u00a0length of the garden is n).\n;; There are n + 1 taps located at points [0, 1, ..., n] in the garden.\n;; Given an integer n and an integer list ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.\n;; Return the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1.\n;; Example 1:\n;; Input: n = 5, ranges = [3,4,1,1,0,0]\n;; Output: 1\n;; Explanation: The tap at point 0 can cover the interval [-3,3]\n;; The tap at point 1 can cover the interval [-3,5]\n;; The tap at point 2 can cover the interval [1,3]\n;; The tap at point 3 can cover the interval [2,4]\n;; The tap at point 4 can cover the interval [4,4]\n;; The tap at point 5 can cover the interval [5,5]\n;; Opening Only the second tap will water the whole garden [0,5]\n;; Example 2:\n;; Input: n = 3, ranges = [0,0,0,0]\n;; Output: -1\n;; Explanation: Even if you activate all the four taps you cannot water the whole garden.\n;; Constraints:\n;; 1 <= n <= 104\n;; ranges.length == n + 1\n;; 0 <= ranges[i] <= 100\n(define (min_taps n ranges)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1077_min_taps.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate min_taps))\n    (check-within (candidate 2 (list 2 1 2)) 1 0.001)\n    (check-within (candidate 5 (list 3 2 1 1 2 2)) 2 0.001)\n    (check-within (candidate 8 (list 4 0 0 0 0 0 0 0 4)) 2 0.001)\n    (check-within (candidate 3 (list 2 3 1 1 1)) 1 0.001)\n    (check-within (candidate 3 (list 0 0 0 0)) -1 0.001)\n    (check-within (candidate 2 (list 1 2 1)) 1 0.001)\n    (check-within (candidate 1 (list 1 1)) 1 0.001)\n    (check-within (candidate 5 (list 2 2 1 2 1 3)) 2 0.001)\n    (check-within (candidate 5 (list 3 4 1 1 0 0)) 1 0.001)\n    (check-within (candidate 3 (list 0 0 3 0)) 1 0.001)\n    (check-within (candidate 3 (list 3 2 1 1)) 1 0.001)\n    (check-within (candidate 3 (list 3 0 0 0)) 1 0.001)\n    (check-within (candidate 8 (list 4 0 0 0 4 0 0 0 4)) 1 0.001)\n    (check-within (candidate 3 (list 2 1 1 1)) 2 0.001)\n    (check-within (candidate 0 (list 0)) 0 0.001)\n    (check-within (candidate 10 (list 5 5 2 1 5 1 5 2 1 5 2)) -1 0.001)\n    (check-within (candidate 5 (list 3 2 1 1 1 1)) 2 0.001)\n    (check-within (candidate 2 (list 2 1 1)) 1 0.001)\n    (check-within (candidate 3 (list 2 1 2 1)) 1 0.001)\n    (check-within (candidate 3 (list 4 0 0 0 0 0)) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1079_numPoints", "language": "rkt", "prompt": "#lang racket\n;; Alice is throwing n darts on a very large wall. You are given a list darts where darts[i] = [xi, yi] is the position of the ith dart that Alice threw on the wall.\n;; Bob knows the positions of the n darts on the wall. He wants to place a dartboard of radius r on the wall so that the maximum number of darts that Alice throws lie\u00a0on the dartboard.\n;; Given the integer r, return the maximum number of darts that can lie on the dartboard.\n;; Example 1:\n;; Input: darts = [[-2,0],[2,0],[0,2],[0,-2]], r = 2\n;; Output: 4\n;; Explanation: Circle dartboard with center in (0,0) and radius = 2 contain all points.\n;; Example 2:\n;; Input: darts = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5\n;; Output: 5\n;; Explanation: Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8).\n;; Constraints:\n;; 1 <= darts.length <= 100\n;; darts[i].length == 2\n;; -104 <= xi, yi <= 104\n;; All the darts\u00a0are unique\n;; 1 <= r <= 5000\n(define (numPoints darts r)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1079_numPoints.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate numPoints))\n    (check-within (candidate (list (list 1 2) (list 3 4) (list 5 6) (list 7 8) (list 9 10)) 1) 1 0.001)\n    (check-within (candidate (list (list 100 100) (list 200 200) (list 300 300) (list 400 400) (list 500 500)) 100) 1 0.001)\n    (check-within (candidate (list (list 0 0) (list 1 1) (list 2 2) (list 3 3) (list 4 4)) 1) 1 0.001)\n    (check-within (candidate (list (list 1 1) (list 2 2) (list 3 3) (list 4 4) (list 5 5)) 5) 5 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1082_minDifficulty", "language": "rkt", "prompt": "#lang racket\n;; You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the ith job, you have to finish all the jobs j where 0 <= j < i).\n;; You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done on that day.\n;; You are given an integer list jobDifficulty and an integer d. The difficulty of the ith job is jobDifficulty[i].\n;; Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.\n;; Example 1:\n;; Input: jobDifficulty = [6,5,4,3,2,1], d = 2\n;; Output: 7\n;; Explanation: First day you can finish the first 5 jobs, total difficulty = 6.\n;; Second day you can finish the last job, total difficulty = 1.\n;; The difficulty of the schedule = 6 + 1 = 7 \n;; Example 2:\n;; Input: jobDifficulty = [9,9,9], d = 4\n;; Output: -1\n;; Explanation: If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.\n;; Example 3:\n;; Input: jobDifficulty = [1,1,1], d = 3\n;; Output: 3\n;; Explanation: The schedule is one job per day. total difficulty will be 3.\n;; Constraints:\n;; 1 <= jobDifficulty.length <= 300\n;; 0 <= jobDifficulty[i] <= 1000\n;; 1 <= d <= 10\n(define (minDifficulty jobDifficulty d)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1082_minDifficulty.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minDifficulty))\n    (check-within (candidate (list 6 5 4 3 2 1) 2) 7 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1) 1) 1 0.001)\n    (check-within (candidate (list 9 9 9) 4) -1 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9) 1) 9 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1) 5) 5 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9) 1) 9 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1) 20) 20 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1) 9) 9 0.001)\n    (check-within (candidate (list 9) 2) -1 0.001)\n    (check-within (candidate (list 1 1 1) 3) 3 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1085_countOrders", "language": "rkt", "prompt": "#lang racket\n;; Given n orders, each order consist in pickup and delivery services.\u00a0\n;; Count all valid pickup/delivery possible sequences such that delivery(i) is always after of\u00a0pickup(i).\u00a0\n;; Since the answer\u00a0may be too large,\u00a0return it modulo\u00a010^9 + 7.\n;; Example 1:\n;; Input: n = 1\n;; Output: 1\n;; Explanation: Unique order (P1, D1), Delivery 1 always is after of Pickup 1.\n;; Example 2:\n;; Input: n = 2\n;; Output: 6\n;; Explanation: All possible orders: \n;; (P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).\n;; This is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2.\n;; Example 3:\n;; Input: n = 3\n;; Output: 90\n;; Constraints:\n;; 1 <= n <= 500\n(define (countOrders n)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1085_countOrders.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate countOrders))\n    (check-within (candidate 6) 7484400 0.001)\n    (check-within (candidate 3) 90 0.001)\n    (check-within (candidate 7) 681080400 0.001)\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 5) 113400 0.001)\n    (check-within (candidate 4) 2520 0.001)\n    (check-within (candidate 2) 6 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1089_maxJumps", "language": "rkt", "prompt": "#lang racket\n;; Given a list of\u00a0integers arr and an integer d. In one step you can jump from index i to index:\n;; i + x where:\u00a0i + x < arr.length and  0 <\u00a0x <= d.\n;; i - x where:\u00a0i - x >= 0 and  0 <\u00a0x <= d.\n;; In addition, you can only jump from index i to index j\u00a0if arr[i] > arr[j] and arr[i] > arr[k] for all indices k between i and j (More formally min(i,\u00a0j) < k < max(i, j)).\n;; You can choose any index of the list and start jumping. Return the maximum number of indices\u00a0you can visit.\n;; Notice that you can not jump outside of the list at any time.\n;; Example 1:\n;; Input: arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2\n;; Output: 4\n;; Explanation: You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.\n;; Note that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.\n;; Similarly You cannot jump from index 3 to index 2 or index 1.\n;; Example 2:\n;; Input: arr = [3,3,3,3,3], d = 3\n;; Output: 1\n;; Explanation: You can start at any index. You always cannot jump to any index.\n;; Example 3:\n;; Input: arr = [7,6,5,4,3,2,1], d = 1\n;; Output: 7\n;; Explanation: Start at index 0. You can visit all the indicies. \n;; Constraints:\n;; 1 <= arr.length <= 1000\n;; 1 <= arr[i] <= 105\n;; 1 <= d <= arr.length\n(define (maxJumps arr d)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1089_maxJumps.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maxJumps))\n    (check-within (candidate (list 1 1 1 1 1 1 1) 1) 1 0.001)\n    (check-within (candidate (list 6 4 14 6 8 3 5 2 10 3) 2) 4 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1) 3) 1 0.001)\n    (check-within (candidate (list 7 1 1 1 1 1 7) 2) 2 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1) 4) 1 0.001)\n    (check-within (candidate (list 6 4 14 6 8 13 9 7 10 6 12) 3) 4 0.001)\n    (check-within (candidate (list 6 4 14 6 8 13 9 7 10 6 12) 4) 4 0.001)\n    (check-within (candidate (list 6 4 14 6 8 13 9 7 10 6 12) 5) 4 0.001)\n    (check-within (candidate (list 1 2 1 1 1 3 1 1 1 1 1 1 1 1 2 2 2 1) 0) 1 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1) 2) 1 0.001)\n    (check-within (candidate (list 7 6 5 4 3 2 1) 1) 7 0.001)\n    (check-within (candidate (list 3 3 3 3 3) 3) 1 0.001)\n    (check-within (candidate (list 1 2 1 1 1 3 1 1 1 1 1 1 1 1 2 2 2 1) 6) 3 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1101_minCost", "language": "rkt", "prompt": "#lang racket\n;; Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n;; 1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n;; 2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n;; 3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n;; 4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n;; Notice that there could be some signs on the cells of the grid that point outside the grid.\n;; You will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.\n;; You can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\n;; Return the minimum cost to make the grid have at least one valid path.\n;; Example 1:\n;; Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\n;; Output: 3\n;; Explanation: You will start at point (0, 0).\n;; The path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\n;; The total cost = 3.\n;; Example 2:\n;; Input: grid = [[1,1,3],[3,2,2],[1,1,4]]\n;; Output: 0\n;; Explanation: You can follow the path from (0, 0) to (2, 2).\n;; Example 3:\n;; Input: grid = [[1,2],[4,3]]\n;; Output: 1\n;; Constraints:\n;; m == grid.length\n;; n == grid[i].length\n;; 1 <= m, n <= 100\n;; 1 <= grid[i][j] <= 4\n(define (minCost grid)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1101_minCost.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minCost))\n    (check-within (candidate (list (list 1 1 1 1 1 1) (list 1 2 2 2 2 1) (list 1 2 3 3 2 1) (list 1 2 2 2 2 1) (list 1 2 2 2 2 1) (list 1 1 1 1 1 1))) 4 0.001)\n    (check-within (candidate (list (list 1 1 1 1 1) (list 1 2 2 2 1) (list 1 2 3 2 1) (list 1 2 2 2 1) (list 1 1 1 1 1))) 3 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 2 2 1) (list 1 2 2 1) (list 1 1 1 1))) 3 0.001)\n    (check-within (candidate (list (list 4 1 4) (list 1 4 1) (list 4 1 4))) 2 0.001)\n    (check-within (candidate (list (list 1 2) (list 4 3))) 1 0.001)\n    (check-within (candidate (list (list 1 1 3) (list 3 2 2) (list 1 1 4))) 0 0.001)\n    (check-within (candidate (list (list 4 1) (list 1 4))) 1 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 2 2 2 2) (list 1 1 1 1) (list 2 2 2 2))) 3 0.001)\n    (check-within (candidate (list (list 4 1 4 1) (list 1 4 1 4) (list 4 1 4 1) (list 1 4 1 4))) 3 0.001)\n    (check-within (candidate (list (list 1 1 3) (list 3 2 2) (list 1 1 1))) 0 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 2 1 1) (list 2 2 1 2) (list 1 2 1 1) (list 1 1 1 1))) 4 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 2 2 1 2) (list 1 2 2 1) (list 1 1 1 1))) 3 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1109_frogPosition", "language": "rkt", "prompt": "#lang racket\n;; Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\n;; The edges of the undirected tree are given in the list edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\n;; Return the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.\n;; Example 1:\n;; Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\n;; Output: 0.16666666666666666 \n;; Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. \n;; Example 2:\n;; Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\n;; Output: 0.3333333333333333\n;; Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. \n;; Constraints:\n;; 1 <= n <= 100\n;; edges.length == n - 1\n;; edges[i].length == 2\n;; 1 <= ai, bi <= n\n;; 1 <= t <= 50\n;; 1 <= target <= n\n(define (frogPosition n edges t target)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1109_frogPosition.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate frogPosition))\n    (check-within (candidate 3 (list (list 2 1) (list 3 2)) 2 3) 1.0 0.001)\n    (check-within (candidate 7 (list (list 1 2) (list 1 3) (list 1 7) (list 2 4) (list 2 6) (list 3 5)) 1 7) 0.3333333333333333 0.001)\n    (check-within (candidate 3 (list (list 2 1) (list 3 2)) 2 1) 0.0 0.001)\n    (check-within (candidate 3 (list (list 2 1) (list 3 2)) 1 2) 1.0 0.001)\n    (check-within (candidate 12 (list (list 9 11) (list 4 5) (list 1 2) (list 10 12) (list 3 8) (list 6 9) (list 3 1) (list 3 10) (list 8 11) (list 7 9) (list 7 4) (list 8 6) (list 10 11)) 0 1) 1.0 0.001)\n    (check-within (candidate 7 (list (list 1 2) (list 1 3) (list 1 7) (list 2 4) (list 2 6) (list 3 5)) 0 1) 1.0 0.001)\n    (check-within (candidate 3 (list (list 2 1) (list 3 2)) 1 3) 0.0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1110_minNumberOfSemesters", "language": "rkt", "prompt": "#lang racket\n;; You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a list relations where relations[i] = [prevCoursei, nextCoursei], representing a prerequisite relationship between course prevCoursei and course nextCoursei: course prevCoursei has to be taken before course nextCoursei. Also, you are given the integer k.\n;; In one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semesters for the courses you are taking.\n;; Return the minimum number of semesters needed to take all courses. The testcases will be generated such that it is possible to take every course.\n;; Example 1:\n;; Input: n = 4, relations = [[2,1],[3,1],[1,4]], k = 2\n;; Output: 3\n;; Explanation: The figure above represents the given graph.\n;; In the first semester, you can take courses 2 and 3.\n;; In the second semester, you can take course 1.\n;; In the third semester, you can take course 4.\n;; Example 2:\n;; Input: n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2\n;; Output: 4\n;; Explanation: The figure above represents the given graph.\n;; In the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.\n;; In the second semester, you can take course 4.\n;; In the third semester, you can take course 1.\n;; In the fourth semester, you can take course 5.\n;; Constraints:\n;; 1 <= n <= 15\n;; 1 <= k <= n\n;; 0 <= relations.length <= n * (n-1) / 2\n;; relations[i].length == 2\n;; 1 <= prevCoursei, nextCoursei <= n\n;; prevCoursei != nextCoursei\n;; All the pairs [prevCoursei, nextCoursei] are unique.\n;; The given graph is a directed acyclic graph.\n(define (minNumberOfSemesters n relations k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1110_minNumberOfSemesters.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minNumberOfSemesters))\n    (check-within (candidate 6 (list (list 6 5) (list 5 4) (list 4 3) (list 3 2) (list 2 1)) 1) 6 0.001)\n    (check-within (candidate 2 (list (list 1 2)) 1) 2 0.001)\n    (check-within (candidate 1 (list ) 2) 1 0.001)\n    (check-within (candidate 10 (list (list 2 1) (list 3 2) (list 4 3) (list 5 4) (list 6 5) (list 7 6) (list 8 7) (list 9 8) (list 10 9)) 1) 10 0.001)\n    (check-within (candidate 1 (list ) 1) 1 0.001)\n    (check-within (candidate 3 (list (list 3 2) (list 2 1)) 1) 3 0.001)\n    (check-within (candidate 4 (list (list 2 1) (list 3 1) (list 1 4)) 2) 3 0.001)\n    (check-within (candidate 5 (list (list 1 2) (list 3 4) (list 2 5) (list 4 5)) 2) 3 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1116_max_satisfaction", "language": "rkt", "prompt": "#lang racket\n;; A chef has collected data on the satisfaction level of his n dishes. Chef can cook any dish in 1 unit of time.\n;; Like-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. time[i] * satisfaction[i].\n;; Return the maximum sum of like-time coefficient that the chef can obtain after dishes preparation.\n;; Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.\n;; Example 1:\n;; Input: satisfaction = [-1,-8,0,5,-9]\n;; Output: 14\n;; Explanation: After Removing the second and last dish, the maximum total like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14).\n;; Each dish is prepared in one unit of time.\n;; Example 2:\n;; Input: satisfaction = [4,3,2]\n;; Output: 20\n;; Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\n;; Example 3:\n;; Input: satisfaction = [-1,-4,-5]\n;; Output: 0\n;; Explanation: People do not like the dishes. No dish is prepared.\n;; Constraints:\n;; n == satisfaction.length\n;; 1 <= n <= 500\n;; -1000 <= satisfaction[i] <= 1000\n(define (max_satisfaction satisfaction)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1116_max_satisfaction.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_satisfaction))\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1)) 55 0.001)\n    (check-within (candidate (list -1 -4 -5)) 0 0.001)\n    (check-within (candidate (list -1 -8 0 5 -9)) 14 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0 0 0 0 0)) 0 0.001)\n    (check-within (candidate (list -1 -2 -3 -4 -5 -6 -7 -8 -9 -10)) 0 0.001)\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list -10 -20 -30 -40 -50 -60 -70 -80 -90 -100)) 0 0.001)\n    (check-within (candidate (list -1 -1 -1 -1 -1 -1 -1 -1 -1 -1)) 0 0.001)\n    (check-within (candidate (list -1000 -1000 -1000)) 0 0.001)\n    (check-within (candidate (list 4 3 2)) 20 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1131_stoneGameIII", "language": "rkt", "prompt": "#lang racket\n;; Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the list stoneValue.\n;; Alice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2, or 3 stones from the first remaining stones in the row.\n;; The score of each player is the sum of the values of the stones taken. The score of each player is 0 initially.\n;; The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\n;; Assume Alice and Bob play optimally.\n;; Return \"Alice\" if Alice will win, \"Bob\" if Bob will win, or \"Tie\" if they will end the game with the same score.\n;; Example 1:\n;; Input: stoneValue = [1,2,3,7]\n;; Output: \"Bob\"\n;; Explanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n;; Example 2:\n;; Input: stoneValue = [1,2,3,-9]\n;; Output: \"Alice\"\n;; Explanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.\n;; If Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\n;; If Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\n;; Remember that both play optimally so here Alice will choose the scenario that makes her win.\n;; Example 3:\n;; Input: stoneValue = [1,2,3,6]\n;; Output: \"Tie\"\n;; Explanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\n;; Constraints:\n;; 1 <= stoneValue.length <= 5 * 104\n;; -1000 <= stoneValue[i] <= 1000\n(define (stoneGameIII stoneValue)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1131_stoneGameIII.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate stoneGameIII))\n    (check-within (candidate (list 1 2 3 4)) \"Bob\" 0.001)\n    (check-within (candidate (list 1 -1 1 -1 1 -1 1 -1 1)) \"Alice\" 0.001)\n    (check-within (candidate (list 1 -2 3 6 5 -10 13 -3 -5 13 -5 -2 11 -6 -3 -1 3 -1 -4 -6 -3 11)) \"Alice\" 0.001)\n    (check-within (candidate (list 1 2 3 7 -9 -8 1 2 3 7 -9 -8 1 2 3 7 -9 -8 1 2 3 7 -9 -8 1 2 3 7 -9 -8)) \"Bob\" 0.001)\n    (check-within (candidate (list 1 2 3 0 0 0 0 0)) \"Alice\" 0.001)\n    (check-within (candidate (list 1 2 3 -9)) \"Alice\" 0.001)\n    (check-within (candidate (list 1)) \"Alice\" 0.001)\n    (check-within (candidate (list 1 -1 2 -2 3 -3 4 -4 5 -5 6 -6 7 -7 8 -8 9 -9)) \"Alice\" 0.001)\n    (check-within (candidate (list 1 -2 3 6 5 -10 13 -3 -5 13 -5 -2 11 -6 -3 -1 3 -1 -4 -6 -3 11 -4 -6 13 -6)) \"Alice\" 0.001)\n    (check-within (candidate (list 1 2 3 -1 -2 -3 7)) \"Alice\" 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) \"Alice\" 0.001)\n    (check-within (candidate (list 1 2 3 7)) \"Bob\" 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0 0 0)) \"Tie\" 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1155_kthSmallest", "language": "rkt", "prompt": "#lang racket\n;; You are given an m x n matrix mat that has its rows sorted in non-decreasing order and an integer k.\n;; You are allowed to choose exactly one element from each row to form a list.\n;; Return the kth smallest list sum among all possible lists.\n;; Example 1:\n;; Input: mat = [[1,3,11],[2,4,6]], k = 5\n;; Output: 7\n;; Explanation: Choosing one element from each row, the first k smallest sum are:\n;; [1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.\n;; Example 2:\n;; Input: mat = [[1,3,11],[2,4,6]], k = 9\n;; Output: 17\n;; Example 3:\n;; Input: mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7\n;; Output: 9\n;; Explanation: Choosing one element from each row, the first k smallest sum are:\n;; [1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  \n;; Constraints:\n;; m == mat.length\n;; n == mat.length[i]\n;; 1 <= m, n <= 40\n;; 1 <= mat[i][j] <= 5000\n;; 1 <= k <= min(200, nm)\n;; mat[i] is a non-decreasing list.\n(define (kthSmallest mat k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1155_kthSmallest.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate kthSmallest))\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 6) 6 0.001)\n    (check-within (candidate (list (list 1 1 1) (list 1 1 1) (list 1 1 1)) 5) 1 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 7) 7 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 2) 2 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 5) 5 0.001)\n    (check-within (candidate (list (list 1 4 7 10 13 16 19) (list 2 5 8 11 14 17 20) (list 3 6 9 12 15 18 21)) 8) 8 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 4) 4 0.001)\n    (check-within (candidate (list (list 1 4 7) (list 3 5 8) (list 1 1 2)) 9) 8 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 1 2 3) (list 1 2 3)) 3) 1 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 1) 1 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 3) 3 0.001)\n    (check-within (candidate (list (list 1 4 7) (list 3 5 8) (list 1 1 2)) 8) 7 0.001)\n    (check-within (candidate (list (list 10 20 30 40) (list 15 25 35 45) (list 24 29 37 48) (list 32 33 39 50)) 7) 30 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 8) 8 0.001)\n    (check-within (candidate (list (list 1 10 15) (list 2 11 20) (list 3 12 30)) 5) 11 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) 9) 9 0.001)\n    (check-within (candidate (list (list 1 4 7 10 13 16 19) (list 2 5 8 11 14 17 20) (list 3 6 9 12 15 18 21)) 1) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1172_maxDotProduct", "language": "rkt", "prompt": "#lang racket\n;; Given two lists nums1\u00a0and nums2.\n;; Return the maximum dot product\u00a0between\u00a0non-empty subsequences of nums1 and nums2 with the same length.\n;; A subsequence of a list is a new list which is formed from the original list by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie,\u00a0[2,3,5]\u00a0is a subsequence of\u00a0[1,2,3,4,5]\u00a0while [1,5,3]\u00a0is not).\n;; Example 1:\n;; Input: nums1 = [2,1,-2,5], nums2 = [3,0,-6]\n;; Output: 18\n;; Explanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.\n;; Their dot product is (2*3 + (-2)*(-6)) = 18.\n;; Example 2:\n;; Input: nums1 = [3,-2], nums2 = [2,-6,7]\n;; Output: 21\n;; Explanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.\n;; Their dot product is (3*7) = 21.\n;; Example 3:\n;; Input: nums1 = [-1,-1], nums2 = [1,1]\n;; Output: -1\n;; Explanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.\n;; Their dot product is -1.\n;; Constraints:\n;; 1 <= nums1.length, nums2.length <= 500\n;; -1000 <= nums1[i], nums2[i] <= 1000\n(define (maxDotProduct nums1 nums2)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1172_maxDotProduct.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maxDotProduct))\n    (check-within (candidate (list 1 2 3 4 5) (list 1 2 3 4 5)) 55 0.001)\n    (check-within (candidate (list -4 4) (list 2 -2)) 8 0.001)\n    (check-within (candidate (list -1 -1 -1) (list 1 1 1)) -1 0.001)\n    (check-within (candidate (list -4 4) (list 0 0)) 0 0.001)\n    (check-within (candidate (list 1 0 1) (list 1 0 1)) 2 0.001)\n    (check-within (candidate (list -1 2 3) (list -1 0 1)) 4 0.001)\n    (check-within (candidate (list 1 2 3 4 5) (list 2 3 4 5 6)) 70 0.001)\n    (check-within (candidate (list 1 2 3) (list 4 5)) 23 0.001)\n    (check-within (candidate (list 1) (list 1)) 1 0.001)\n    (check-within (candidate (list 1 2 3) (list 4 5 6)) 32 0.001)\n    (check-within (candidate (list -1 2 3) (list 4 -5 6)) 26 0.001)\n    (check-within (candidate (list 1 1 1) (list 2 2 2)) 6 0.001)\n    (check-within (candidate (list 1 0 1 0 -1 0) (list -1 0 1 1 1 0)) 2 0.001)\n    (check-within (candidate (list 0 0 0) (list 0 0 0)) 0 0.001)\n    (check-within (candidate (list -1 -1) (list 1 1)) -1 0.001)\n    (check-within (candidate (list 1 1 1) (list 1 2 3)) 6 0.001)\n    (check-within (candidate (list 2 3 4) (list 5 6 7)) 56 0.001)\n    (check-within (candidate (list -1 -1) (list 1 1)) -1 0.001)\n    (check-within (candidate (list -2 -1 -1 -1) (list 1 0 1 1)) 0 0.001)\n    (check-within (candidate (list 1 2 3) (list 1 1 1)) 6 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1194_maximumRequests", "language": "rkt", "prompt": "#lang racket\n;; We have n buildings numbered from 0 to n - 1. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in.\n;; You are given a list requests where requests[i] = [fromi, toi] represents an employee's request to transfer from building fromi to building toi.\n;; All buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. This means the number of employees leaving is equal to the number of employees moving in. For example if n = 3 and two employees are leaving building 0, one is leaving building 1, and one is leaving building 2, there should be two employees moving to building 0, one employee moving to building 1, and one employee moving to building 2.\n;; Return the maximum number of achievable requests.\n;; Example 1:\n;; Input: n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\n;; Output: 5\n;; Explantion: Let's see the requests:\n;; From building 0 we have employees x and y and both want to move to building 1.\n;; From building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.\n;; From building 2 we have employee z and they want to move to building 0.\n;; From building 3 we have employee c and they want to move to building 4.\n;; From building 4 we don't have any requests.\n;; We can achieve the requests of users x and b by swapping their places.\n;; We can achieve the requests of users y, a and z by swapping the places in the 3 buildings.\n;; Example 2:\n;; Input: n = 3, requests = [[0,0],[1,2],[2,1]]\n;; Output: 3\n;; Explantion: Let's see the requests:\n;; From building 0 we have employee x and they want to stay in the same building 0.\n;; From building 1 we have employee y and they want to move to building 2.\n;; From building 2 we have employee z and they want to move to building 1.\n;; We can achieve all the requests. \n;; Example 3:\n;; Input: n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]\n;; Output: 4\n;; Constraints:\n;; 1 <= n <= 20\n;; 1 <= requests.length <= 16\n;; requests[i].length == 2\n;; 0 <= fromi, toi < n\n(define (maximumRequests n requests)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1194_maximumRequests.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximumRequests))\n    (check-within (candidate 4 (list (list 0 1) (list 1 2) (list 2 3) (list 3 0) (list 0 2) (list 2 0) (list 1 3) (list 3 1))) 8 0.001)\n    (check-within (candidate 5 (list (list 0 1) (list 1 0) (list 0 1) (list 1 2) (list 2 0) (list 3 4))) 5 0.001)\n    (check-within (candidate 3 (list (list 0 1) (list 1 2) (list 2 0) (list 1 0) (list 2 0))) 3 0.001)\n    (check-within (candidate 1 (list (list 0 0))) 1 0.001)\n    (check-within (candidate 2 (list (list 0 1) (list 1 1))) 1 0.001)\n    (check-within (candidate 5 (list (list 0 3) (list 3 1) (list 1 2) (list 2 0))) 4 0.001)\n    (check-within (candidate 3 (list (list 0 1) (list 1 2) (list 2 0) (list 1 0))) 3 0.001)\n    (check-within (candidate 5 (list (list 0 1) (list 1 2) (list 2 3) (list 3 4) (list 4 0))) 5 0.001)\n    (check-within (candidate 6 (list (list 0 1) (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 0))) 6 0.001)\n    (check-within (candidate 3 (list (list 0 2) (list 2 1) (list 1 0))) 3 0.001)\n    (check-within (candidate 7 (list (list 0 1) (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 0))) 7 0.001)\n    (check-within (candidate 4 (list (list 3 2) (list 3 3) (list 0 3) (list 2 3) (list 1 2))) 3 0.001)\n    (check-within (candidate 4 (list (list 0 3) (list 3 1) (list 1 2) (list 2 0))) 4 0.001)\n    (check-within (candidate 3 (list (list 0 0) (list 1 2) (list 2 1))) 3 0.001)\n    (check-within (candidate 5 (list (list 0 1) (list 1 2) (list 2 3) (list 3 4) (list 4 0) (list 0 2) (list 1 3) (list 2 4) (list 3 0) (list 4 1) (list 3 1) (list 2 3) (list 1 4))) 12 0.001)\n    (check-within (candidate 2 (list (list 0 1) (list 1 0) (list 0 1) (list 1 0))) 4 0.001)\n    (check-within (candidate 3 (list (list 1 0) (list 2 1) (list 0 2) (list 2 0) (list 1 0))) 3 0.001)\n    (check-within (candidate 2 (list (list 0 1) (list 1 0) (list 0 1) (list 1 0) (list 0 1) (list 1 0) (list 0 1) (list 1 0))) 8 0.001)\n    (check-within (candidate 1 (list )) 0 0.001)\n    (check-within (candidate 3 (list (list 0 1) (list 1 2) (list 2 0) (list 0 1) (list 1 2) (list 2 0))) 6 0.001)\n    (check-within (candidate 5 (list (list 0 1) (list 1 0) (list 2 3) (list 3 2) (list 4 0) (list 0 4) (list 2 4) (list 4 2))) 8 0.001)\n    (check-within (candidate 6 (list (list 0 1) (list 1 0) (list 0 1) (list 1 0) (list 0 1) (list 1 0))) 6 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1198_busiestServers", "language": "rkt", "prompt": "#lang racket\n;; You have k servers numbered from 0 to k-1 that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but cannot handle more than one request at a time. The requests are assigned to servers according to a specific algorithm:\n;; The ith (0-indexed) request arrives.\n;; If all servers are busy, the request is dropped (not handled at all).\n;; If the (i % k)th server is available, assign the request to that server.\n;; Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the ith server is busy, try to assign the request to the (i+1)th server, then the (i+2)th server, and so on.\n;; You are given a strictly increasing list arrival of positive integers, where arrival[i] represents the arrival time of the ith request, and another list load, where load[i] represents the load of the ith request (the time it takes to complete). Your goal is to find the busiest server(s). A server is considered busiest if it handled the most number of requests successfully among all the servers.\n;; Return a list containing the IDs (0-indexed) of the busiest server(s). You may return the IDs in any order.\n;; Example 1:\n;; Input: k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] \n;; Output: [1] \n;; Explanation: \n;; All of the servers start out available.\n;; The first 3 requests are handled by the first 3 servers in order.\n;; Request 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1.\n;; Request 4 comes in. It cannot be handled since all servers are busy, so it is dropped.\n;; Servers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.\n;; Example 2:\n;; Input: k = 3, arrival = [1,2,3,4], load = [1,2,1,2]\n;; Output: [0]\n;; Explanation: \n;; The first 3 requests are handled by first 3 servers.\n;; Request 3 comes in. It is handled by server 0 since the server is available.\n;; Server 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.\n;; Example 3:\n;; Input: k = 3, arrival = [1,2,3], load = [10,12,11]\n;; Output: [0,1,2]\n;; Explanation: Each server handles a single request, so they are all considered the busiest.\n;; Constraints:\n;; 1 <= k <= 105\n;; 1 <= arrival.length, load.length <= 105\n;; arrival.length == load.length\n;; 1 <= arrival[i], load[i] <= 109\n;; arrival is strictly increasing.\n(define (busiestServers k arrival load)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1198_busiestServers.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate busiestServers))\n    (check-within (candidate 2 (list 1 2 3 4 5 6 7 8 9 10) (list 5 4 3 2 1 5 4 3 2 1)) (list 0 1) 0.001)\n    (check-within (candidate 1 (list 1 1 1) (list 1 1 1)) (list 0) 0.001)\n    (check-within (candidate 2 (list 1 3 5 7 9) (list 2 4 6 8 10)) (list 0 1) 0.001)\n    (check-within (candidate 3 (list 1 2 3 4) (list 1 2 1 2)) (list 0) 0.001)\n    (check-within (candidate 6 (list 1 2 3 4 5 6) (list 2 2 2 2 2 2)) (list 0 1 2 3 4 5) 0.001)\n    (check-within (candidate 3 (list 1 2 3) (list 10 12 11)) (list 0 1 2) 0.001)\n    (check-within (candidate 1 (list 1 2 3 4 5 6 7 8 9 10) (list 1 1 1 1 1 1 1 1 1 1)) (list 0) 0.001)\n    (check-within (candidate 3 (list 1 2 3 4 5) (list 5 2 3 3 3)) (list 1) 0.001)\n    (check-within (candidate 5 (list 1 1 1 1 1 1 1 1 1 1 1) (list 1 1 1 1 1 1 1 1 1 1 1)) (list 0 1 2 3 4) 0.001)\n    (check-within (candidate 5 (list 1 6 11 16 21 26 31 36 41 46) (list 5 5 5 5 5 5 5 5 5 5)) (list 0 1 2 3 4) 0.001)\n    (check-within (candidate 1 (list 1 1 1 1 1 1) (list 3 1 2 4 5 1)) (list 0) 0.001)\n    (check-within (candidate 3 (list 1 2 3) (list 10 12 11)) (list 0 1 2) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1206_winnerSquareGame", "language": "rkt", "prompt": "#lang racket\n;; Alice and Bob take turns playing a game, with Alice starting first.\n;; Initially, there are n stones in a pile. On each player's turn, that player makes a move consisting of removing any non-zero square number of stones in the pile.\n;; Also, if a player cannot make a move, he/she loses the game.\n;; Given a positive integer n, return true if and only if Alice wins the game otherwise return false, assuming both players play optimally.\n;; Example 1:\n;; Input: n = 1\n;; Output: true\n;; Explanation: Alice can remove 1 stone winning the game because Bob doesn't have any moves.\n;; Example 2:\n;; Input: n = 2\n;; Output: false\n;; Explanation: Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0).\n;; Example 3:\n;; Input: n = 4\n;; Output: true\n;; Explanation: n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0).\n;; Constraints:\n;; 1 <= n <= 105\n(define (winnerSquareGame n)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1206_winnerSquareGame.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate winnerSquareGame))\n    (check-within (candidate 14) #t 0.001)\n    (check-within (candidate 19) #t 0.001)\n    (check-within (candidate 9999) #t 0.001)\n    (check-within (candidate 7684) #t 0.001)\n    (check-within (candidate 28) #t 0.001)\n    (check-within (candidate 31) #t 0.001)\n    (check-within (candidate 7) #f 0.001)\n    (check-within (candidate 29) #t 0.001)\n    (check-within (candidate 16) #t 0.001)\n    (check-within (candidate 9) #t 0.001)\n    (check-within (candidate 27) #t 0.001)\n    (check-within (candidate 160) #t 0.001)\n    (check-within (candidate 4) #t 0.001)\n    (check-within (candidate 63) #t 0.001)\n    (check-within (candidate 22) #f 0.001)\n    (check-within (candidate 13) #t 0.001)\n    (check-within (candidate 9997) #t 0.001)\n    (check-within (candidate 1000) #t 0.001)\n    (check-within (candidate 1) #t 0.001)\n    (check-within (candidate 8) #t 0.001)\n    (check-within (candidate 81) #t 0.001)\n    (check-within (candidate 21) #t 0.001)\n    (check-within (candidate 11) #t 0.001)\n    (check-within (candidate 18) #t 0.001)\n    (check-within (candidate 2685) #f 0.001)\n    (check-within (candidate 2469) #t 0.001)\n    (check-within (candidate 15) #f 0.001)\n    (check-within (candidate 30) #t 0.001)\n    (check-within (candidate 32) #t 0.001)\n    (check-within (candidate 23) #t 0.001)\n    (check-within (candidate 33) #t 0.001)\n    (check-within (candidate 0) #f 0.001)\n    (check-within (candidate 5) #f 0.001)\n    (check-within (candidate 6) #t 0.001)\n    (check-within (candidate 85868) #t 0.001)\n    (check-within (candidate 24) #t 0.001)\n    (check-within (candidate 17) #f 0.001)\n    (check-within (candidate 3) #t 0.001)\n    (check-within (candidate 2) #f 0.001)\n    (check-within (candidate 26) #t 0.001)\n    (check-within (candidate 25) #t 0.001)\n    (check-within (candidate 3456) #t 0.001)\n    (check-within (candidate 8876) #t 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1211_findMaxValueOfEquation", "language": "rkt", "prompt": "#lang racket\n;; You are given a list points containing the coordinates of points on a 2D plane, sorted by the x-values, where points[i] = [xi, yi] such that xi < xj for all 1 <= i < j <= points.length. You are also given an integer k.\n;; Return the maximum value of the equation yi + yj + |xi - xj| where |xi - xj| <= k and 1 <= i < j <= points.length.\n;; It is guaranteed that there exists at least one pair of points that satisfy the constraint |xi - xj| <= k.\n;; Example 1:\n;; Input: points = [[1,3],[2,0],[5,10],[6,-10]], k = 1\n;; Output: 4\n;; Explanation: The first two points satisfy the condition |xi - xj| <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1.\n;; No other pairs satisfy the condition, so we return the max of 4 and 1.\n;; Example 2:\n;; Input: points = [[0,0],[3,0],[9,2]], k = 3\n;; Output: 3\n;; Explanation: Only the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3.\n;; Constraints:\n;; 2 <= points.length <= 105\n;; points[i].length == 2\n;; -108 <= xi, yi <= 108\n;; 0 <= k <= 2 * 108\n;; xi < xj for all 1 <= i < j <= points.length\n;; xi form a strictly increasing sequence.\n(define (findMaxValueOfEquation points k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1211_findMaxValueOfEquation.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate findMaxValueOfEquation))\n    (check-within (candidate (list (list 0 0) (list 3 0) (list 9 2)) 10) 11 0.001)\n    (check-within (candidate (list (list 0 0) (list 3 0) (list 9 2)) 3) 3 0.001)\n    (check-within (candidate (list (list 1 3) (list 2 0) (list 5 10) (list 6 -10)) 3) 13 0.001)\n    (check-within (candidate (list (list 0 0) (list 3 0) (list 9 2)) 9) 11 0.001)\n    (check-within (candidate (list (list 1 3) (list 2 0) (list 5 10) (list 6 -10)) 1) 4 0.001)\n    (check-within (candidate (list (list 0 0) (list 3 0) (list 9 2)) 12) 11 0.001)\n    (check-within (candidate (list (list 0 0) (list 3 0) (list 9 2)) 11) 11 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1217_minInteger", "language": "rkt", "prompt": "#lang racket\n;; You are given a string num representing the digits of a very large integer and an integer k. You are allowed to swap any two adjacent digits of the integer at most k times.\n;; Return the minimum integer you can obtain also as a string.\n;; Example 1:\n;; Input: num = \"4321\", k = 4\n;; Output: \"1342\"\n;; Explanation: The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown.\n;; Example 2:\n;; Input: num = \"100\", k = 1\n;; Output: \"010\"\n;; Explanation: It's ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros.\n;; Example 3:\n;; Input: num = \"36789\", k = 1000\n;; Output: \"36789\"\n;; Explanation: We can keep the number without any swaps.\n;; Constraints:\n;; 1 <= num.length <= 3 * 104\n;; num consists of only digits and does not contain leading zeros.\n;; 1 <= k <= 109\n(define (minInteger num k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1217_minInteger.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minInteger))\n    (check-within (candidate \"abcdefghijklm\" 6) \"abcdefghijklm\" 0.001)\n    (check-within (candidate \"36789\" 1) \"36789\" 0.001)\n    (check-within (candidate \"4321\" 3) \"1432\" 0.001)\n    (check-within (candidate \"0001\" 1) \"0001\" 0.001)\n    (check-within (candidate \"4321\" 4) \"1342\" 0.001)\n    (check-within (candidate \"100\" 1) \"010\" 0.001)\n    (check-within (candidate \"abcdefghijklm\" 7) \"abcdefghijklm\" 0.001)\n    (check-within (candidate \"4321\" 1) \"3421\" 0.001)\n    (check-within (candidate \"36789\" 0) \"36789\" 0.001)\n    (check-within (candidate \"abcdefghij\" 4) \"abcdefghij\" 0.001)\n    (check-within (candidate \"4321\" 4) \"1342\" 0.001)\n    (check-within (candidate \"36789\" 1000) \"36789\" 0.001)\n    (check-within (candidate \"1000\" 0) \"1000\" 0.001)\n    (check-within (candidate \"36789\" 1000) \"36789\" 0.001)\n    (check-within (candidate \"2134\" 2) \"1234\" 0.001)\n    (check-within (candidate \"abcdefghij\" 10) \"abcdefghij\" 0.001)\n    (check-within (candidate \"1234567890\" 0) \"1234567890\" 0.001)\n    (check-within (candidate \"4321\" 2) \"2431\" 0.001)\n    (check-within (candidate \"0001\" 3) \"0001\" 0.001)\n    (check-within (candidate \"hgfedcba\" 0) \"hgfedcba\" 0.001)\n    (check-within (candidate \"abcdefghijklm\" 13) \"abcdefghijklm\" 0.001)\n    (check-within (candidate \"100\" 0) \"100\" 0.001)\n    (check-within (candidate \"0001\" 0) \"0001\" 0.001)\n    (check-within (candidate \"7654321\" 1) \"6754321\" 0.001)\n    (check-within (candidate \"abcdefghijklm\" 0) \"abcdefghijklm\" 0.001)\n    (check-within (candidate \"4321\" 0) \"4321\" 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1224_numWays", "language": "rkt", "prompt": "#lang racket\n;; You are given a list of strings of the same length words and a string target.\n;; Your task is to form target using the given words under the following rules:\n;; target should be formed from left to right.\n;; To form the ith character (0-indexed) of target, you can choose the kth character of the jth string in words if target[i] = words[j][k].\n;; Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\n;; Repeat the process until you form the string target.\n;; Notice that you can use multiple characters from the same string in words provided the conditions above are met.\n;; Return the number of ways to form target from words. Since the answer may be too large, return it modulo 109 + 7.\n;; Example 1:\n;; Input: words = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\"\n;; Output: 6\n;; Explanation: There are 6 ways to form target.\n;; \"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n;; \"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n;; \"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n;; \"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")\n;; \"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"acca\")\n;; \"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n;; Example 2:\n;; Input: words = [\"abba\",\"baab\"], target = \"bab\"\n;; Output: 4\n;; Explanation: There are 4 ways to form target.\n;; \"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 2 (\"abba\")\n;; \"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 3 (\"baab\")\n;; \"bab\" -> index 0 (\"baab\"), index 2 (\"baab\"), index 3 (\"baab\")\n;; \"bab\" -> index 1 (\"abba\"), index 2 (\"baab\"), index 3 (\"baab\")\n;; Constraints:\n;; 1 <= words.length <= 1000\n;; 1 <= words[i].length <= 1000\n;; All strings in words have the same length.\n;; 1 <= target.length <= 1000\n;; words[i] and target contain only lowercase English letters.\n(define (numWays words target)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1224_numWays.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate numWays))\n    (check-within (candidate (list \"abc\" \"def\" \"ghi\") \"def\") 1 0.001)\n    (check-within (candidate (list \"abcd\" \"efgh\" \"ijkl\" \"mnop\" \"qrst\" \"uvwx\" \"yz\") \"qrst\") 1 0.001)\n    (check-within (candidate (list \"abc\" \"def\" \"ghi\") \"ghi\") 1 0.001)\n    (check-within (candidate (list \"abc\" \"def\" \"ghi\") \"de\") 1 0.001)\n    (check-within (candidate (list \"abcd\") \"abcd\") 1 0.001)\n    (check-within (candidate (list \"abc\" \"def\" \"ghi\") \"xyz\") 0 0.001)\n    (check-within (candidate (list \"a\" \"a\" \"a\" \"a\" \"a\" \"a\") \"eeee\") 0 0.001)\n    (check-within (candidate (list \"abcd\") \"ab\") 1 0.001)\n    (check-within (candidate (list \"abc\" \"def\" \"ghi\") \"abc\") 1 0.001)\n    (check-within (candidate (list \"aaa\" \"aaa\" \"aaa\") \"abcc\") 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1246_minimumEffort", "language": "rkt", "prompt": "#lang racket\n;; You are given a list tasks where tasks[i] = [actuali, minimumi]:\n;; actuali is the actual amount of energy you spend to finish the ith task.\n;; minimumi is the minimum amount of energy you require to begin the ith task.\n;; For example, if the task is [10, 12] and your current energy is 11, you cannot start this task. However, if your current energy is 13, you can complete this task, and your energy will be 3 after finishing it.\n;; You can finish the tasks in any order you like.\n;; Return the minimum initial amount of energy you will need to finish all the tasks.\n;; Example 1:\n;; Input: tasks = [[1,2],[2,4],[4,8]]\n;; Output: 8\n;; Explanation:\n;; Starting with 8 energy, we finish the tasks in the following order:\n;;     - 3rd task. Now energy = 8 - 4 = 4.\n;;     - 2nd task. Now energy = 4 - 2 = 2.\n;;     - 1st task. Now energy = 2 - 1 = 1.\n;; Notice that even though we have leftover energy, starting with 7 energy does not work because we cannot do the 3rd task.\n;; Example 2:\n;; Input: tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]\n;; Output: 32\n;; Explanation:\n;; Starting with 32 energy, we finish the tasks in the following order:\n;;     - 1st task. Now energy = 32 - 1 = 31.\n;;     - 2nd task. Now energy = 31 - 2 = 29.\n;;     - 3rd task. Now energy = 29 - 10 = 19.\n;;     - 4th task. Now energy = 19 - 10 = 9.\n;;     - 5th task. Now energy = 9 - 8 = 1.\n;; Example 3:\n;; Input: tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]\n;; Output: 27\n;; Explanation:\n;; Starting with 27 energy, we finish the tasks in the following order:\n;;     - 5th task. Now energy = 27 - 5 = 22.\n;;     - 2nd task. Now energy = 22 - 2 = 20.\n;;     - 3rd task. Now energy = 20 - 3 = 17.\n;;     - 1st task. Now energy = 17 - 1 = 16.\n;;     - 4th task. Now energy = 16 - 4 = 12.\n;;     - 6th task. Now energy = 12 - 6 = 6.\n;; Constraints:\n;; 1 <= tasks.length <= 105\n;; 1 <= actual\u200bi\u00a0<= minimumi\u00a0<= 104\n(define (minimumEffort tasks)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1246_minimumEffort.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minimumEffort))\n    (check-within (candidate (list (list 1 7) (list 2 8) (list 3 9) (list 4 10) (list 5 11) (list 6 12))) 27 0.001)\n    (check-within (candidate (list (list 1 3) (list 2 4) (list 10 11) (list 10 12) (list 8 9))) 32 0.001)\n    (check-within (candidate (list (list 5 10) (list 10 20) (list 20 40))) 40 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 4) (list 4 8))) 8 0.001)\n    (check-within (candidate (list (list 1 1) (list 2 2) (list 3 3) (list 4 4) (list 5 5) (list 6 6) (list 7 7) (list 8 8) (list 9 9) (list 10 10))) 55 0.001)\n    (check-within (candidate (list (list 1 3) (list 5 8))) 8 0.001)\n    (check-within (candidate (list (list 1 1))) 1 0.001)\n    (check-within (candidate (list (list 1 2) (list 1 2) (list 1 2) (list 1 2) (list 1 2) (list 1 2) (list 1 2) (list 1 2) (list 1 2) (list 1 2) (list 1 2))) 12 0.001)\n    (check-within (candidate (list (list 2 2) (list 3 3) (list 4 4) (list 5 5))) 14 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_124_maximumGap", "language": "rkt", "prompt": "#lang racket\n;; Given an integer list nums, return the maximum difference between two successive elements in its sorted form. If the list contains less than two elements, return 0.\n;; You must write an algorithm that runs in linear time and uses linear extra space.\n;; Example 1:\n;; Input: nums = [3,6,9,1]\n;; Output: 3\n;; Explanation: The sorted form of the list is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.\n;; Example 2:\n;; Input: nums = [10]\n;; Output: 0\n;; Explanation: The list contains less than 2 elements, therefore return 0.\n;; Constraints:\n;; 1 <= nums.length <= 105\n;; 0 <= nums[i] <= 109\n(define (maximumGap nums)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_124_maximumGap.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximumGap))\n    (check-within (candidate (list 1 0 1 0 1 0 1 0 1 0)) 1 0.001)\n    (check-within (candidate (list 1 2 4 8 16 32 64 128 256 512)) 256 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0 0 0 0 1)) 1 0.001)\n    (check-within (candidate (list 0)) 0 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1)) 0 0.001)\n    (check-within (candidate (list 1 3 6 9 12 15 18 21 24 27)) 3 0.001)\n    (check-within (candidate (list 9 8 7 6 5 4 3 2 1 0)) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10)) 1 0.001)\n    (check-within (candidate (list 1000 2000 3000 4000 5000 6000 7000 8000 9000 10000)) 1000 0.001)\n    (check-within (candidate (list 10 20 30 40 50 60 70 80 90 100)) 10 0.001)\n    (check-within (candidate (list 0 0 0 1 1 1 1 1 1 1)) 1 0.001)\n    (check-within (candidate (list 10 100 1000 10000 100000 1000000 10000000)) 9000000 0.001)\n    (check-within (candidate (list 100 200 300 400 500 600 700 800 900 1000)) 100 0.001)\n    (check-within (candidate (list 3 6 9 1)) 3 0.001)\n    (check-within (candidate (list 1 10 100 1000 10000 100000 1000000)) 900000 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0 0 0 0 0)) 0 0.001)\n    (check-within (candidate (list )) 0 0.001)\n    (check-within (candidate (list 1 2 3 5 8 13 21 34 55 89)) 34 0.001)\n    (check-within (candidate (list 5 10 15 20 25 30 35 40 45 50)) 5 0.001)\n    (check-within (candidate (list 1 1 1 1 1 2 2 2 2 2)) 1 0.001)\n    (check-within (candidate (list 10)) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1250_minimumMountainRemovals", "language": "rkt", "prompt": "#lang racket\n;; You may recall that a list arr is a mountain list if and only if:\n;; arr.length >= 3\n;; There exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:\n;; arr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n;; arr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n;; Given an integer list nums\u200b\u200b\u200b, return the minimum number of elements to remove to make nums\u200b\u200b\u200b a mountain list.\n;; Example 1:\n;; Input: nums = [1,3,1]\n;; Output: 0\n;; Explanation: The list itself is a mountain list so we do not need to remove any elements.\n;; Example 2:\n;; Input: nums = [2,1,1,5,6,2,3,1]\n;; Output: 3\n;; Explanation: One solution is to remove the elements at indices 0, 1, and 5, making the list nums = [1,5,6,3,1].\n;; Constraints:\n;; 3 <= nums.length <= 1000\n;; 1 <= nums[i] <= 109\n;; It is guaranteed that you can make a mountain list out of nums.\n(define (minimumMountainRemovals nums)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1250_minimumMountainRemovals.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minimumMountainRemovals))\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1)) 7 0.001)\n    (check-within (candidate (list 1 5 6 3 1)) 0 0.001)\n    (check-within (candidate (list 1 2 3 2 1)) 0 0.001)\n    (check-within (candidate (list 1 3 1)) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 4 3 2 1)) 1 0.001)\n    (check-within (candidate (list 2 1 1 5 6 2 3 1)) 3 0.001)\n    (check-within (candidate (list 1 2 3 4 4 3 2 1 2 1)) 2 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 8 7 6 5 4 3 2 1)) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 4 3 2 1 3)) 2 0.001)\n    (check-within (candidate (list 3 2 1 4 3 2 4 3 2 1 4 3)) 4 0.001)\n    (check-within (candidate (list 1 2 3 4 4 4 3 1)) 2 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1269_isPrintable", "language": "rkt", "prompt": "#lang racket\n;; There is a strange printer with the following two special requirements:\n;; On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\n;; Once the printer has used a color for the above operation, the same color cannot be used again.\n;; You are given a m x n matrix targetGrid, where targetGrid[row][col] is the color in the position (row, col) of the grid.\n;; Return true if it is possible to print the matrix targetGrid, otherwise, return false.\n;; Example 1:\n;; Input: targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]\n;; Output: true\n;; Example 2:\n;; Input: targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]\n;; Output: true\n;; Example 3:\n;; Input: targetGrid = [[1,2,1],[2,1,2],[1,2,1]]\n;; Output: false\n;; Explanation: It is impossible to form targetGrid because it is not allowed to print the same color in different turns.\n;; Constraints:\n;; m == targetGrid.length\n;; n == targetGrid[i].length\n;; 1 <= m, n <= 60\n;; 1 <= targetGrid[row][col] <= 60\n(define (isPrintable targetGrid)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1269_isPrintable.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate isPrintable))\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6))) #f 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 2 3 1) (list 1 2 3 1) (list 1 1 1 1))) #f 0.001)\n    (check-within (candidate (list (list 1 2 1) (list 2 1 2) (list 1 2 1) (list 2 1 2) (list 1 2 1) (list 2 1 2) (list 1 2 1) (list 2 1 2) (list 1 2 1) (list 2 1 2))) #f 0.001)\n    (check-within (candidate (list (list 1 1 1 1) (list 1 1 1 1) (list 1 1 1 1) (list 1 1 1 1))) #t 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6))) #f 0.001)\n    (check-within (candidate (list (list 1 2 3 4) (list 1 2 3 4) (list 1 2 3 4) (list 1 2 3 4) (list 1 2 3 4) (list 1 2 3 4) (list 1 2 3 4) (list 1 2 3 4))) #f 0.001)\n    (check-within (candidate (list (list 1 2 1) (list 2 1 2) (list 1 2 1) (list 2 1 2) (list 1 2 1) (list 2 1 2) (list 1 2 1))) #f 0.001)\n    (check-within (candidate (list (list 1 2 1) (list 2 1 2) (list 1 2 1))) #f 0.001)\n    (check-within (candidate (list (list 1 2 1 2) (list 2 1 2 1) (list 1 2 1 2) (list 2 1 2 1))) #f 0.001)\n    (check-within (candidate (list (list 1 2 1) (list 2 1 2) (list 1 2 1) (list 2 1 2))) #f 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5 6 7 8) (list 8 7 6 5 4 3 2 1) (list 1 2 3 4 5 6 7 8) (list 8 7 6 5 4 3 2 1) (list 1 2 3 4 5 6 7 8) (list 8 7 6 5 4 3 2 1) (list 1 2 3 4 5 6 7 8) (list 8 7 6 5 4 3 2 1))) #f 0.001)\n    (check-within (candidate (list (list 1 2 3 4) (list 2 1 2 3) (list 3 2 1 2) (list 4 3 2 12))) #f 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6))) #f 0.001)\n    (check-within (candidate (list (list 1 2 1) (list 2 1 2) (list 1 2 1))) #f 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1270_distanceLimitedPathsExist", "language": "rkt", "prompt": "#lang racket\n;; An undirected graph of n nodes is defined by edgeList, where edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with distance disi. Note that there may be multiple edges between two nodes.\n;; Given a list queries, where queries[j] = [pj, qj, limitj], your task is to determine for each queries[j] whether there is a path between pj and qj such that each edge on the path has a distance strictly less than limitj .\n;; Return a boolea list answer, where answer.length == queries.length and the jth value of answer is true if there is a path for queries[j] is true, and false otherwise.\n;; Example 1:\n;; Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\n;; Output: [false,true]\n;; Explanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.\n;; For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.\n;; For the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query.\n;; Example 2:\n;; Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]\n;; Output: [true,false]\n;; Explanation: The above figure shows the given graph.\n;; Constraints:\n;; 2 <= n <= 105\n;; 1 <= edgeList.length, queries.length <= 105\n;; edgeList[i].length == 3\n;; queries[j].length == 3\n;; 0 <= ui, vi, pj, qj <= n - 1\n;; ui != vi\n;; pj != qj\n;; 1 <= disi, limitj <= 109\n;; There may be multiple edges between two nodes.\n(define (distanceLimitedPathsExist n edgeList queries)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1270_distanceLimitedPathsExist.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate distanceLimitedPathsExist))\n    (check-within (candidate 2 (list (list 0 1 3)) (list (list 0 1 2))) (list #f) 0.001)\n    (check-within (candidate 3 (list (list 0 1 1) (list 1 2 1) (list 2 0 1)) (list (list 0 2 1))) (list #f) 0.001)\n    (check-within (candidate 4 (list (list 0 1 3) (list 1 2 1) (list 2 3 1)) (list (list 0 3 2))) (list #f) 0.001)\n    (check-within (candidate 2 (list (list 0 1 3)) (list (list 0 1 4))) (list #t) 0.001)\n    (check-within (candidate 3 (list (list 0 1 1) (list 1 2 1) (list 2 0 1)) (list (list 0 2 2) (list 2 0 2) (list 0 1 2))) (list #t #t #t) 0.001)\n    (check-within (candidate 4 (list (list 0 1 3) (list 1 2 1) (list 2 3 1) (list 3 0 1)) (list (list 0 3 2))) (list #t) 0.001)\n    (check-within (candidate 2 (list (list 0 1 1)) (list (list 0 1 2))) (list #t) 0.001)\n    (check-within (candidate 5 (list (list 0 1 1) (list 1 2 1) (list 2 3 1) (list 3 4 1) (list 1 4 1) (list 0 4 2) (list 3 4 3) (list 1 2 4) (list 2 3 2) (list 1 3 2) (list 0 4 5) (list 2 4 1) (list 1 4 4)) (list (list 0 4 5) (list 1 4 5) (list 2 4 5) (list 3 4 5))) (list #t #t #t #t) 0.001)\n    (check-within (candidate 4 (list (list 0 1 3) (list 1 2 1) (list 2 3 1)) (list (list 0 3 1))) (list #f) 0.001)\n    (check-within (candidate 5 (list (list 0 1 1) (list 1 2 1) (list 2 3 1) (list 3 4 1) (list 0 4 2) (list 3 4 3) (list 1 2 4) (list 2 3 2) (list 1 3 2) (list 0 4 5) (list 2 4 1) (list 1 4 4)) (list (list 0 4 5) (list 1 4 5) (list 2 4 5) (list 3 4 5))) (list #t #t #t #t) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1280_busiest_servers", "language": "rkt", "prompt": "#lang racket\n;; You have k servers numbered from 0 to k-1 that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but cannot handle more than one request at a time. The requests are assigned to servers according to a specific algorithm:\n;; The ith (0-indexed) request arrives.\n;; If all servers are busy, the request is dropped (not handled at all).\n;; If the (i % k)th server is available, assign the request to that server.\n;; Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the ith server is busy, try to assign the request to the (i+1)th server, then the (i+2)th server, and so on.\n;; You are given a strictly increasing list arrival of positive integers, where arrival[i] represents the arrival time of the ith request, and another list load, where load[i] represents the load of the ith request (the time it takes to complete). Your goal is to find the busiest server(s). A server is considered busiest if it handled the most number of requests successfully among all the servers.\n;; Return a list containing the IDs (0-indexed) of the busiest server(s). You may return the IDs in any order.\n;; Example 1:\n;; Input: k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] \n;; Output: [1] \n;; Explanation: \n;; All of the servers start out available.\n;; The first 3 requests are handled by the first 3 servers in order.\n;; Request 3 comes in. Server 0 is busy, so it's assigned to the next available server, which is 1.\n;; Request 4 comes in. It cannot be handled since all servers are busy, so it is dropped.\n;; Servers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.\n;; Example 2:\n;; Input: k = 3, arrival = [1,2,3,4], load = [1,2,1,2]\n;; Output: [0]\n;; Explanation: \n;; The first 3 requests are handled by first 3 servers.\n;; Request 3 comes in. It is handled by server 0 since the server is available.\n;; Server 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.\n;; Example 3:\n;; Input: k = 3, arrival = [1,2,3], load = [10,12,11]\n;; Output: [0,1,2]\n;; Explanation: Each server handles a single request, so they are all considered the busiest.\n;; Constraints:\n;; 1 <= k <= 105\n;; 1 <= arrival.length, load.length <= 105\n;; arrival.length == load.length\n;; 1 <= arrival[i], load[i] <= 109\n;; arrival is strictly increasing.\n(define (busiest_servers k arrival load)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1280_busiest_servers.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate busiest_servers))\n    (check-within (candidate 3 (list 1 2 3 4 5) (list 5 2 3 3 3)) (list 1) 0.001)\n    (check-within (candidate 5 (list 1 2 3 4 5) (list 1 1 1 1 1)) (list 0 1 2 3 4) 0.001)\n    (check-within (candidate 2 (list 1 1 1 1 1 1 1 1) (list 3 1 5 1 1 1 3 1)) (list 0 1) 0.001)\n    (check-within (candidate 1 (list 1) (list 1)) (list 0) 0.001)\n    (check-within (candidate 1000 (list 1) (list 1000)) (list 0) 0.001)\n    (check-within (candidate 1000 (list 1000) (list 1000)) (list 0) 0.001)\n    (check-within (candidate 2 (list 1 2 3 4 5 6 7) (list 1 2 1 2 1 2 1)) (list 0) 0.001)\n    (check-within (candidate 5 (list 1 2 1 2 1 2 1 2 1 2) (list 8 12 4 10 12 6 13 15 7 13)) (list 0 1 2 3 4) 0.001)\n    (check-within (candidate 1 (list 1 1 1 1) (list 3 2 4 2)) (list 0) 0.001)\n    (check-within (candidate 3 (list 1 2 3 4 5 6 7 8 9) (list 1 1 1 1 1 1 1 1 1)) (list 0 1 2) 0.001)\n    (check-within (candidate 2 (list 1 2 3 4) (list 2 3 2 4)) (list 0) 0.001)\n    (check-within (candidate 3 (list 1 2 3 4 5) (list 1 2 2 2 1)) (list 0 1) 0.001)\n    (check-within (candidate 2 (list 1 2 3 4) (list 1 2 1 2)) (list 0) 0.001)\n    (check-within (candidate 3 (list 1 2 3 4) (list 1 2 1 2)) (list 0) 0.001)\n    (check-within (candidate 3 (list 1 2 3) (list 10 12 11)) (list 0 1 2) 0.001)\n    (check-within (candidate 1 (list 1) (list 3)) (list 0) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1283_minOperations", "language": "rkt", "prompt": "#lang racket\n;; You are given a list target that consists of distinct integers and another integer list arr that can have duplicates.\n;; In one operation, you can insert any integer at any position in arr. For example, if arr = [1,4,1,2], you can add 3 in the middle and make it [1,4,3,1,2]. Note that you can insert the integer at the very beginning or end of the list.\n;; Return the minimum number of operations needed to make target a subsequence of arr.\n;; A subsequence of a list is a new list generated from the original list by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.\n;; Example 1:\n;; Input: target = [5,1,3], arr = [9,4,2,3,4]\n;; Output: 2\n;; Explanation: You can add 5 and 1 in such a way that makes arr = [5,9,4,1,2,3,4], then target will be a subsequence of arr.\n;; Example 2:\n;; Input: target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]\n;; Output: 3\n;; Constraints:\n;; 1 <= target.length, arr.length <= 105\n;; 1 <= target[i], arr[i] <= 109\n;; target contains no duplicates.\n(define (minOperations target arr)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1283_minOperations.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minOperations))\n    (check-within (candidate (list 1 2 3 4 5) (list 5 4 3 2 1)) 4 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) (list 10 9 8 7 6 5 4 3 2 1)) 9 0.001)\n    (check-within (candidate (list 1 2 3) (list 1 2 3)) 0 0.001)\n    (check-within (candidate (list 100 200 300 400 500) (list 500 400 300 200 100)) 4 0.001)\n    (check-within (candidate (list 5 1 3) (list 9 4 2 3 4)) 2 0.001)\n    (check-within (candidate (list 1 2 3) (list 2 3 1)) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5) (list 3 4 5 1 2)) 2 0.001)\n    (check-within (candidate (list 1 2 3 4 5) (list 2 3 4 5 1)) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) (list 2 4 6 8 10 1 3 5 7 9)) 5 0.001)\n    (check-within (candidate (list 1 2 3) (list 3 2 1)) 2 0.001)\n    (check-within (candidate (list 6 4 8 1 3 2) (list 4 7 6 2 3 8 6 1)) 3 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) (list 5 6 7 8 9 10 4 3 2 1)) 4 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1287_check_ways", "language": "rkt", "prompt": "#lang racket\n;; You are given a list pairs, where pairs[i] = [xi, yi], and:\n;; There are no duplicates.\n;; xi < yi\n;; Let ways be the number of rooted trees that satisfy the following conditions:\n;; The tree consists of nodes whose values appeared in pairs.\n;; A pair [xi, yi] exists in pairs if and only if xi is an ancestor of yi or yi is an ancestor of xi.\n;; Note: the tree does not have to be a binary tree.\n;; Two ways are considered to be different if there is at least one node that has different parents in both ways.\n;; Return:\n;; 0 if ways == 0\n;; 1 if ways == 1\n;; 2 if ways > 1\n;; A rooted tree is a tree that has a single root node, and all edges are oriented to be outgoing from the root.\n;; An ancestor of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors.\n;; Example 1:\n;; Input: pairs = [[1,2],[2,3]]\n;; Output: 1\n;; Explanation: There is exactly one valid rooted tree, which is shown in the above figure.\n;; Example 2:\n;; Input: pairs = [[1,2],[2,3],[1,3]]\n;; Output: 2\n;; Explanation: There are multiple valid rooted trees. Three of them are shown in the above figures.\n;; Example 3:\n;; Input: pairs = [[1,2],[2,3],[2,4],[1,5]]\n;; Output: 0\n;; Explanation: There are no valid rooted trees.\n;; Constraints:\n;; 1 <= pairs.length <= 105\n;; 1 <= xi < yi <= 500\n;; The elements in pairs are unique.\n(define (check_ways pairs)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1287_check_ways.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_ways))\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 7) (list 7 8) (list 8 9) (list 1 9) (list 1 10) (list 7 10) (list 9 10) (list 9 11) (list 11 12) (list 11 13) (list 13 14))) 2 0.001)\n    (check-within (candidate (list (list -1000000000 1000000000) (list -1000000000 1000000000) (list -1000000000 1000000000) (list -1000000000 1000000000))) 0 0.001)\n    (check-within (candidate (list (list 1 2) (list 1 3) (list 1 4) (list 1 5) (list 5 6))) 2 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 1 3) (list 1 4) (list 1 5))) 2 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 5 6) (list 6 7))) 2 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 4 5) (list 5 6))) 2 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 7) (list 7 8) (list 8 9) (list 10 11) (list 11 12) (list 12 13) (list 13 14) (list 14 15) (list 15 16) (list 16 17) (list 17 18))) 2 0.001)\n    (check-within (candidate (list (list 1 2) (list 1 3) (list 1 4) (list 1 5) (list 2 6) (list 3 6) (list 4 6) (list 5 6))) 0 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 1 3) (list 1 4) (list 1 5))) 2 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 7) (list 7 8) (list 8 9) (list 10 11) (list 11 12) (list 12 13) (list 13 14) (list 14 15) (list 15 16) (list 16 17) (list 17 18) (list 19 20))) 2 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 1 3) (list 1 4) (list 1 5) (list 4 6))) 2 0.001)\n    (check-within (candidate (list (list 1 2) (list 3 4) (list 5 6) (list 7 8) (list 9 10))) 2 0.001)\n    (check-within (candidate (list (list 1 2) (list 3 4))) 2 0.001)\n    (check-within (candidate (list (list 9 10) (list 1 2) (list 2 3) (list 4 5) (list 5 6) (list 6 7) (list 2 8) (list 3 4) (list 2 1) (list 9 10) (list 5 1) (list 8 7) (list 8 6))) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1306_num_ways", "language": "rkt", "prompt": "#lang racket\n;; You are given a list of strings of the same length words and a string target.\n;; Your task is to form target using the given words under the following rules:\n;; target should be formed from left to right.\n;; To form the ith character (0-indexed) of target, you can choose the kth character of the jth string in words if target[i] = words[j][k].\n;; Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\n;; Repeat the process until you form the string target.\n;; Notice that you can use multiple characters from the same string in words provided the conditions above are met.\n;; Return the number of ways to form target from words. Since the answer may be too large, return it modulo 109 + 7.\n;; Example 1:\n;; Input: words = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\"\n;; Output: 6\n;; Explanation: There are 6 ways to form target.\n;; \"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n;; \"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n;; \"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n;; \"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")\n;; \"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"acca\")\n;; \"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n;; Example 2:\n;; Input: words = [\"abba\",\"baab\"], target = \"bab\"\n;; Output: 4\n;; Explanation: There are 4 ways to form target.\n;; \"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 2 (\"abba\")\n;; \"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 3 (\"baab\")\n;; \"bab\" -> index 0 (\"baab\"), index 2 (\"baab\"), index 3 (\"baab\")\n;; \"bab\" -> index 1 (\"abba\"), index 2 (\"baab\"), index 3 (\"baab\")\n;; Constraints:\n;; 1 <= words.length <= 1000\n;; 1 <= words[i].length <= 1000\n;; All strings in words have the same length.\n;; 1 <= target.length <= 1000\n;; words[i] and target contain only lowercase English letters.\n(define (num_ways words target)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1306_num_ways.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate num_ways))\n    (check-within (candidate (list \"aaa\") \"\") 1 0.001)\n    (check-within (candidate (list \"abc\" \"acd\" \"bcd\") \"b\") 2 0.001)\n    (check-within (candidate (list \"aaa\" \"aa\" \"a\") \"\") 1 0.001)\n    (check-within (candidate (list \"baba\" \"baba\" \"baba\") \"b\") 6 0.001)\n    (check-within (candidate (list \"aaa\") \"abababab\") 0 0.001)\n    (check-within (candidate (list \"abc\" \"acd\" \"bcd\") \"cd\") 6 0.001)\n    (check-within (candidate (list \"abc\" \"acd\" \"bcd\") \"ab\") 4 0.001)\n    (check-within (candidate (list \"aaa\") \"aab\") 0 0.001)\n    (check-within (candidate (list \"abc\" \"acd\" \"bcd\") \"a\") 2 0.001)\n    (check-within (candidate (list \"aaa\" \"aaa\" \"aaa\") \"b\") 0 0.001)\n    (check-within (candidate (list \"abc\" \"acd\" \"bcd\") \"ac\") 6 0.001)\n    (check-within (candidate (list \"abc\" \"acd\" \"bcd\") \"d\") 2 0.001)\n    (check-within (candidate (list \"abc\" \"acd\" \"bcd\") \"c\") 3 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1307_check_partitioning", "language": "rkt", "prompt": "#lang racket\n;; Given a string s, return true if it is possible to split the string s into three non-empty palindromic substrings. Otherwise, return false.\u200b\u200b\u200b\u200b\u200b\n;; A string is said to be palindrome if it the same string when reversed.\n;; Example 1:\n;; Input: s = \"abcbdd\"\n;; Output: true\n;; Explanation: \"abcbdd\" = \"a\" + \"bcb\" + \"dd\", and all three substrings are palindromes.\n;; Example 2:\n;; Input: s = \"bcbddxy\"\n;; Output: false\n;; Explanation: s cannot be split into 3 palindromes.\n;; Constraints:\n;; 3 <= s.length <= 2000\n;; s\u200b\u200b\u200b\u200b\u200b\u200b consists only of lowercase English letters.\n(define (check_partitioning s)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1307_check_partitioning.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_partitioning))\n    (check-within (candidate \"abcdddddcbcbbbbabbbbbabbbbbabbbbbbabcddddddddd\") #f 0.001)\n    (check-within (candidate \"abcdedcbaefggefg\") #f 0.001)\n    (check-within (candidate \"abcbddxyzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzabcbaabcbaabcba\") #f 0.001)\n    (check-within (candidate \"abcbdd\") #t 0.001)\n    (check-within (candidate \"aabaaba\") #t 0.001)\n    (check-within (candidate \"abcdefghihgfedcbaabcbaabcbaabcba\") #t 0.001)\n    (check-within (candidate \"abcdefedcbazzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzabcbaabcbaabcba\") #t 0.001)\n    (check-within (candidate \"abcbddxyzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzabcbaabcbaabcba\") #f 0.001)\n    (check-within (candidate \"abcbaabcbaabcba\") #t 0.001)\n    (check-within (candidate \"abcdefghihgfedcbaabcba\") #f 0.001)\n    (check-within (candidate \"bcbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxybbddxy\") #f 0.001)\n    (check-within (candidate \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbcccc\") #t 0.001)\n    (check-within (candidate \"abcdefghijklmnoponmlkjihgfedcbaabcbaabcbaabcbaabcba\") #t 0.001)\n    (check-within (candidate \"aaabbbccc\") #t 0.001)\n    (check-within (candidate \"abcdefedcbazzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzabcbaabcbaabcba\") #t 0.001)\n    (check-within (candidate \"aabaaaabbbbbaababbbbbbbababaabbbbabababbaaabbbabbbaaaabaaaaababaaababbbbababababbbaabaaababaaaabaaababbbbababababbbabbbaaaabbbbabbbbaabbababbbbbabbabababaababaabbbabbbbaabbbaabababaaaaabbbbbabbbaabbaabbaabbababbbbaabbaabbaabbbaabbaabababaaabababbbabababbbabbbabbbbbb\") #f 0.001)\n    (check-within (candidate \"abcbddxyabcdddcbaabcddabcabcddeabcdddabcddcbaabcddd\") #f 0.001)\n    (check-within (candidate \"bcbddxy\") #f 0.001)\n    (check-within (candidate \"aabbcc\") #t 0.001)\n    (check-within (candidate \"aaabbbbcccc\") #t 0.001)\n    (check-within (candidate \"abcbddxy\") #f 0.001)\n    (check-within (candidate \"aabaabaaaabbbbbabbbbbaabaabaaabaabaaaabaaaaababaa\") #f 0.001)\n    (check-within (candidate \"abcdefedcbaabcba\") #f 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_132_calculateMinimumHP", "language": "rkt", "prompt": "#lang racket\n;; The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess.\n;; The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\n;; Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\n;; To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\n;; Return the knight's minimum initial health so that he can rescue the princess.\n;; Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n;; Example 1:\n;; Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\n;; Output: 7\n;; Explanation: The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n;; Example 2:\n;; Input: dungeon = [[0]]\n;; Output: 1\n;; Constraints:\n;; m == dungeon.length\n;; n == dungeon[i].length\n;; 1 <= m, n <= 200\n;; -1000 <= dungeon[i][j] <= 1000\n(define (calculateMinimumHP dungeon)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_132_calculateMinimumHP.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate calculateMinimumHP))\n    (check-within (candidate (list (list -2 -3 3) (list -5 -10 1) (list 10 30 -5))) 7 0.001)\n    (check-within (candidate (list (list 0 -3))) 4 0.001)\n    (check-within (candidate (list (list 0))) 1 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 0 10 0) (list 0 0 -10))) 1 0.001)\n    (check-within (candidate (list (list -2 -3 3) (list -5 -10 1) (list 10 30 -5))) 7 0.001)\n    (check-within (candidate (list (list 2 1) (list 1 -2))) 1 0.001)\n    (check-within (candidate (list (list 1 -2 3) (list -2 2 -2))) 2 0.001)\n    (check-within (candidate (list (list 1 2 1) (list 1 2 1) (list 1 2 1))) 1 0.001)\n    (check-within (candidate (list (list -100))) 101 0.001)\n    (check-within (candidate (list (list -1 -3) (list -2 -3) (list -3 -3))) 10 0.001)\n    (check-within (candidate (list (list 1 -2 2 -1) (list 6 -2 -7 5))) 2 0.001)\n    (check-within (candidate (list (list 100))) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1348_minimum_deviation", "language": "rkt", "prompt": "#lang racket\n;; You are given a list nums of n positive integers.\n;; You can perform two types of operations on any element of the list any number of times:\n;; If the element is even, divide it by 2.\n;; For example, if the list is [1,2,3,4], then you can do this operation on the last element, and the list will be [1,2,3,2].\n;; If the element is odd, multiply it by 2.\n;; For example, if the list is [1,2,3,4], then you can do this operation on the first element, and the list will be [2,2,3,4].\n;; The deviation of the list is the maximum difference between any two elements in the list.\n;; Return the minimum deviation the list can have after performing some number of operations.\n;; Example 1:\n;; Input: nums = [1,2,3,4]\n;; Output: 1\n;; Explanation: You can transform the list to [1,2,3,2], then to [2,2,3,2], then the deviation will be 3 - 2 = 1.\n;; Example 2:\n;; Input: nums = [4,1,5,20,3]\n;; Output: 3\n;; Explanation: You can transform the list after two operations to [4,2,5,5,3], then the deviation will be 5 - 2 = 3.\n;; Example 3:\n;; Input: nums = [2,10,8]\n;; Output: 3\n;; Constraints:\n;; n == nums.length\n;; 2 <= n <= 5 * 104\n;; 1 <= nums[i] <= 109\n(define (minimum_deviation nums)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1348_minimum_deviation.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minimum_deviation))\n    (check-within (candidate (list 3 3 3 3 3 3)) 0 0.001)\n    (check-within (candidate (list 2 10 8)) 3 0.001)\n    (check-within (candidate (list 5 15 30 60)) 10 0.001)\n    (check-within (candidate (list 1 1 1 1)) 0 0.001)\n    (check-within (candidate (list 5 5 5 5 5 5 5 5 5 5)) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1356_min_moves", "language": "rkt", "prompt": "#lang racket\n;; You are given an integer list, nums, and an integer k. nums comprises of only 0's and 1's. In one move, you can choose two adjacent indices and swap their values.\n;; Return the minimum number of moves required so that nums has k consecutive 1's.\n;; Example 1:\n;; Input: nums = [1,0,0,1,0,1], k = 2\n;; Output: 1\n;; Explanation: In 1 move, nums could be [1,0,0,0,1,1] and have 2 consecutive 1's.\n;; Example 2:\n;; Input: nums = [1,0,0,0,0,0,1,1], k = 3\n;; Output: 5\n;; Explanation: In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,1,1,1].\n;; Example 3:\n;; Input: nums = [1,1,0,1], k = 2\n;; Output: 0\n;; Explanation: nums already has 2 consecutive 1's.\n;; Constraints:\n;; 1 <= nums.length <= 105\n;; nums[i] is 0 or 1.\n;; 1 <= k <= sum(nums)\n(define (min_moves nums k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1356_min_moves.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate min_moves))\n    (check-within (candidate (list 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 1 1 1 1 1 1 1 1) 11) 0 0.001)\n    (check-within (candidate (list 1 0 1 0 1 0 1 0 1 0) 5) 0 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0 0 0 0 1) 1) 0 0.001)\n    (check-within (candidate (list 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) 5) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_136_maxProfit", "language": "rkt", "prompt": "#lang racket\n;; You are given an integer list prices where prices[i] is the price of a given stock on the ith day, and an integer k.\n;; Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\n;; Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n;; Example 1:\n;; Input: k = 2, prices = [2,4,1]\n;; Output: 2\n;; Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n;; Example 2:\n;; Input: k = 2, prices = [3,2,6,5,0,3]\n;; Output: 7\n;; Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n;; Constraints:\n;; 1 <= k <= 100\n;; 1 <= prices.length <= 1000\n;; 0 <= prices[i] <= 1000\n(define (maxProfit k prices)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_136_maxProfit.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maxProfit))\n    (check-within (candidate 2 (list 1 2 4 2 5 7 2 4 9 0)) 13 0.001)\n    (check-within (candidate 3 (list 1 2 3 4 5)) 4 0.001)\n    (check-within (candidate 1 (list 7 6 4 3 1)) 0 0.001)\n    (check-within (candidate 1 (list 2 4 1)) 2 0.001)\n    (check-within (candidate 4 (list 1 2 3 1 2 3 1 2 3)) 6 0.001)\n    (check-within (candidate 2 (list 3 2 6 5 0 3)) 7 0.001)\n    (check-within (candidate 3 (list 1 2 3 4 5 6 7 8 9 10)) 9 0.001)\n    (check-within (candidate 3 (list 2 4 1)) 2 0.001)\n    (check-within (candidate 3 (list 10 9 8 7 6 5 4 3 2 1)) 0 0.001)\n    (check-within (candidate 2 (list 1 2 3 4 5 6 7 8 9 10)) 9 0.001)\n    (check-within (candidate 2 (list 3 3 5 0 0 3 1 4)) 6 0.001)\n    (check-within (candidate 2 (list 7 6 4 3 1)) 0 0.001)\n    (check-within (candidate 2 (list 1 2 3 4 5)) 4 0.001)\n    (check-within (candidate 3 (list 1 2 3 4 5 6)) 5 0.001)\n    (check-within (candidate 2 (list 1 2 4 2 5 7 2 4 9 9)) 13 0.001)\n    (check-within (candidate 3 (list 6 1 3 2 4 7)) 7 0.001)\n    (check-within (candidate 3 (list 2 1 2 0 1)) 2 0.001)\n    (check-within (candidate 1 (list 7 1 5 3 6 4 5 9 1 4)) 8 0.001)\n    (check-within (candidate 3 (list 7 6 4 3 1)) 0 0.001)\n    (check-within (candidate 1 (list 6 5 4 3 2 1)) 0 0.001)\n    (check-within (candidate 1 (list 10 9 8 7 6 5 4 3 2 1)) 0 0.001)\n    (check-within (candidate 1 (list 7 1 5 3 6 4)) 5 0.001)\n    (check-within (candidate 2 (list 2 4 1)) 2 0.001)\n    (check-within (candidate 2 (list 1 2 4 2 5 7 2 4 9 4)) 13 0.001)\n    (check-within (candidate 3 (list 3 2 6 5 0 3)) 7 0.001)\n    (check-within (candidate 3 (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)) 19 0.001)\n    (check-within (candidate 3 (list 9 8 7 6 5 4 3 2 1)) 0 0.001)\n    (check-within (candidate 3 (list 1 4 2 7)) 8 0.001)\n    (check-within (candidate 2 (list 7 6 5 4 3 2)) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1378_min_operations", "language": "rkt", "prompt": "#lang racket\n;; You are given a list target that consists of distinct integers and another integer list arr that can have duplicates.\n;; In one operation, you can insert any integer at any position in arr. For example, if arr = [1,4,1,2], you can add 3 in the middle and make it [1,4,3,1,2]. Note that you can insert the integer at the very beginning or end of the list.\n;; Return the minimum number of operations needed to make target a subsequence of arr.\n;; A subsequence of a list is a new list generated from the original list by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.\n;; Example 1:\n;; Input: target = [5,1,3], arr = [9,4,2,3,4]\n;; Output: 2\n;; Explanation: You can add 5 and 1 in such a way that makes arr = [5,9,4,1,2,3,4], then target will be a subsequence of arr.\n;; Example 2:\n;; Input: target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]\n;; Output: 3\n;; Constraints:\n;; 1 <= target.length, arr.length <= 105\n;; 1 <= target[i], arr[i] <= 109\n;; target contains no duplicates.\n(define (min_operations target arr)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1378_min_operations.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate min_operations))\n    (check-within (candidate (list 1) (list 1)) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) (list 2 4 6 8 10)) 5 0.001)\n    (check-within (candidate (list ) (list 1 2 3 4 5)) 0 0.001)\n    (check-within (candidate (list 5 1 3) (list 9 4 2 3 4)) 2 0.001)\n    (check-within (candidate (list 5 1 3) (list 9 4 2 3 4)) 2 0.001)\n    (check-within (candidate (list 6 4 8 1 3 2) (list 4 7 6 2 3 8 6 1)) 3 0.001)\n    (check-within (candidate (list ) (list )) 0 0.001)\n    (check-within (candidate (list 6 4 8 1 3 2) (list 4 7 6 2 3 8 6 1)) 3 0.001)\n    (check-within (candidate (list 1 2 3 4 5) (list 5 4 3 2 1 6 7 8 9 10)) 4 0.001)\n    (check-within (candidate (list 5 1 3) (list 4 2 3 4)) 2 0.001)\n    (check-within (candidate (list 1 2 3 4 5) (list 1 2 3 4 5)) 0 0.001)\n    (check-within (candidate (list 6 4 8 1 3 2) (list 4 7 6 2 3 8 6 1)) 3 0.001)\n    (check-within (candidate (list 5 1 3) (list 9 4 2 3 4)) 2 0.001)\n    (check-within (candidate (list 5 1 3) (list 9 4 2 3 4 2 1 6 7 8 9 10)) 2 0.001)\n    (check-within (candidate (list 1 3 5 7 9) (list 2 4 6 8 10)) 5 0.001)\n    (check-within (candidate (list 1 2 3 4 5) (list 5 4 3 2 1)) 4 0.001)\n    (check-within (candidate (list 1 2 3 4 5) (list )) 5 0.001)\n    (check-within (candidate (list 5 1 3) (list 9 4 2 3 4)) 2 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) (list 1 3 5 7 9)) 5 0.001)\n    (check-within (candidate (list 5 1 3) (list 9 4 2 3 4)) 2 0.001)\n    (check-within (candidate (list 2 2 2) (list 2 2)) 2 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) (list 10 9 8 7 6 5 4 3 2 1)) 9 0.001)\n    (check-within (candidate (list 1 2 3 4 5) (list 1 2 3 4)) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6) (list 1 4 4 4 5 6)) 2 0.001)\n    (check-within (candidate (list 6 4 8 1 3 2) (list 4 7 6 2 3 8 6 1)) 3 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1419_minAbsDifference", "language": "rkt", "prompt": "#lang racket\n;; You are given an integer list nums and an integer goal.\n;; You want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal).\n;; Return the minimum possible value of abs(sum - goal).\n;; Note that a subsequence of a list is a list formed by removing some elements (possibly all or none) of the original list.\n;; Example 1:\n;; Input: nums = [5,-7,3,5], goal = 6\n;; Output: 0\n;; Explanation: Choose the whole list as a subsequence, with a sum of 6.\n;; This is equal to the goal, so the absolute difference is 0.\n;; Example 2:\n;; Input: nums = [7,-9,15,-2], goal = -5\n;; Output: 1\n;; Explanation: Choose the subsequence [7,-9,-2], with a sum of -4.\n;; The absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.\n;; Example 3:\n;; Input: nums = [1,2,3], goal = -7\n;; Output: 7\n;; Constraints:\n;; 1 <= nums.length <= 40\n;; -107 <= nums[i] <= 107\n;; -109 <= goal <= 109\n(define (minAbsDifference nums goal)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1419_minAbsDifference.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minAbsDifference))\n    (check-within (candidate (list 5) 5) 0 0.001)\n    (check-within (candidate (list 5) 10) 5 0.001)\n    (check-within (candidate (list 1 2 3) 2) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 7) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) 33) 0 0.001)\n    (check-within (candidate (list 1 -1 1 -1 1 -1 1 -1) 2) 0 0.001)\n    (check-within (candidate (list -3 7 -15 -20 5) 5) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 10) 0 0.001)\n    (check-within (candidate (list 4 7 -1 2 -2 5 6 1 8 3) 10) 0 0.001)\n    (check-within (candidate (list 1 -1 1 -1 1 -1 1 -1) 1) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) 11) 0 0.001)\n    (check-within (candidate (list -12 -8 -8 4 -12 10 -12 -3 -14 -12 -8 -8) -3) 0 0.001)\n    (check-within (candidate (list -3 7 -15 -20 5) 6) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) 5) 0 0.001)\n    (check-within (candidate (list -2 4 -4 6 8 -9) 3) 0 0.001)\n    (check-within (candidate (list -7 -13 5 13 2 8 13 -14 -2 -15 8 10 -14 -12 -16 -13 -15 10 -14) -35) 0 0.001)\n    (check-within (candidate (list 1 2 3) 5) 0 0.001)\n    (check-within (candidate (list 1 2 3) 3) 0 0.001)\n    (check-within (candidate (list -20 -30 -100 60 5 40 10 80) 10) 0 0.001)\n    (check-within (candidate (list 1 2 3) 4) 0 0.001)\n    (check-within (candidate (list 1 2 3) 1) 0 0.001)\n    (check-within (candidate (list 1 -1 1 -1 1 -1 1 -1) 0) 0 0.001)\n    (check-within (candidate (list -7 15 -2 -10 17 3 11 12 -12 5 -2 -4 11 -4 12) 12) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) 55) 0 0.001)\n    (check-within (candidate (list 1 2 3) 6) 0 0.001)\n    (check-within (candidate (list 1 -1 1 -1 1 -1 1 -1) 3) 0 0.001)\n    (check-within (candidate (list -3 7 -15 -20 5) 11) 1 0.001)\n    (check-within (candidate (list -78 50 86 92 -42 98 -65 -46 90 -12 34) 70) 0 0.001)\n    (check-within (candidate (list 1 -1 1 -1 1 -1 1 -1) -1) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1425_min_trio_degree", "language": "rkt", "prompt": "#lang racket\n;; You are given an undirected graph. You are given an integer n which is the number of nodes in the graph and a list edges, where each edges[i] = [ui, vi] indicates that there is an undirected edge between ui and vi.\n;; A connected trio is a set of three nodes where there is an edge between every pair of them.\n;; The degree of a connected trio is the number of edges where one endpoint is in the trio, and the other is not.\n;; Return the minimum degree of a connected trio in the graph, or -1 if the graph has no connected trios.\n;; Example 1:\n;; Input: n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]\n;; Output: 3\n;; Explanation: There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.\n;; Example 2:\n;; Input: n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]\n;; Output: 0\n;; Explanation: There are exactly three trios:\n;; 1) [1,4,3] with degree 0.\n;; 2) [2,5,6] with degree 2.\n;; 3) [5,6,7] with degree 2.\n;; Constraints:\n;; 2 <= n <= 400\n;; edges[i].length == 2\n;; 1 <= edges.length <= n * (n-1) / 2\n;; 1 <= ui, vi <= n\n;; ui != vi\n;; There are no repeated edges.\n(define (min_trio_degree n edges)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1425_min_trio_degree.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate min_trio_degree))\n    (check-within (candidate 7 (list (list 1 3) (list 4 1) (list 4 3) (list 2 5) (list 5 6) (list 6 7) (list 7 5) (list 2 6))) 0 0.001)\n    (check-within (candidate 7 (list (list 1 3) (list 4 1) (list 4 3) (list 2 5) (list 5 6) (list 6 7) (list 7 5) (list 2 6))) 0 0.001)\n    (check-within (candidate 6 (list (list 1 2) (list 1 3) (list 3 2) (list 4 1) (list 5 2) (list 3 6))) 3 0.001)\n    (check-within (candidate 6 (list (list 1 2) (list 1 3) (list 2 4) (list 2 5) (list 3 6))) -1 0.001)\n    (check-within (candidate 7 (list (list 1 3) (list 4 1) (list 4 3) (list 2 5) (list 5 6) (list 6 7) (list 7 5) (list 2 6))) 0 0.001)\n    (check-within (candidate 7 (list (list 1 2) (list 1 3) (list 3 2) (list 4 1) (list 5 2) (list 3 6) (list 4 6))) 3 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1431_maximumScore", "language": "rkt", "prompt": "#lang racket\n;; You are given two 0-indexed integer lists nums and multipliers of size n and m respectively, where n >= m.\n;; You begin with a score of 0. You want to perform exactly m operations. On the ith operation (0-indexed) you will:\n;; Choose one integer x from either the start or the end of the list nums.\n;; Add multipliers[i] * x to your score.\n;; Note that multipliers[0] corresponds to the first operation, multipliers[1] to the second operation, and so on.\n;; Remove x from nums.\n;; Return the maximum score after performing m operations.\n;; Example 1:\n;; Input: nums = [1,2,3], multipliers = [3,2,1]\n;; Output: 14\n;; Explanation:\u00a0An optimal solution is as follows:\n;; - Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score.\n;; - Choose from the end, [1,2], adding 2 * 2 = 4 to the score.\n;; - Choose from the end, [1], adding 1 * 1 = 1 to the score.\n;; The total score is 9 + 4 + 1 = 14.\n;; Example 2:\n;; Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]\n;; Output: 102\n;; Explanation: An optimal solution is as follows:\n;; - Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score.\n;; - Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score.\n;; - Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score.\n;; - Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score.\n;; - Choose from the end, [-2,7], adding 7 * 6 = 42 to the score. \n;; The total score is 50 + 15 - 9 + 4 + 42 = 102.\n;; Constraints:\n;; n == nums.length\n;; m == multipliers.length\n;; 1 <= m <= 300\n;; m <= n <= 105 \n;; -1000 <= nums[i], multipliers[i] <= 1000\n(define (maximumScore nums multipliers)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1431_maximumScore.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximumScore))\n    (check-within (candidate (list 1 2 3) (list 3 2 1)) 14 0.001)\n    (check-within (candidate (list -1 -2 -3 -4 -5) (list 1 1 1 1 1)) -15 0.001)\n    (check-within (candidate (list 1 2 3 4 5) (list -1 -1 -1 -1 -1)) -15 0.001)\n    (check-within (candidate (list -1 -2 -3 -4 -5 -6 -7 -8 -9 -10) (list -1 -2 -3 -4 -5 -6 -7 -8 -9 -10)) 385 0.001)\n    (check-within (candidate (list 1) (list 1)) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) (list 1 2 3 4 5 6 7 8 9 10)) 385 0.001)\n    (check-within (candidate (list 1 2 3 4 5) (list 1 1 1 1 1)) 15 0.001)\n    (check-within (candidate (list -5 -3 -3 -2 7 1) (list -10 -5 3 4 6)) 102 0.001)\n    (check-within (candidate (list 1 2) (list 3 4)) 11 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1490_max_building", "language": "rkt", "prompt": "#lang racket\n;; You want to build n new buildings in a city. The new buildings will be built in a line and are labeled from 1 to n.\n;; However, there are city restrictions on the heights of the new buildings:\n;; The height of each building must be a non-negative integer.\n;; The height of the first building must be 0.\n;; The height difference between any two adjacent buildings cannot exceed 1.\n;; Additionally, there are city restrictions on the maximum height of specific buildings. These restrictions are given as a 2D integer list restrictions where restrictions[i] = [idi, maxHeighti] indicates that building idi must have a height less than or equal to maxHeighti.\n;; It is guaranteed that each building will appear at most once in restrictions, and building 1 will not be in restrictions.\n;; Return the maximum possible height of the tallest building.\n;; Example 1:\n;; Input: n = 5, restrictions = [[2,1],[4,1]]\n;; Output: 2\n;; Explanation: The green area in the image indicates the maximum allowed height for each building.\n;; We can build the buildings with heights [0,1,2,1,2], and the tallest building has a height of 2.\n;; Example 2:\n;; Input: n = 6, restrictions = []\n;; Output: 5\n;; Explanation: The green area in the image indicates the maximum allowed height for each building.\n;; We can build the buildings with heights [0,1,2,3,4,5], and the tallest building has a height of 5.\n;; Example 3:\n;; Input: n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]]\n;; Output: 5\n;; Explanation: The green area in the image indicates the maximum allowed height for each building.\n;; We can build the buildings with heights [0,1,2,3,3,4,4,5,4,3], and the tallest building has a height of 5.\n;; Constraints:\n;; 2 <= n <= 109\n;; 0 <= restrictions.length <= min(n - 1, 105)\n;; 2 <= idi <= n\n;; idi\u00a0is unique.\n;; 0 <= maxHeighti <= 109\n(define (max_building n restrictions)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1490_max_building.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_building))\n    (check-within (candidate 10 (list (list 2 5) (list 7 4) (list 9 3))) 5 0.001)\n    (check-within (candidate 5 (list (list 2 1) (list 3 2) (list 4 3) (list 5 4))) 4 0.001)\n    (check-within (candidate 7 (list )) 6 0.001)\n    (check-within (candidate 4 (list (list 4 2))) 2 0.001)\n    (check-within (candidate 8 (list (list 4 2) (list 5 3) (list 6 4))) 6 0.001)\n    (check-within (candidate 6 (list )) 5 0.001)\n    (check-within (candidate 5 (list )) 4 0.001)\n    (check-within (candidate 10 (list (list 2 5) (list 8 4) (list 9 3))) 5 0.001)\n    (check-within (candidate 10 (list (list 5 3) (list 9 4))) 5 0.001)\n    (check-within (candidate 8 (list (list 2 3) (list 5 7))) 7 0.001)\n    (check-within (candidate 6 (list (list 4 3))) 5 0.001)\n    (check-within (candidate 4 (list (list 2 1) (list 3 2) (list 4 3))) 3 0.001)\n    (check-within (candidate 10 (list )) 9 0.001)\n    (check-within (candidate 6 (list (list 1 5))) 5 0.001)\n    (check-within (candidate 6 (list (list 1 2) (list 2 3) (list 3 4) (list 4 5))) 5 0.001)\n    (check-within (candidate 5 (list (list 1 3) (list 2 3) (list 3 4))) 4 0.001)\n    (check-within (candidate 5 (list (list 3 4) (list 5 4))) 4 0.001)\n    (check-within (candidate 5 (list (list 1 3) (list 2 3) (list 3 4) (list 4 4))) 4 0.001)\n    (check-within (candidate 3 (list )) 2 0.001)\n    (check-within (candidate 4 (list (list 3 2) (list 4 3))) 3 0.001)\n    (check-within (candidate 4 (list )) 3 0.001)\n    (check-within (candidate 2 (list )) 1 0.001)\n    (check-within (candidate 10 (list (list 3 2) (list 4 5) (list 7 4) (list 8 3))) 5 0.001)\n    (check-within (candidate 6 (list (list 3 1) (list 4 2))) 4 0.001)\n    (check-within (candidate 10 (list (list 2 6) (list 8 4) (list 9 3))) 5 0.001)\n    (check-within (candidate 8 (list )) 7 0.001)\n    (check-within (candidate 4 (list (list 2 2) (list 3 1))) 2 0.001)\n    (check-within (candidate 5 (list (list 3 4))) 4 0.001)\n    (check-within (candidate 5 (list (list 1 2) (list 2 3) (list 3 4))) 4 0.001)\n    (check-within (candidate 4 (list (list 2 2) (list 4 1))) 2 0.001)\n    (check-within (candidate 4 (list (list 1 1) (list 3 3))) 3 0.001)\n    (check-within (candidate 1 (list )) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1505_largestPathValue", "language": "rkt", "prompt": "#lang racket\n;; There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1.\n;; You are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). You are also given a 2D list edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj.\n;; A valid path in the graph is a sequence of nodes x1 -> x2 -> x3 -> ... -> xk such that there is a directed edge from xi to xi+1 for every 1 <= i < k. The color value of the path is the number of nodes that are colored the most frequently occurring color along that path.\n;; Return the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle.\n;; Example 1:\n;; Input: colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]\n;; Output: 3\n;; Explanation: The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored \"a\" (red in the above image).\n;; Example 2:\n;; Input: colors = \"a\", edges = [[0,0]]\n;; Output: -1\n;; Explanation: There is a cycle from 0 to 0.\n;; Constraints:\n;; n == colors.length\n;; m == edges.length\n;; 1 <= n <= 105\n;; 0 <= m <= 105\n;; colors consists of lowercase English letters.\n;; 0 <= aj, bj\u00a0< n\n(define (largestPathValue colors edges)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1505_largestPathValue.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largestPathValue))\n    (check-within (candidate \"aababba\" (list (list 4 0) (list 1 0) (list 4 3) (list 1 4) (list 4 2))) 3 0.001)\n    (check-within (candidate \"aaa\" (list (list 1 2) (list 0 2) (list 2 1) (list 2 0) (list 1 0))) -1 0.001)\n    (check-within (candidate \"aaa\" (list (list 0 1) (list 1 2) (list 2 0))) -1 0.001)\n    (check-within (candidate \"a\" (list (list 0 0))) -1 0.001)\n    (check-within (candidate \"aaaa\" (list (list 3 0) (list 0 1) (list 2 3) (list 2 1))) 4 0.001)\n    (check-within (candidate \"aababbaa\" (list (list 4 0) (list 1 0) (list 4 3) (list 1 4) (list 4 2) (list 0 2) (list 1 2))) 4 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_150_findWords", "language": "rkt", "prompt": "#lang racket\n;; Given an m x n board\u00a0of characters and a list of strings words, return all words on the board.\n;; Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n;; Example 1:\n;; Input: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n;; Output: [\"eat\",\"oath\"]\n;; Example 2:\n;; Input: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\n;; Output: []\n;; Constraints:\n;; m == board.length\n;; n == board[i].length\n;; 1 <= m, n <= 12\n;; board[i][j] is a lowercase English letter.\n;; 1 <= words.length <= 3 * 104\n;; 1 <= words[i].length <= 10\n;; words[i] consists of lowercase English letters.\n;; All the strings of words are unique.\n(define (findWords board words)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_150_findWords.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate findWords))\n    (check-within (candidate (list (list \"a\" \"b\") (list \"c\" \"d\")) (list \"ac\" \"bd\")) (list \"ac\" \"bd\") 0.001)\n    (check-within (candidate (list (list \"a\" \"b\") (list \"c\" \"d\")) (list \"abcd\")) (list ) 0.001)\n    (check-within (candidate (list (list \"o\" \"a\" \"b\" \"n\") (list \"o\" \"t\" \"a\" \"e\") (list \"a\" \"h\" \"k\" \"r\") (list \"a\" \"f\" \"l\" \"v\")) (list \"oa\" \"oaa\")) (list \"oa\" \"oaa\") 0.001)\n    (check-within (candidate (list (list \"a\")) (list \"a\")) (list \"a\") 0.001)\n    (check-within (candidate (list (list \"a\" \"b\" \"c\") (list \"d\" \"e\" \"f\") (list \"g\" \"h\" \"i\")) (list \"aei\" \"bdf\" \"cgh\")) (list ) 0.001)\n    (check-within (candidate (list (list \"a\" \"a\" \"a\") (list \"a\" \"a\" \"a\") (list \"a\" \"a\" \"a\")) (list \"aaa\" \"aaaa\" \"aaaaa\")) (list \"aaa\" \"aaaa\" \"aaaaa\") 0.001)\n    (check-within (candidate (list (list \"a\" \"b\" \"c\") (list \"d\" \"e\" \"f\") (list \"g\" \"h\" \"i\")) (list \"a\" \"e\" \"i\")) (list \"a\" \"e\" \"i\") 0.001)\n    (check-within (candidate (list (list \"a\" \"b\" \"c\") (list \"d\" \"e\" \"f\") (list \"g\" \"h\" \"i\")) (list \"adg\" \"beh\" \"cfi\")) (list \"adg\" \"beh\" \"cfi\") 0.001)\n    (check-within (candidate (list (list \"a\" \"b\") (list \"c\" \"d\")) (list \"abcb\")) (list ) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1523_minOperationsToFlip", "language": "rkt", "prompt": "#lang racket\n;; You are given a valid boolean expression as a string expression consisting of the characters '1','0','&' (bitwise AND operator),'|' (bitwise OR operator),'(', and ')'.\n;; For example, \"()1|1\" and \"(1)&()\" are not valid while \"1\", \"(((1))|(0))\", and \"1|(0&(1))\" are valid expressions.\n;; Return the minimum cost to change the final value of the expression.\n;; For example, if expression = \"1|1|(0&0)&1\", its value is 1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1. We want to apply operations so that the new expression evaluates to 0.\n;; The cost of changing the final value of an expression is the number of operations performed on the expression. The types of operations are described as follows:\n;; Turn a '1' into a '0'.\n;; Turn a '0' into a '1'.\n;; Turn a '&' into a '|'.\n;; Turn a '|' into a '&'.\n;; Note: '&' does not take precedence over '|' in the order of calculation. Evaluate parentheses first, then in left-to-right order.\n;; Example 1:\n;; Input: expression = \"1&(0|1)\"\n;; Output: 1\n;; Explanation: We can turn \"1&(0|1)\" into \"1&(0&1)\" by changing the '|' to a '&' using 1 operation.\n;; The new expression evaluates to 0. \n;; Example 2:\n;; Input: expression = \"(0&0)&(0&0&0)\"\n;; Output: 3\n;; Explanation: We can turn \"(0&0)&(0&0&0)\" into \"(0|1)|(0&0&0)\" using 3 operations.\n;; The new expression evaluates to 1.\n;; Example 3:\n;; Input: expression = \"(0|(1|0&1))\"\n;; Output: 1\n;; Explanation: We can turn \"(0|(1|0&1))\" into \"(0|(0|0&1))\" using 1 operation.\n;; The new expression evaluates to 0.\n;; Constraints:\n;; 1 <= expression.length <= 105\n;; expression\u00a0only contains\u00a0'1','0','&','|','(', and\u00a0')'\n;; All parentheses\u00a0are properly matched.\n;; There will be no empty parentheses (i.e:\u00a0\"()\"\u00a0is not a substring of\u00a0expression).\n(define (minOperationsToFlip expression)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1523_minOperationsToFlip.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minOperationsToFlip))\n    (check-within (candidate \"1&0|1\") 2 0.001)\n    (check-within (candidate \"0&0|0&0\") 1 0.001)\n    (check-within (candidate \"1^0|0^1\") 2 0.001)\n    (check-within (candidate \"(0&0)&(0&0&0)\") 3 0.001)\n    (check-within (candidate \"1^1|0|1\") 2 0.001)\n    (check-within (candidate \"(1|1)&0\") 1 0.001)\n    (check-within (candidate \"1&0|0\") 1 0.001)\n    (check-within (candidate \"(1|0)&1|0&1\") 2 0.001)\n    (check-within (candidate \"0|0\") 1 0.001)\n    (check-within (candidate \"((1|0)&1)&0\") 1 0.001)\n    (check-within (candidate \"1|1|(0&0&0)\") 3 0.001)\n    (check-within (candidate \"1|0\") 1 0.001)\n    (check-within (candidate \"0|0|(1&1)\") 2 0.001)\n    (check-within (candidate \"1&1|0&1|0\") 1 0.001)\n    (check-within (candidate \"1&1&0&0&0&0\") 1 0.001)\n    (check-within (candidate \"(1&1)|0\") 1 0.001)\n    (check-within (candidate \"0\") 1 0.001)\n    (check-within (candidate \"1|(0&0)&(0&0)\") 3 0.001)\n    (check-within (candidate \"1^0|0|1\") 2 0.001)\n    (check-within (candidate \"1|0|0\") 1 0.001)\n    (check-within (candidate \"((0&0)&(0&0&0))\") 3 0.001)\n    (check-within (candidate \"1&0&0\") 1 0.001)\n    (check-within (candidate \"(1&0)|(0&1)\") 2 0.001)\n    (check-within (candidate \"(1|0)&1|0\") 1 0.001)\n    (check-within (candidate \"(1&0)|1&0|1\") 2 0.001)\n    (check-within (candidate \"(1|1)&0|1\") 2 0.001)\n    (check-within (candidate \"1&0\") 1 0.001)\n    (check-within (candidate \"(0&0)&(0&0)\") 3 0.001)\n    (check-within (candidate \"1|0&1|0\") 1 0.001)\n    (check-within (candidate \"((1|1)&0)&1\") 2 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1528_longestSubsequenceRepeatedK", "language": "rkt", "prompt": "#lang racket\n;; You are given a string s of length n, and an integer k. You are tasked to find the longest subsequence repeated k times in string s.\n;; A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n;; A subsequence seq is repeated k times in the string s if seq * k is a subsequence of s, where seq * k represents a string constructed by concatenating seq k times.\n;; For example, \"bba\" is repeated 2 times in the string \"bababcba\", because the string \"bbabba\", constructed by concatenating \"bba\" 2 times, is a subsequence of the string \"bababcba\".\n;; Return the longest subsequence repeated k times in string s. If multiple such subsequences are found, return the lexicographically largest one. If there is no such subsequence, return an empty string.\n;; Example 1:\n;; Input: s = \"letsleetcode\", k = 2\n;; Output: \"let\"\n;; Explanation: There are two longest subsequences repeated 2 times: \"let\" and \"ete\".\n;; \"let\" is the lexicographically largest one.\n;; Example 2:\n;; Input: s = \"bb\", k = 2\n;; Output: \"b\"\n;; Explanation: The longest subsequence repeated 2 times is \"b\".\n;; Example 3:\n;; Input: s = \"ab\", k = 2\n;; Output: \"\"\n;; Explanation: There is no subsequence repeated 2 times. Empty string is returned.\n;; Constraints:\n;; n == s.length\n;; 2 <= n, k <= 2000\n;; 2 <= n < k * 8\n;; s consists of lowercase English letters.\n(define (longestSubsequenceRepeatedK s k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1528_longestSubsequenceRepeatedK.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate longestSubsequenceRepeatedK))\n    (check-within (candidate \"ab\" 2) \"\" 0.001)\n    (check-within (candidate \"\" 1) \"\" 0.001)\n    (check-within (candidate \"ab\" 2) \"\" 0.001)\n    (check-within (candidate \"abcde\" 1) \"\" 0.001)\n    (check-within (candidate \"bbcbbabcba\" 6) \"\" 0.001)\n    (check-within (candidate \"bbcbbabcba\" 4) \"\" 0.001)\n    (check-within (candidate \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\" 1001) \"\" 0.001)\n    (check-within (candidate \"\" 2) \"\" 0.001)\n    (check-within (candidate \"\" 1001) \"\" 0.001)\n    (check-within (candidate \"bbcbbabcba\" 7) \"\" 0.001)\n    (check-within (candidate \"abcde\" 3) \"\" 0.001)\n    (check-within (candidate \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\" 3) \"a\" 0.001)\n    (check-within (candidate \"abacadaeafagahaijj\" 2) \"a\" 0.001)\n    (check-within (candidate \"aabbccddeeffgghhiijj\" 3) \"\" 0.001)\n    (check-within (candidate \"bbcbbabcba\" 5) \"\" 0.001)\n    (check-within (candidate \"abacadaeafagahaiaj\" 2) \"a\" 0.001)\n    (check-within (candidate \"abababab\" 2) \"ab\" 0.001)\n    (check-within (candidate \"ab\" 2) \"\" 0.001)\n    (check-within (candidate \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\" 1000) \"\" 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_152_shortest_palindrome", "language": "rkt", "prompt": "#lang racket\n;; You are given a string s. You can convert s to a palindrome by adding characters in front of it.\n;; Return the shortest palindrome you can find by performing this transformation.\n;; Example 1:\n;; Input: s = \"aacecaaa\"\n;; Output: \"aaacecaaa\"\n;; Example 2:\n;; Input: s = \"abcd\"\n;; Output: \"dcbabcd\"\n;; Constraints:\n;; 0 <= s.length <= 5 * 104\n;; s consists of lowercase English letters only.\n(define (shortest_palindrome s)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_152_shortest_palindrome.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate shortest_palindrome))\n    (check-within (candidate \"a\") \"a\" 0.001)\n    (check-within (candidate \"rotor\") \"rotor\" 0.001)\n    (check-within (candidate \"abababababababa\") \"abababababababa\" 0.001)\n    (check-within (candidate \"level\") \"level\" 0.001)\n    (check-within (candidate \"madam\") \"madam\" 0.001)\n    (check-within (candidate \"aa\") \"aa\" 0.001)\n    (check-within (candidate \"aaacecaaa\") \"aaacecaaa\" 0.001)\n    (check-within (candidate \"abacaba\") \"abacaba\" 0.001)\n    (check-within (candidate \"xxx\") \"xxx\" 0.001)\n    (check-within (candidate \"aaabaaa\") \"aaabaaa\" 0.001)\n    (check-within (candidate \"aba\") \"aba\" 0.001)\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"cbaabc\") \"cbaabc\" 0.001)\n    (check-within (candidate \"civic\") \"civic\" 0.001)\n    (check-within (candidate \"abcddcba\") \"abcddcba\" 0.001)\n    (check-within (candidate \"redder\") \"redder\" 0.001)\n    (check-within (candidate \"x\") \"x\" 0.001)\n    (check-within (candidate \"racecar\") \"racecar\" 0.001)\n    (check-within (candidate \"b\") \"b\" 0.001)\n    (check-within (candidate \"xxxx\") \"xxxx\" 0.001)\n    (check-within (candidate \"aacecaaa\") \"aaacecaaa\" 0.001)\n    (check-within (candidate \"a\") \"a\" 0.001)\n    (check-within (candidate \"hannah\") \"hannah\" 0.001)\n    (check-within (candidate \"repaper\") \"repaper\" 0.001)\n    (check-within (candidate \"deified\") \"deified\" 0.001)\n    (check-within (candidate \"xxxxx\") \"xxxxx\" 0.001)\n    (check-within (candidate \"abababa\") \"abababa\" 0.001)\n    (check-within (candidate \"deed\") \"deed\" 0.001)\n    (check-within (candidate \"abc\") \"cbabc\" 0.001)\n    (check-within (candidate \"a\") \"a\" 0.001)\n    (check-within (candidate \"abcd\") \"dcbabcd\" 0.001)\n    (check-within (candidate \"dewed\") \"dewed\" 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1549_minCost", "language": "rkt", "prompt": "#lang racket\n;; There is a country of n cities numbered from 0 to n - 1 where all the cities are connected by bi-directional roads. The roads are represented as a 2D integer list edges where edges[i] = [xi, yi, timei] denotes a road between cities xi and yi that takes timei minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.\n;; Each time you pass through a city, you must pay a passing fee. This is represented as a 0-indexed integer list passingFees of length n where passingFees[j] is the amount of dollars you must pay when you pass through city j.\n;; In the beginning, you are at city 0 and want to reach city n - 1 in maxTime minutes or less. The cost of your journey is the summation of passing fees for each city that you passed through at some moment of your journey (including the source and destination cities).\n;; Given maxTime, edges, and passingFees, return the minimum cost to complete your journey, or -1 if you cannot complete it within maxTime minutes.\n;; Example 1:\n;; Input: maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n;; Output: 11\n;; Explanation: The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees.\n;; Example 2:\n;; Input: maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n;; Output: 48\n;; Explanation: The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees.\n;; You cannot take path 0 -> 1 -> 2 -> 5 since it would take too long.\n;; Example 3:\n;; Input: maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n;; Output: -1\n;; Explanation: There is no way to reach city 5 from city 0 within 25 minutes.\n;; Constraints:\n;; 1 <= maxTime <= 1000\n;; n == passingFees.length\n;; 2 <= n <= 1000\n;; n - 1 <= edges.length <= 1000\n;; 0 <= xi, yi <= n - 1\n;; 1 <= timei <= 1000\n;; 1 <= passingFees[j] <= 1000\u00a0\n;; The graph may contain multiple edges between two nodes.\n;; The graph does not contain self loops.\n(define (minCost maxTime edges passingFees)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1549_minCost.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minCost))\n    (check-within (candidate 20 (list (list 0 1 5) (list 1 2 5) (list 0 2 15)) (list 1 2 3)) 6 0.001)\n    (check-within (candidate 10 (list (list 0 1 5) (list 1 2 4)) (list 1 2 3)) 6 0.001)\n    (check-within (candidate 10 (list (list 0 1 5) (list 1 2 6)) (list 1 2 5)) -1 0.001)\n    (check-within (candidate 20 (list (list 0 1 10) (list 1 2 20)) (list 1 2 3)) -1 0.001)\n    (check-within (candidate 20 (list (list 0 1 5) (list 1 2 5)) (list 1 2 5)) 8 0.001)\n    (check-within (candidate 30 (list (list 0 1 10) (list 1 2 10)) (list 1 2 3)) 6 0.001)\n    (check-within (candidate 10 (list (list 0 1 5) (list 1 2 5)) (list 1 2 5)) 8 0.001)\n    (check-within (candidate 20 (list (list 0 1 5) (list 1 2 5) (list 0 2 10)) (list 1 2 3)) 4 0.001)\n    (check-within (candidate 10 (list (list 0 1 5) (list 1 2 4)) (list 1 2 5)) 8 0.001)\n    (check-within (candidate 20 (list (list 0 1 10) (list 1 2 10)) (list 1 3 2)) 6 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1597_valid_arrangement", "language": "rkt", "prompt": "#lang racket\n;; You are given a 0-indexed 2D integer list pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\n;; Return any valid arrangement of pairs.\n;; Note: The inputs will be generated such that there exists a valid arrangement of pairs.\n;; Example 1:\n;; Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\n;; Output: [[11,9],[9,4],[4,5],[5,1]]\n;; Explanation:\n;; This is a valid arrangement since endi-1 always equals starti.\n;; end0 = 9 == 9 = start1 \n;; end1 = 4 == 4 = start2\n;; end2 = 5 == 5 = start3\n;; Example 2:\n;; Input: pairs = [[1,3],[3,2],[2,1]]\n;; Output: [[1,3],[3,2],[2,1]]\n;; Explanation:\n;; This is a valid arrangement since endi-1 always equals starti.\n;; end0 = 3 == 3 = start1\n;; end1 = 2 == 2 = start2\n;; The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.\n;; Example 3:\n;; Input: pairs = [[1,2],[1,3],[2,1]]\n;; Output: [[1,2],[2,1],[1,3]]\n;; Explanation:\n;; This is a valid arrangement since endi-1 always equals starti.\n;; end0 = 2 == 2 = start1\n;; end1 = 1 == 1 = start2\n;; Constraints:\n;; 1 <= pairs.length <= 105\n;; pairs[i].length == 2\n;; 0 <= starti, endi <= 109\n;; starti != endi\n;; No two pairs are exactly the same.\n;; There exists a valid arrangement of pairs.\n(define (valid_arrangement pairs)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1597_valid_arrangement.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate valid_arrangement))\n    (check-within (candidate (list (list 0 1) (list 1 2) (list 2 3))) (list (list 0 1) (list 1 2) (list 2 3)) 0.001)\n    (check-within (candidate (list (list 9 8) (list 10 9) (list 8 10))) (list (list 9 8) (list 8 10) (list 10 9)) 0.001)\n    (check-within (candidate (list (list 1 3) (list 3 2) (list 2 1))) (list (list 1 3) (list 3 2) (list 2 1)) 0.001)\n    (check-within (candidate (list (list 16 17) (list 18 16) (list 17 18))) (list (list 16 17) (list 17 18) (list 18 16)) 0.001)\n    (check-within (candidate (list (list 3 5) (list 7 3) (list 5 7))) (list (list 3 5) (list 5 7) (list 7 3)) 0.001)\n    (check-within (candidate (list (list 0 1) (list 1 2) (list 2 0))) (list (list 0 1) (list 1 2) (list 2 0)) 0.001)\n    (check-within (candidate (list (list 0 1) (list 2 0) (list 1 2))) (list (list 0 1) (list 1 2) (list 2 0)) 0.001)\n    (check-within (candidate (list (list 11 10) (list 12 11) (list 10 12))) (list (list 11 10) (list 10 12) (list 12 11)) 0.001)\n    (check-within (candidate (list (list 13 14) (list 15 13) (list 14 15))) (list (list 13 14) (list 14 15) (list 15 13)) 0.001)\n    (check-within (candidate (list (list 12 0) (list 0 10) (list 10 7) (list 7 12))) (list (list 12 0) (list 0 10) (list 10 7) (list 7 12)) 0.001)\n    (check-within (candidate (list (list 5 2) (list 3 5) (list 2 3))) (list (list 5 2) (list 2 3) (list 3 5)) 0.001)\n    (check-within (candidate (list (list 1 5) (list 3 1) (list 5 3))) (list (list 1 5) (list 5 3) (list 3 1)) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1608_recoverArray", "language": "rkt", "prompt": "#lang racket\n;; You are given an integer n representing the length of an unknown list that you are trying to recover. You are also given a list sums containing the values of all 2n subset sums of the unknown list (in no particular order).\n;; Return the list ans of length n representing the unknown list. If multiple answers exist, return any of them.\n;; An list sub is a subset of a list arr if sub can be obtained from arr by deleting some (possibly zero or all) elements of arr. The sum of the elements in sub is one possible subset sum of arr. The sum of an empty list is considered to be 0.\n;; Note: Test cases are generated such that there will always be at least one correct answer.\n;; Example 1:\n;; Input: n = 3, sums = [-3,-2,-1,0,0,1,2,3]\n;; Output: [1,2,-3]\n;; Explanation: [1,2,-3] is able to achieve the given subset sums:\n;; - []: sum is 0\n;; - [1]: sum is 1\n;; - [2]: sum is 2\n;; - [1,2]: sum is 3\n;; - [-3]: sum is -3\n;; - [1,-3]: sum is -2\n;; - [2,-3]: sum is -1\n;; - [1,2,-3]: sum is 0\n;; Note that any permutation of [1,2,-3] and also any permutation of [-1,-2,3] will also be accepted.\n;; Example 2:\n;; Input: n = 2, sums = [0,0,0,0]\n;; Output: [0,0]\n;; Explanation: The only correct answer is [0,0].\n;; Example 3:\n;; Input: n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]\n;; Output: [0,-1,4,5]\n;; Explanation: [0,-1,4,5] is able to achieve the given subset sums.\n;; Constraints:\n;; 1 <= n <= 15\n;; sums.length == 2n\n;; -104 <= sums[i] <= 104\n(define (recoverArray n sums)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1608_recoverArray.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate recoverArray))\n    (check-within (candidate 2 (list 0 0 0)) (list 0 0) 0.001)\n    (check-within (candidate 3 (list 0 0 0 0 0)) (list 0 0 0) 0.001)\n    (check-within (candidate 1 (list 0)) (list 0) 0.001)\n    (check-within (candidate 2 (list 0 0 0 0)) (list 0 0) 0.001)\n    (check-within (candidate 3 (list 0 0 0 0 0 0)) (list 0 0 0) 0.001)\n    (check-within (candidate 3 (list 1 1 1 1 1 1 1 1)) (list 1 1 1) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1635_longest_subsequence_repeated_k", "language": "rkt", "prompt": "#lang racket\n;; You are given a string s of length n, and an integer k. You are tasked to find the longest subsequence repeated k times in string s.\n;; A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n;; A subsequence seq is repeated k times in the string s if seq * k is a subsequence of s, where seq * k represents a string constructed by concatenating seq k times.\n;; For example, \"bba\" is repeated 2 times in the string \"bababcba\", because the string \"bbabba\", constructed by concatenating \"bba\" 2 times, is a subsequence of the string \"bababcba\".\n;; Return the longest subsequence repeated k times in string s. If multiple such subsequences are found, return the lexicographically largest one. If there is no such subsequence, return an empty string.\n;; Example 1:\n;; Input: s = \"letsleetcode\", k = 2\n;; Output: \"let\"\n;; Explanation: There are two longest subsequences repeated 2 times: \"let\" and \"ete\".\n;; \"let\" is the lexicographically largest one.\n;; Example 2:\n;; Input: s = \"bb\", k = 2\n;; Output: \"b\"\n;; Explanation: The longest subsequence repeated 2 times is \"b\".\n;; Example 3:\n;; Input: s = \"ab\", k = 2\n;; Output: \"\"\n;; Explanation: There is no subsequence repeated 2 times. Empty string is returned.\n;; Constraints:\n;; n == s.length\n;; 2 <= n, k <= 2000\n;; 2 <= n < k * 8\n;; s consists of lowercase English letters.\n(define (longest_subsequence_repeated_k s k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1635_longest_subsequence_repeated_k.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate longest_subsequence_repeated_k))\n    (check-within (candidate \"aaaa\" 1) \"aaaa\" 0.001)\n    (check-within (candidate \"aabbccddeeff\" 3) \"\" 0.001)\n    (check-within (candidate \"abcdef\" 3) \"\" 0.001)\n    (check-within (candidate \"ab\" 2) \"\" 0.001)\n    (check-within (candidate \"bb\" 2) \"b\" 0.001)\n    (check-within (candidate \"abcdef\" 1) \"fedcba\" 0.001)\n    (check-within (candidate \"abacadaea\" 2) \"aa\" 0.001)\n    (check-within (candidate \"ab\" 2) \"\" 0.001)\n    (check-within (candidate \"bb\" 2) \"b\" 0.001)\n    (check-within (candidate \"aaaaaa\" 3) \"aa\" 0.001)\n    (check-within (candidate \"bb\" 1) \"bb\" 0.001)\n    (check-within (candidate \"\" 2) \"\" 0.001)\n    (check-within (candidate \"abcdef\" 2) \"\" 0.001)\n    (check-within (candidate \"bba\" 2) \"b\" 0.001)\n    (check-within (candidate \"abbb\" 4) \"\" 0.001)\n    (check-within (candidate \"zzzzzzzzzzzzz\" 1) \"zzzzzzzzzzzzz\" 0.001)\n    (check-within (candidate \"aaaaaa\" 7) \"\" 0.001)\n    (check-within (candidate \"fdaebc\" 1) \"fedcba\" 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_166_countDigitOne", "language": "rkt", "prompt": "#lang racket\n;; Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\n;; Example 1:\n;; Input: n = 13\n;; Output: 6\n;; Example 2:\n;; Input: n = 0\n;; Output: 0\n;; Constraints:\n;; 0 <= n <= 109\n(define (countDigitOne n)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_166_countDigitOne.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate countDigitOne))\n    (check-within (candidate 12) 5 0.001)\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 20) 12 0.001)\n    (check-within (candidate 1000000) 600001 0.001)\n    (check-within (candidate 1000) 301 0.001)\n    (check-within (candidate 3) 1 0.001)\n    (check-within (candidate 100000) 50001 0.001)\n    (check-within (candidate 2) 1 0.001)\n    (check-within (candidate 16) 9 0.001)\n    (check-within (candidate 4) 1 0.001)\n    (check-within (candidate 10) 2 0.001)\n    (check-within (candidate 8) 1 0.001)\n    (check-within (candidate 13) 6 0.001)\n    (check-within (candidate 5) 1 0.001)\n    (check-within (candidate 15) 8 0.001)\n    (check-within (candidate 18) 11 0.001)\n    (check-within (candidate 0) 0 0.001)\n    (check-within (candidate 14) 7 0.001)\n    (check-within (candidate 7) 1 0.001)\n    (check-within (candidate 9) 1 0.001)\n    (check-within (candidate 101) 23 0.001)\n    (check-within (candidate 19) 12 0.001)\n    (check-within (candidate 17) 10 0.001)\n    (check-within (candidate 6) 1 0.001)\n    (check-within (candidate 11) 4 0.001)\n    (check-within (candidate 10000) 4001 0.001)\n    (check-within (candidate 100) 21 0.001)\n    (check-within (candidate 21) 13 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1677_count_pyramids", "language": "rkt", "prompt": "#lang racket\n;; A farmer has a rectangular grid of land with m rows and n columns that can be divided into unit cells. Each cell is either fertile (represented by a 1) or barren (represented by a 0). All cells outside the grid are considered barren.\n;; A rktramidal plot of land can be defined as a set of cells with the following criteria:\n;; The number of cells in the set has to be greater than 1 and all cells must be fertile.\n;; The apex of a rktramid is the topmost cell of the rktramid. The height of a rktramid is the number of rows it covers. Let (r, c) be the apex of the rktramid, and its height be h. Then, the plot comprises of cells (i, j) where r <= i <= r + h - 1 and c - (i - r) <= j <= c + (i - r).\n;; An inverse rktramidal plot of land can be defined as a set of cells with similar criteria:\n;; The number of cells in the set has to be greater than 1 and all cells must be fertile.\n;; The apex of an inverse rktramid is the bottommost cell of the inverse rktramid. The height of an inverse rktramid is the number of rows it covers. Let (r, c) be the apex of the rktramid, and its height be h. Then, the plot comprises of cells (i, j) where r - h + 1 <= i <= r and c - (r - i) <= j <= c + (r - i).\n;; Some examples of valid and invalid rktramidal (and inverse rktramidal) plots are shown below. Black cells indicate fertile cells.\n;; Given a 0-indexed m x n binary matrix grid representing the farmland, return the total number of rktramidal and inverse rktramidal plots that can be found in grid.\n;; Example 1:\n;; Input: grid = [[0,1,1,0],[1,1,1,1]]\n;; Output: 2\n;; Explanation: The 2 possible rktramidal plots are shown in blue and red respectively.\n;; There are no inverse rktramidal plots in this grid. \n;; Hence total number of rktramidal and inverse rktramidal plots is 2 + 0 = 2.\n;; Example 2:\n;; Input: grid = [[1,1,1],[1,1,1]]\n;; Output: 2\n;; Explanation: The rktramidal plot is shown in blue, and the inverse rktramidal plot is shown in red. \n;; Hence the total number of plots is 1 + 1 = 2.\n;; Example 3:\n;; Input: grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]\n;; Output: 13\n;; Explanation: There are 7 rktramidal plots, 3 of which are shown in the 2nd and 3rd figures.\n;; There are 6 inverse rktramidal plots, 2 of which are shown in the last figure.\n;; The total number of plots is 7 + 6 = 13.\n;; Constraints:\n;; m == grid.length\n;; n == grid[i].length\n;; 1 <= m, n <= 1000\n;; 1 <= m * n <= 105\n;; grid[i][j] is either 0 or 1.\n(define (count_pyramids grid)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1677_count_pyramids.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_pyramids))\n    (check-within (candidate (list (list 0 0 0) (list 0 0 0) (list 0 0 0))) 0 0.001)\n    (check-within (candidate (list (list 0 1 0) (list 1 2 1) (list 0 1 0))) 2 0.001)\n    (check-within (candidate (list (list 2 2 2) (list 2 2 2) (list 2 2 2))) 2 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 0 6) (list 7 8 9))) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_169_maxSlidingWindow", "language": "rkt", "prompt": "#lang racket\n;; You are given a list of integers\u00a0nums, there is a sliding window of size k which is moving from the very left of the list to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\n;; Return the max sliding window.\n;; Example 1:\n;; Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\n;; Output: [3,3,5,5,6,7]\n;; Explanation: \n;; Window position                Max\n;; ---------------               -----\n;; [1  3  -1] -3  5  3  6  7       3\n;;  1 [3  -1  -3] 5  3  6  7       3\n;;  1  3 [-1  -3  5] 3  6  7       5\n;;  1  3  -1 [-3  5  3] 6  7       5\n;;  1  3  -1  -3 [5  3  6] 7       6\n;;  1  3  -1  -3  5 [3  6  7]      7\n;; Example 2:\n;; Input: nums = [1], k = 1\n;; Output: [1]\n;; Constraints:\n;; 1 <= nums.length <= 105\n;; -104 <= nums[i] <= 104\n;; 1 <= k <= nums.length\n(define (maxSlidingWindow nums k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_169_maxSlidingWindow.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maxSlidingWindow))\n    (check-within (candidate (list 10 9 8 7 6 5 4 3 2 1) 10) (list 10) 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1 1 1) 3) (list 1 1 1 1 1 1 1 1 1 1) 0.001)\n    (check-within (candidate (list 1) 1) (list 1) 0.001)\n    (check-within (candidate (list 1 3 1 2 0 5) 6) (list 5) 0.001)\n    (check-within (candidate (list 1 3 1 2 0 5) 3) (list 3 3 2 5) 0.001)\n    (check-within (candidate (list -1 -3 -1 -3 5 3 6 7) 3) (list -1 -1 5 5 6 7) 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) 3) (list 3 4 5 6 7 8 9 10) 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) 10) (list 10) 0.001)\n    (check-within (candidate (list 1 3 -1 -3 5 3 6 7) 2) (list 3 3 -1 5 5 6 7) 0.001)\n    (check-within (candidate (list 1 2 3 4 5 4 3 2 1) 3) (list 3 4 5 5 5 4 3) 0.001)\n    (check-within (candidate (list 1 3 1 2 0 5) 1) (list 1 3 1 2 0 5) 0.001)\n    (check-within (candidate (list 1 3 -1 -3 5 3 6 7) 3) (list 3 3 5 5 6 7) 0.001)\n    (check-within (candidate (list -7 -8 7 5 7 1 9 0 1 0) 1) (list -7 -8 7 5 7 1 9 0 1 0) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1809_countExcellentPairs", "language": "rkt", "prompt": "#lang racket\n;; You are given a 0-indexed positive integer list nums and a positive integer k.\n;; A pair of numbers (num1, num2) is called excellent if the following conditions are satisfied:\n;; Both the numbers num1 and num2 exist in the list nums.\n;; The sum of the number of set bits in num1 OR num2 and num1 AND num2 is greater than or equal to k, where OR is the bitwise OR operation and AND is the bitwise AND operation.\n;; Return the number of distinct excellent pairs.\n;; Two pairs (a, b) and (c, d) are considered distinct if either a != c or b != d. For example, (1, 2) and (2, 1) are distinct.\n;; Note that a pair (num1, num2) such that num1 == num2 can also be excellent if you have at least one occurrence of num1 in the list.\n;; Example 1:\n;; Input: nums = [1,2,3,1], k = 3\n;; Output: 5\n;; Explanation: The excellent pairs are the following:\n;; - (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. The total number of set bits is 2 + 2 = 4, which is greater than or equal to k = 3.\n;; - (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and (2 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.\n;; - (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and (1 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.\n;; So the number of excellent pairs is 5.\n;; Example 2:\n;; Input: nums = [5,1,1], k = 10\n;; Output: 0\n;; Explanation: There are no excellent pairs for this list.\n;; Constraints:\n;; 1 <= nums.length <= 105\n;; 1 <= nums[i] <= 109\n;; 1 <= k <= 60\n(define (countExcellentPairs nums k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1809_countExcellentPairs.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate countExcellentPairs))\n    (check-within (candidate (list 1 1 1 2 2 2) 3) 0 0.001)\n    (check-within (candidate (list 3 3) 5) 0 0.001)\n    (check-within (candidate (list 1 2 3) 3) 4 0.001)\n    (check-within (candidate (list 3 3 3 1) 4) 3 0.001)\n    (check-within (candidate (list 1 2 3 1) 6) 0 0.001)\n    (check-within (candidate (list 1 1 1 1) 4) 0 0.001)\n    (check-within (candidate (list 3 3 3 1) 5) 0 0.001)\n    (check-within (candidate (list 3 3 3 3) 3) 6 0.001)\n    (check-within (candidate (list 1 1 1 1 1) 5) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 4) 2 0.001)\n    (check-within (candidate (list 1 1 1 2 2 2) 5) 0 0.001)\n    (check-within (candidate (list 3 4 5 6) 6) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 5) 0 0.001)\n    (check-within (candidate (list 3 3 3 3 3) 6) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 1) 20 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6) 5) 0 0.001)\n    (check-within (candidate (list 1 1 1 2) 5) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 2) 20 0.001)\n    (check-within (candidate (list 2 3 4 5 6) 5) 0 0.001)\n    (check-within (candidate (list 2 2 2 2) 2) 6 0.001)\n    (check-within (candidate (list 2 2 2 2) 3) 0 0.001)\n    (check-within (candidate (list 1 1 1 1) 1) 6 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6) 6) 0 0.001)\n    (check-within (candidate (list 2 3 4 5 6) 2) 20 0.001)\n    (check-within (candidate (list 1 2 3) 4) 0 0.001)\n    (check-within (candidate (list 2 2 3 3) 5) 0 0.001)\n    (check-within (candidate (list 5 1 1) 10) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1836_kSum", "language": "rkt", "prompt": "#lang racket\n;; You are given an integer list nums and a positive integer k. You can choose any subsequence of the list and sum all of its elements together.\n;; We define the K-Sum of the list as the kth largest subsequence sum that can be obtained (not necessarily distinct).\n;; Return the K-Sum of the list.\n;; A subsequence is a list that can be derived from another list by deleting some or no elements without changing the order of the remaining elements.\n;; Note that the empty subsequence is considered to have a sum of 0.\n;; Example 1:\n;; Input: nums = [2,4,-2], k = 5\n;; Output: 2\n;; Explanation: All the possible subsequence sums that we can obtain are the following sorted in decreasing order:\n;; - 6, 4, 4, 2, 2, 0, 0, -2.\n;; The 5-Sum of the list is 2.\n;; Example 2:\n;; Input: nums = [1,-2,3,4,-10,12], k = 16\n;; Output: 10\n;; Explanation: The 16-Sum of the list is 10.\n;; Constraints:\n;; n == nums.length\n;; 1 <= n <= 105\n;; -109 <= nums[i] <= 109\n;; 1 <= k <= min(2000, 2n)\n(define (kSum nums k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1836_kSum.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate kSum))\n    (check-within (candidate (list -1 4) 2) 3 0.001)\n    (check-within (candidate (list 0 0 0 0 0) 1) 0 0.001)\n    (check-within (candidate (list 0 0) 1) 0 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1) 10) 9 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 1) 15 0.001)\n    (check-within (candidate (list 0 0 0 0 0) 1) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1893_minCost", "language": "rkt", "prompt": "#lang racket\n;; You are given two 0-indexed lists nums and cost consisting each of n positive integers.\n;; You can do the following operation any number of times:\n;; Increase or decrease any element of the list nums by 1.\n;; The cost of doing one operation on the ith element is cost[i].\n;; Return the minimum total cost such that all the elements of the list nums become equal.\n;; Example 1:\n;; Input: nums = [1,3,5,2], cost = [2,3,1,14]\n;; Output: 8\n;; Explanation: We can make all the elements equal to 2 in the following way:\n;; - Increase the 0th element one time. The cost is 2.\n;; - Decrease the 1st element one time. The cost is 3.\n;; - Decrease the 2nd element three times. The cost is 1 + 1 + 1 = 3.\n;; The total cost is 2 + 3 + 3 = 8.\n;; It can be shown that we cannot make the list equal with a smaller cost.\n;; Example 2:\n;; Input: nums = [2,2,2,2,2], cost = [4,2,8,1,3]\n;; Output: 0\n;; Explanation: All the elements are already equal, so no operations are needed.\n;; Constraints:\n;; n == nums.length == cost.length\n;; 1 <= n <= 105\n;; 1 <= nums[i], cost[i] <= 106\n;; Test cases are generated in a way that the output doesn't exceed\u00a0253-1\n(define (minCost nums cost)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1893_minCost.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minCost))\n    (check-within (candidate (list 1 3 5 2) (list 2 3 1 14)) 8 0.001)\n    (check-within (candidate (list 1 1 1 1 1) (list 1 2 3 4 5)) 0 0.001)\n    (check-within (candidate (list 2 1 1 1 1) (list 1 2 3 4 5)) 1 0.001)\n    (check-within (candidate (list 1 1 1 1 100) (list 1 1 1 1 1)) 99 0.001)\n    (check-within (candidate (list 2 2 2 2 2) (list 4 2 8 1 3)) 0 0.001)\n    (check-within (candidate (list 1 3 5 2) (list 2 3 1 14)) 8 0.001)\n    (check-within (candidate (list 1 1 1 1 100) (list 1 1 1 1 1)) 99 0.001)\n    (check-within (candidate (list 3 3 3 3 3) (list 1 2 3 4 5)) 0 0.001)\n    (check-within (candidate (list 2 2 2 2 2) (list 4 2 8 1 3)) 0 0.001)\n    (check-within (candidate (list 3 3 3 3 3) (list 1 2 3 4 5)) 0 0.001)\n    (check-within (candidate (list 1 1 1 1 1) (list 1 2 3 4 5)) 0 0.001)\n    (check-within (candidate (list 2 1 1 1 1) (list 1 2 3 4 5)) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1917_countTriplets", "language": "rkt", "prompt": "#lang racket\n;; Given an integer list nums, return the number of AND triples.\n;; An AND triple is a triple of indices (i, j, k) such that:\n;; 0 <= i < nums.length\n;; 0 <= j < nums.length\n;; 0 <= k < nums.length\n;; nums[i] & nums[j] & nums[k] == 0, where & represents the bitwise-AND operator.\n;; Example 1:\n;; Input: nums = [2,1,3]\n;; Output: 12\n;; Explanation: We could choose the following i, j, k triples:\n;; (i=0, j=0, k=1) : 2 & 2 & 1\n;; (i=0, j=1, k=0) : 2 & 1 & 2\n;; (i=0, j=1, k=1) : 2 & 1 & 1\n;; (i=0, j=1, k=2) : 2 & 1 & 3\n;; (i=0, j=2, k=1) : 2 & 3 & 1\n;; (i=1, j=0, k=0) : 1 & 2 & 2\n;; (i=1, j=0, k=1) : 1 & 2 & 1\n;; (i=1, j=0, k=2) : 1 & 2 & 3\n;; (i=1, j=1, k=0) : 1 & 1 & 2\n;; (i=1, j=2, k=0) : 1 & 3 & 2\n;; (i=2, j=0, k=1) : 3 & 2 & 1\n;; (i=2, j=1, k=0) : 3 & 1 & 2\n;; Example 2:\n;; Input: nums = [0,0,0]\n;; Output: 27\n;; Constraints:\n;; 1 <= nums.length <= 1000\n;; 0 <= nums[i] < 216\n(define (countTriplets nums)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1917_countTriplets.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate countTriplets))\n    (check-within (candidate (list 1 2 3 4 5 6)) 20 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10)) 120 0.001)\n    (check-within (candidate (list 1 1 1 1 1)) 0 0.001)\n    (check-within (candidate (list 10 20 30 40 50 60 70 80 90 100)) 120 0.001)\n    (check-within (candidate (list 1 2 3)) 1 0.001)\n    (check-within (candidate (list 5 4 3 2 1)) 10 0.001)\n    (check-within (candidate (list 2 2 2 2 2 2 2)) 0 0.001)\n    (check-within (candidate (list 4 4 2 4 3)) 3 0.001)\n    (check-within (candidate (list 1 1 1 4 4 4)) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) 10 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_1953_countPartitions", "language": "rkt", "prompt": "#lang racket\n;; You are given a list nums consisting of positive integers and an integer k.\n;; Partition the list into two ordered groups such that each element is in exactly one group. A partition is called great if the sum of elements of each group is greater than or equal to k.\n;; Return the number of distinct great partitions. Since the answer may be too large, return it modulo 109 + 7.\n;; Two partitions are considered distinct if some element nums[i] is in different groups in the two partitions.\n;; Example 1:\n;; Input: nums = [1,2,3,4], k = 4\n;; Output: 6\n;; Explanation: The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and ([4], [1,2,3]).\n;; Example 2:\n;; Input: nums = [3,3,3], k = 4\n;; Output: 0\n;; Explanation: There are no great partitions for this list.\n;; Example 3:\n;; Input: nums = [6,6], k = 2\n;; Output: 2\n;; Explanation: We can either put nums[0] in the first partition or in the second partition.\n;; The great partitions will be ([6], [6]) and ([6], [6]).\n;; Constraints:\n;; 1 <= nums.length, k <= 1000\n;; 1 <= nums[i] <= 109\n(define (countPartitions nums k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_1953_countPartitions.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate countPartitions))\n    (check-within (candidate (list 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6) 4500) 0 0.001)\n    (check-within (candidate (list 10 20 30 40 50 60 70 80 90 100) 600) 0 0.001)\n    (check-within (candidate (list 100 200 300 400 500 600 700 800 900 1000) 5000) 0 0.001)\n    (check-within (candidate (list 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3) 45) 0 0.001)\n    (check-within (candidate (list 100 200 300 400 500 600 700 800 900 1000) 3000) 0 0.001)\n    (check-within (candidate (list 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100) 2000) 0 0.001)\n    (check-within (candidate (list 6 6) 2) 2 0.001)\n    (check-within (candidate (list 100 200 300 400 500 600 700 800 900 1000) 4000) 0 0.001)\n    (check-within (candidate (list 10 20 30 40 50 60 70 80 90 100) 550) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20) 5000) 0 0.001)\n    (check-within (candidate (list 100 200 300 400 500 600 700 800 900 1000) 4500) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_224_countSmaller", "language": "rkt", "prompt": "#lang racket\n;; Given an integer list nums, return an integer list counts where counts[i] is the number of smaller elements to the right of nums[i].\n;; Example 1:\n;; Input: nums = [5,2,6,1]\n;; Output: [2,1,1,0]\n;; Explanation:\n;; To the right of 5 there are 2 smaller elements (2 and 1).\n;; To the right of 2 there is only 1 smaller element (1).\n;; To the right of 6 there is 1 smaller element (1).\n;; To the right of 1 there is 0 smaller element.\n;; Example 2:\n;; Input: nums = [-1]\n;; Output: [0]\n;; Example 3:\n;; Input: nums = [-1,-1]\n;; Output: [0,0]\n;; Constraints:\n;; 1 <= nums.length <= 105\n;; -104 <= nums[i] <= 104\n(define (countSmaller nums)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_224_countSmaller.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate countSmaller))\n    (check-within (candidate (list 2 1 3 1 2)) (list 2 0 2 0 0) 0.001)\n    (check-within (candidate (list 2 2 2 2 2 2)) (list 0 0 0 0 0 0) 0.001)\n    (check-within (candidate (list 1 2 3 2 1)) (list 0 1 2 1 0) 0.001)\n    (check-within (candidate (list -1)) (list 0) 0.001)\n    (check-within (candidate (list -1 -1)) (list 0 0) 0.001)\n    (check-within (candidate (list 1)) (list 0) 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) (list 0 0 0 0 0) 0.001)\n    (check-within (candidate (list 2 2 2 2 2)) (list 0 0 0 0 0) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_235_countRangeSum", "language": "rkt", "prompt": "#lang racket\n;; Given an integer list nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\n;; Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.\n;; Example 1:\n;; Input: nums = [-2,5,-1], lower = -2, upper = 2\n;; Output: 3\n;; Explanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.\n;; Example 2:\n;; Input: nums = [0], lower = 0, upper = 0\n;; Output: 1\n;; Constraints:\n;; 1 <= nums.length <= 105\n;; -231 <= nums[i] <= 231 - 1\n;; -105 <= lower <= upper <= 105\n;; The answer is guaranteed to fit in a 32-bit integer.\n(define (countRangeSum nums lower upper)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_235_countRangeSum.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate countRangeSum))\n    (check-within (candidate (list -2 5 -1) -10 10) 6 0.001)\n    (check-within (candidate (list (range 50)) 0 0) 1 0.001)\n    (check-within (candidate (list 10 -10 20 -20 30 -30) -50 50) 21 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 3 3) 2 0.001)\n    (check-within (candidate (list 0) 0 0) 1 0.001)\n    (check-within (candidate (list 1 3 5 7 9) 4 6) 2 0.001)\n    (check-within (candidate (list 10 -10 20 -20 30 -30) -30 30) 21 0.001)\n    (check-within (candidate (list -2 5 -1) -2 2) 3 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_237_minPatches", "language": "rkt", "prompt": "#lang racket\n;; Given a sorted integer list nums and an integer n, add/patch elements to the list such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the list.\n;; Return the minimum number of patches required.\n;; Example 1:\n;; Input: nums = [1,3], n = 6\n;; Output: 1\n;; Explanation:\n;; Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\n;; Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\n;; Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\n;; So we only need 1 patch.\n;; Example 2:\n;; Input: nums = [1,5,10], n = 20\n;; Output: 2\n;; Explanation: The two patches can be [2, 4].\n;; Example 3:\n;; Input: nums = [1,2,2], n = 5\n;; Output: 0\n;; Constraints:\n;; 1 <= nums.length <= 1000\n;; 1 <= nums[i] <= 104\n;; nums is sorted in ascending order.\n;; 1 <= n <= 231 - 1\n(define (minPatches nums n)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_237_minPatches.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minPatches))\n    (check-within (candidate (list 1 2 4 8 16 32 64 128 256 512) 1023) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) 50) 0 0.001)\n    (check-within (candidate (list 1 2 2) 5) 0 0.001)\n    (check-within (candidate (list 1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 262144 524288 1048576) 2047) 0 0.001)\n    (check-within (candidate (list 2 4 8 16 32) 64) 2 0.001)\n    (check-within (candidate (list 1 3 6 12) 24) 1 0.001)\n    (check-within (candidate (range 1 513) 8181) 0 0.001)\n    (check-within (candidate (list 1 5 10) 20) 2 0.001)\n    (check-within (candidate (list 1 2 4 8) 15) 0 0.001)\n    (check-within (candidate (list 1 2 4 8 16) 31) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) 55) 0 0.001)\n    (check-within (candidate (list 1 2 4 8 16 32) 63) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) 37) 0 0.001)\n    (check-within (candidate (list 1 2 4) 7) 0 0.001)\n    (check-within (candidate (list 1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 262144 524288 1048576) 2048) 0 0.001)\n    (check-within (candidate (list 2 4 8 16 32) 1) 1 0.001)\n    (check-within (candidate (list 1 3 5 7) 12) 1 0.001)\n    (check-within (candidate (list 1 2 4 8 16 32 64 128 256 512) 1025) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) 56) 1 0.001)\n    (check-within (candidate (list 1 3) 6) 1 0.001)\n    (check-within (candidate (list 1 2 4 8 16 32) 65) 1 0.001)\n    (check-within (candidate (list 1 4 8 16) 20) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_239_findItinerary", "language": "rkt", "prompt": "#lang racket\n;; You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\n;; All of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n;; For example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"].\n;; You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\n;; Example 1:\n;; Input: tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\n;; Output: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\n;; Example 2:\n;; Input: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\n;; Output: [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\n;; Explanation: Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it is larger in lexical order.\n;; Constraints:\n;; 1 <= tickets.length <= 300\n;; tickets[i].length == 2\n;; fromi.length == 3\n;; toi.length == 3\n;; fromi and toi consist of uppercase English letters.\n;; fromi != toi\n(define (findItinerary tickets)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_239_findItinerary.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate findItinerary))\n    (check-within (candidate (list (list \"MUC\" \"LHR\") (list \"JFK\" \"MUC\") (list \"SFO\" \"SJC\") (list \"LHR\" \"SFO\"))) (list \"JFK\" \"MUC\" \"LHR\" \"SFO\" \"SJC\") 0.001)\n    (check-within (candidate (list (list \"JFK\" \"ATL\") (list \"ATL\" \"JFK\"))) (list \"JFK\" \"ATL\" \"JFK\") 0.001)\n    (check-within (candidate (list (list \"JFK\" \"SFO\") (list \"SFO\" \"JFK\") (list \"JFK\" \"ATL\") (list \"ATL\" \"SFO\") (list \"SFO\" \"JFK\"))) (list \"JFK\" \"ATL\" \"SFO\" \"JFK\" \"SFO\" \"JFK\") 0.001)\n    (check-within (candidate (list (list \"JFK\" \"ATL\") (list \"ATL\" \"JFK\") (list \"JFK\" \"ATL\"))) (list \"JFK\" \"ATL\" \"JFK\" \"ATL\") 0.001)\n    (check-within (candidate (list (list \"JFK\" \"ATL\") (list \"ATL\" \"JFK\") (list \"JFK\" \"SFO\"))) (list \"JFK\" \"ATL\" \"JFK\" \"SFO\") 0.001)\n    (check-within (candidate (list (list \"JFK\" \"ATL\") (list \"ATL\" \"SFO\") (list \"SFO\" \"ATL\") (list \"ATL\" \"JFK\"))) (list \"JFK\" \"ATL\" \"SFO\" \"ATL\" \"JFK\") 0.001)\n    (check-within (candidate (list (list \"JFK\" \"SFO\") (list \"SFO\" \"JFK\"))) (list \"JFK\" \"SFO\" \"JFK\") 0.001)\n    (check-within (candidate (list (list \"JFK\" \"ATL\") (list \"ATL\" \"SFO\") (list \"SFO\" \"JFK\"))) (list \"JFK\" \"ATL\" \"SFO\" \"JFK\") 0.001)\n    (check-within (candidate (list (list \"JFK\" \"ATL\") (list \"ATL\" \"SFO\") (list \"JFK\" \"ATL\") (list \"ATL\" \"JFK\") (list \"SFO\" \"JFK\"))) (list \"JFK\" \"ATL\" \"JFK\" \"ATL\" \"SFO\" \"JFK\") 0.001)\n    (check-within (candidate (list (list \"JFK\" \"SFO\") (list \"JFK\" \"ATL\") (list \"SFO\" \"ATL\") (list \"ATL\" \"JFK\") (list \"ATL\" \"SFO\"))) (list \"JFK\" \"ATL\" \"JFK\" \"SFO\" \"ATL\" \"SFO\") 0.001)\n    (check-within (candidate (list (list \"JFK\" \"ATL\") (list \"ATL\" \"JFK\") (list \"JFK\" \"SFO\") (list \"SFO\" \"ATL\") (list \"ATL\" \"JFK\"))) (list \"JFK\" \"ATL\" \"JFK\" \"SFO\" \"ATL\" \"JFK\") 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_242_palindrome_pairs", "language": "rkt", "prompt": "#lang racket\n;; You are given a 0-indexed list of unique strings words.\n;; A palindrome pair is a pair of integers (i, j) such that:\n;; 0 <= i, j < words.length,\n;; i != j, and\n;; words[i] + words[j] (the concatenation of the two strings) is a palindrome.\n;; Return a list of all the palindrome pairs of words.\n;; You must write an algorithm with\u00a0O(sum of words[i].length)\u00a0runtime complexity.\n;; Example 1:\n;; Input: words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\n;; Output: [[0,1],[1,0],[3,2],[2,4]]\n;; Explanation: The palindromes are [\"abcddcba\",\"dcbaabcd\",\"slls\",\"llssssll\"]\n;; Example 2:\n;; Input: words = [\"bat\",\"tab\",\"cat\"]\n;; Output: [[0,1],[1,0]]\n;; Explanation: The palindromes are [\"battab\",\"tabbat\"]\n;; Example 3:\n;; Input: words = [\"a\",\"\"]\n;; Output: [[0,1],[1,0]]\n;; Explanation: The palindromes are [\"a\",\"a\"]\n;; Constraints:\n;; 1 <= words.length <= 5000\n;; 0 <= words[i].length <= 300\n;; words[i] consists of lowercase English letters.\n(define (palindrome_pairs words)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_242_palindrome_pairs.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate palindrome_pairs))\n    (check-within (candidate (list \"a\" \"\")) (list (list 0 1) (list 1 0)) 0.001)\n    (check-within (candidate (list \"ab\" \"ba\" \"cd\" \"dc\")) (list (list 0 1) (list 1 0) (list 2 3) (list 3 2)) 0.001)\n    (check-within (candidate (list \"abcd\" \"dcba\" \"lls\" \"s\" \"sssll\")) (list (list 0 1) (list 1 0) (list 2 4) (list 3 2)) 0.001)\n    (check-within (candidate (list \"x\" \"y\" \"z\")) (list ) 0.001)\n    (check-within (candidate (list \"abc\" \"def\" \"abc\" \"cba\")) (list (list 0 3) (list 2 3) (list 3 0) (list 3 2)) 0.001)\n    (check-within (candidate (list \"radar\" \"dar\" \"\")) (list (list 0 2) (list 2 0)) 0.001)\n    (check-within (candidate (list \"abc\" \"def\" \"ghi\" \"jkl\")) (list ) 0.001)\n    (check-within (candidate (list \"bat\" \"tab\" \"cat\")) (list (list 0 1) (list 1 0)) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_24_findSubstring", "language": "rkt", "prompt": "#lang racket\n;; You are given a string s and a list of strings words. All the strings of words are of the same length.\n;; A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n;; For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n;; Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n;; Example 1:\n;; Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n;; Output: [0,9]\n;; Explanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\n;; The substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\n;; The substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\n;; The output order does not matter. Returning [9,0] is fine too.\n;; Example 2:\n;; Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n;; Output: []\n;; Explanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\n;; There is no substring of length 16 in s that is equal to the concatenation of any permutation of words.\n;; We return an empty list.\n;; Example 3:\n;; Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n;; Output: [6,9,12]\n;; Explanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\n;; The substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\n;; The substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\n;; The substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n;; Constraints:\n;; 1 <= s.length <= 104\n;; 1 <= words.length <= 5000\n;; 1 <= words[i].length <= 30\n;; s and words[i] consist of lowercase English letters.\n(define (findSubstring s words)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_24_findSubstring.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate findSubstring))\n    (check-within (candidate \"abcd\" (list \"ab\" \"cd\" \"ef\")) (list ) 0.001)\n    (check-within (candidate \"wordgoodgoodgoodbestword\" (list \"word\" \"good\" \"best\" \"word\" \"good\" \"best\" \"word\")) (list ) 0.001)\n    (check-within (candidate \"abcdabdc\" (list \"ab\" \"cd\" \"cd\")) (list ) 0.001)\n    (check-within (candidate \"\" (list \"\")) (list ) 0.001)\n    (check-within (candidate \"wordgoodgoodgoodbestword\" (list )) (list ) 0.001)\n    (check-within (candidate \"a\" (list \"a\")) (list 0) 0.001)\n    (check-within (candidate \"\" (list \"a\")) (list ) 0.001)\n    (check-within (candidate \"aaa\" (list \"a\" \"b\")) (list ) 0.001)\n    (check-within (candidate \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" (list \"fooo\" \"barr\" \"wing\" \"ding\" \"wing\")) (list 13) 0.001)\n    (check-within (candidate \"barfoofoobarthefoobarman\" (list \"bar\" \"foo\" \"the\")) (list 6 9 12) 0.001)\n    (check-within (candidate \"barfoothefoobarman\" (list \"foo\" \"bar\" \"man\")) (list 9) 0.001)\n    (check-within (candidate \"barfoofoobarthefoobarman\" (list \"bar\" \"foo\" \"the\" \"man\")) (list 12) 0.001)\n    (check-within (candidate \"a\" (list \"b\")) (list ) 0.001)\n    (check-within (candidate \"wordgoodgoodgoodbestword\" (list \"word\" \"good\" \"best\" \"word\" \"word\")) (list ) 0.001)\n    (check-within (candidate \"barfoothefoobarman\" (list \"foo\" \"bar\" \"man\" \"foo\")) (list ) 0.001)\n    (check-within (candidate \"wordgoodgoodgoodbestword\" (list \"word\" \"good\" \"best\" \"word\" \"good\")) (list ) 0.001)\n    (check-within (candidate \"foobarfoobar\" (list \"foo\" \"bar\")) (list 0 3 6) 0.001)\n    (check-within (candidate \"wordgoodgoodgoodbestword\" (list \"word\" \"good\" \"best\" \"word\")) (list ) 0.001)\n    (check-within (candidate \"ababababab\" (list \"a\" \"b\" \"a\")) (list 0 2 4 6) 0.001)\n    (check-within (candidate \"\" (list \"a\" \"b\" \"c\" \"ab\" \"ac\" \"bc\")) (list ) 0.001)\n    (check-within (candidate \"aaa\" (list \"a\" \"a\" \"a\")) (list 0) 0.001)\n    (check-within (candidate \"\" (list \"word\" \"good\" \"best\" \"word\")) (list ) 0.001)\n    (check-within (candidate \"aa\" (list \"a\" \"a\")) (list 0) 0.001)\n    (check-within (candidate \"wordgoodgoodgoodbestword\" (list \"word\" \"good\" \"best\" \"best\")) (list ) 0.001)\n    (check-within (candidate \"barfoothefoobarman\" (list \"foo\" \"bar\")) (list 0 9) 0.001)\n    (check-within (candidate \"aaa\" (list \"a\" \"a\" \"a\" \"a\")) (list ) 0.001)\n    (check-within (candidate \"aa\" (list \"aa\")) (list 0) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_255_max_envelopes", "language": "rkt", "prompt": "#lang racket\n;; You are given a 2D list of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n;; One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n;; Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n;; Note: You cannot rotate an envelope.\n;; Example 1:\n;; Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]\n;; Output: 3\n;; Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\n;; Example 2:\n;; Input: envelopes = [[1,1],[1,1],[1,1]]\n;; Output: 1\n;; Constraints:\n;; 1 <= envelopes.length <= 105\n;; envelopes[i].length == 2\n;; 1 <= wi, hi <= 105\n(define (max_envelopes envelopes)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_255_max_envelopes.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_envelopes))\n    (check-within (candidate (list (list 5 4) (list 6 4) (list 6 7) (list 2 3) (list 1 2))) 4 0.001)\n    (check-within (candidate (list (list 1 1) (list 1 1) (list 1 1))) 1 0.001)\n    (check-within (candidate (list (list 1 10) (list 2 9) (list 3 8) (list 4 7) (list 5 6) (list 6 5) (list 7 4) (list 8 3) (list 9 2) (list 10 1))) 1 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 7) (list 7 8) (list 8 9) (list 9 10) (list 10 11))) 10 0.001)\n    (check-within (candidate (list (list 10 20) (list 20 30) (list 30 40) (list 40 50))) 4 0.001)\n    (check-within (candidate (list (list 5 4) (list 6 4) (list 6 7) (list 2 3))) 3 0.001)\n    (check-within (candidate (list (list 1 1) (list 2 2) (list 3 3) (list 4 4) (list 5 5))) 5 0.001)\n    (check-within (candidate (list (list 10 20) (list 15 25) (list 20 30) (list 25 35) (list 30 40))) 5 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 7) (list 7 8) (list 8 9) (list 9 10) (list 11 12))) 10 0.001)\n    (check-within (candidate (list (list 5 5) (list 5 5) (list 5 5) (list 5 5) (list 5 5) (list 5 5) (list 5 5) (list 5 5) (list 5 5) (list 5 5))) 1 0.001)\n    (check-within (candidate (list (list 1 1))) 1 0.001)\n    (check-within (candidate (list (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 7) (list 7 8) (list 8 9) (list 9 10) (list 10 11) (list 11 12))) 10 0.001)\n    (check-within (candidate (list (list 4 5) (list 5 6) (list 6 7) (list 7 8))) 4 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_26_longest_valid_parentheses", "language": "rkt", "prompt": "#lang racket\n;; Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n;; Example 1:\n;; Input: s = \"(()\"\n;; Output: 2\n;; Explanation: The longest valid parentheses substring is \"()\".\n;; Example 2:\n;; Input: s = \")()())\"\n;; Output: 4\n;; Explanation: The longest valid parentheses substring is \"()()\".\n;; Example 3:\n;; Input: s = \"\"\n;; Output: 0\n;; Constraints:\n;; 0 <= s.length <= 3 * 104\n;; s[i] is '(', or ')'.\n(define (longest_valid_parentheses s)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_26_longest_valid_parentheses.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate longest_valid_parentheses))\n    (check-within (candidate \"()()\") 4 0.001)\n    (check-within (candidate \"()(((((((()())()))))))()(()))()())\") 28 0.001)\n    (check-within (candidate \")()())()()())(())\") 6 0.001)\n    (check-within (candidate \")()())\") 4 0.001)\n    (check-within (candidate \")(()()())\") 8 0.001)\n    (check-within (candidate \"(()())())\") 8 0.001)\n    (check-within (candidate \"()(()))\") 6 0.001)\n    (check-within (candidate \"(()\") 2 0.001)\n    (check-within (candidate \"(()(()())\") 8 0.001)\n    (check-within (candidate \"()\") 2 0.001)\n    (check-within (candidate \"()(())\") 6 0.001)\n    (check-within (candidate \"()(((((((()())()))))))()(()))())\") 28 0.001)\n    (check-within (candidate \"((((((((((()))))))))\") 18 0.001)\n    (check-within (candidate \"((((((((((())))))))))\") 20 0.001)\n    (check-within (candidate \"\") 0 0.001)\n    (check-within (candidate \"()((((((((((((((((((())))))))))))))))()))(())))\") 46 0.001)\n    (check-within (candidate \"((()()()())(()))())()()()()()\") 18 0.001)\n    (check-within (candidate \"()(()())\") 8 0.001)\n    (check-within (candidate \"(()((())())()()()()()()())\") 26 0.001)\n    (check-within (candidate \"()(()\") 2 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_281_isRectangleCover", "language": "rkt", "prompt": "#lang racket\n;; Given a list rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).\n;; Return true if all the rectangles together form an exact cover of a rectangular region.\n;; Example 1:\n;; Input: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\n;; Output: true\n;; Explanation: All 5 rectangles together form an exact cover of a rectangular region.\n;; Example 2:\n;; Input: rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]\n;; Output: false\n;; Explanation: Because there is a gap between the two rectangular regions.\n;; Example 3:\n;; Input: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]\n;; Output: false\n;; Explanation: Because two of the rectangles overlap with each other.\n;; Constraints:\n;; 1 <= rectangles.length <= 2 * 104\n;; rectangles[i].length == 4\n;; -105 <= xi, yi, ai, bi <= 105\n(define (isRectangleCover rectangles)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_281_isRectangleCover.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate isRectangleCover))\n    (check-within (candidate (list (list 1 1 3 3) (list 3 3 4 4))) #f 0.001)\n    (check-within (candidate (list (list 1 1 2 3) (list 1 3 2 4) (list 3 1 4 2) (list 3 2 4 4) (list 2 1 4 3))) #f 0.001)\n    (check-within (candidate (list (list 1 1 2 3) (list 1 3 2 4) (list 3 1 4 2) (list 3 2 4 4))) #f 0.001)\n    (check-within (candidate (list (list 0 0 1 1) (list 1 0 2 1) (list 0 1 1 2) (list 1 1 2 2))) #t 0.001)\n    (check-within (candidate (list (list 1 2 2 3) (list 1 2 3 2) (list 2 2 3 3) (list 2 2 4 4))) #f 0.001)\n    (check-within (candidate (list (list 1 1 2 3) (list 1 3 2 4) (list 3 1 4 2) (list 3 2 4 4) (list 3 1 3 3))) #f 0.001)\n    (check-within (candidate (list (list 1 1 2 3) (list 2 2 3 3) (list 1 3 2 4) (list 2 3 3 4))) #f 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 3 1 4 2) (list 1 3 2 4) (list 2 2 4 4) (list 1 1 4 2))) #f 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 3 1 4 2) (list 3 2 4 4) (list 1 3 1 4) (list 1 3 2 3) (list 2 3 3 4))) #f 0.001)\n    (check-within (candidate (list (list 1 1 2 3) (list 1 3 2 4) (list 2 2 4 4))) #f 0.001)\n    (check-within (candidate (list (list 1 1 3 3))) #t 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 3 1 4 2) (list 1 3 2 4) (list 2 2 4 4) (list 2 1 3 3))) #f 0.001)\n    (check-within (candidate (list (list 1 1 2 3) (list 1 3 2 4) (list 2 1 3 3))) #f 0.001)\n    (check-within (candidate (list (list 1 1 2 2) (list 2 1 3 2) (list 3 1 4 2) (list 1 2 2 3) (list 2 2 3 3) (list 3 2 4 3))) #t 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 3 1 4 2) (list 1 3 2 4) (list 2 2 4 4) (list 4 1 4 4))) #f 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 3 1 4 2) (list 1 3 2 4) (list 2 2 4 4))) #f 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 3 1 4 2) (list 1 3 2 4) (list 2 2 4 4) (list 3 1 3 3))) #f 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 3 1 4 2) (list 3 2 4 4) (list 1 3 2 4) (list 2 3 3 4))) #t 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 3 1 4 2) (list 1 3 2 4) (list 2 2 4 3))) #f 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 3 1 4 2) (list 1 3 2 4) (list 2 2 4 4) (list 1 1 4 4))) #f 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 3 1 4 2) (list 1 3 2 4) (list 2 2 4 4) (list 1 1 2 2))) #f 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 3 1 4 2) (list 1 3 3 4) (list 2 2 4 4))) #f 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 3 1 4 2) (list 1 3 2 4) (list 2 2 4 4) (list 5 5 6 6))) #f 0.001)\n    (check-within (candidate (list (list 1 1 2 2) (list 2 1 3 2) (list 3 1 4 2) (list 1 2 4 3))) #t 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 3 1 4 2) (list 1 3 2 4) (list 3 2 4 4) (list 3 1 3 3))) #f 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 3 1 4 2) (list 1 3 2 4) (list 3 2 4 4))) #f 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_295_trapRainWater", "language": "rkt", "prompt": "#lang racket\n;; Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.\n;; Example 1:\n;; Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\n;; Output: 4\n;; Explanation: After the rain, water is trapped between the blocks.\n;; We have two small ponds 1 and 3 units trapped.\n;; The total volume of water trapped is 4.\n;; Example 2:\n;; Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\n;; Output: 10\n;; Constraints:\n;; m == heightMap.length\n;; n == heightMap[i].length\n;; 1 <= m, n <= 200\n;; 0 <= heightMap[i][j] <= 2 * 104\n(define (trapRainWater heightMap)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_295_trapRainWater.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate trapRainWater))\n    (check-within (candidate (list (list 3 3 3 3 3) (list 3 2 2 2 3) (list 3 2 1 2 3) (list 3 2 2 2 3) (list 3 3 3 3 3))) 10 0.001)\n    (check-within (candidate (list (list 1 4 3 1 3 2) (list 3 2 1 3 2 4) (list 2 3 3 2 3 1))) 4 0.001)\n    (check-within (candidate (list (list 1 4 3 1 3 2) (list 3 2 1 3 2 4) (list 2 3 3 2 3 1))) 4 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5) (list 1 0 0 0 1) (list 1 0 0 0 1) (list 1 1 1 1 1))) 6 0.001)\n    (check-within (candidate (list (list 3 3 3 3 3) (list 3 2 2 2 3) (list 3 2 1 2 3) (list 3 2 2 2 3) (list 3 3 3 3 3))) 10 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_321_find_kth_number", "language": "rkt", "prompt": "#lang racket\n;; Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].\n;; Example 1:\n;; Input: n = 13, k = 2\n;; Output: 10\n;; Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\n;; Example 2:\n;; Input: n = 1, k = 1\n;; Output: 1\n;; Constraints:\n;; 1 <= k <= n <= 109\n(define (find_kth_number n k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_321_find_kth_number.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_kth_number))\n    (check-within (candidate 9999 9999) 9999 0.001)\n    (check-within (candidate 2 1) 1 0.001)\n    (check-within (candidate 100 10) 17 0.001)\n    (check-within (candidate 10000 1) 1 0.001)\n    (check-within (candidate 13 1) 1 0.001)\n    (check-within (candidate 1 1) 1 0.001)\n    (check-within (candidate 2 2) 2 0.001)\n    (check-within (candidate 13 2) 10 0.001)\n    (check-within (candidate 1000 1) 1 0.001)\n    (check-within (candidate 100 2) 10 0.001)\n    (check-within (candidate 100 1) 1 0.001)\n    (check-within (candidate 15 1) 1 0.001)\n    (check-within (candidate 100000 1) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_343_getMaxRepetitions", "language": "rkt", "prompt": "#lang racket\n;; We define str = [s, n] as the string str which consists of the string s concatenated n times.\n;; For example, str == [\"abc\", 3] ==\"abcabcabc\".\n;; We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n;; For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n;; You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n;; Return the maximum integer m such that str = [str2, m] can be obtained from str1.\n;; Example 1:\n;; Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n;; Output: 2\n;; Example 2:\n;; Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n;; Output: 1\n;; Constraints:\n;; 1 <= s1.length, s2.length <= 100\n;; s1 and s2 consist of lowercase English letters.\n;; 1 <= n1, n2 <= 106\n(define (getMaxRepetitions s1 n1 s2 n2)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_343_getMaxRepetitions.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate getMaxRepetitions))\n    (check-within (candidate \"abcdabcdabcdabcdabcdabcd\" 1 \"abcdabcd\" 3) 1 0.001)\n    (check-within (candidate \"abcd\" 1 \"ab\" 2) 0 0.001)\n    (check-within (candidate \"abcd\" 1 \"abcd\" 1) 1 0.001)\n    (check-within (candidate \"abc\" 4 \"ab\" 2) 2 0.001)\n    (check-within (candidate \"a\" 0 \"a\" 1) 0 0.001)\n    (check-within (candidate \"abcdabcd\" 1 \"abcd\" 1) 2 0.001)\n    (check-within (candidate \"abc\" 3 \"abcabc\" 3) 0 0.001)\n    (check-within (candidate \"abcabcabc\" 5 \"abc\" 3) 5 0.001)\n    (check-within (candidate \"abcdefg\" 6 \"abc\" 1) 6 0.001)\n    (check-within (candidate \"abcdefg\" 5 \"abc\" 1) 5 0.001)\n    (check-within (candidate \"abcdefg\" 3 \"abc\" 1) 3 0.001)\n    (check-within (candidate \"abcabc\" 2 \"abc\" 3) 1 0.001)\n    (check-within (candidate \"abcd\" 1 \"a\" 2) 0 0.001)\n    (check-within (candidate \"abca\" 2 \"abc\" 2) 1 0.001)\n    (check-within (candidate \"abc\" 3 \"abc\" 3) 1 0.001)\n    (check-within (candidate \"a\" 100 \"aa\" 50) 1 0.001)\n    (check-within (candidate \"abcdefg\" 2 \"abc\" 1) 2 0.001)\n    (check-within (candidate \"abcdefg\" 4 \"abc\" 1) 4 0.001)\n    (check-within (candidate \"abcabc\" 2 \"abc\" 2) 2 0.001)\n    (check-within (candidate \"bba\" 1 \"ab\" 2) 0 0.001)\n    (check-within (candidate \"abc\" 100 \"a\" 1) 100 0.001)\n    (check-within (candidate \"abcd\" 1 \"ab\" 3) 0 0.001)\n    (check-within (candidate \"abcdefg\" 1 \"abcdefg\" 1) 1 0.001)\n    (check-within (candidate \"abcdefg\" 3 \"abcdef\" 3) 1 0.001)\n    (check-within (candidate \"ab\" 2 \"a\" 1) 2 0.001)\n    (check-within (candidate \"abcabcabcabcabcabcabcabcabc\" 1 \"abcabcabcabcabcabcabcabcabc\" 1) 1 0.001)\n    (check-within (candidate \"abcabcabcabc\" 4 \"abcabc\" 2) 4 0.001)\n    (check-within (candidate \"bba\" 1 \"ab\" 10) 0 0.001)\n    (check-within (candidate \"abcd\" 1 \"a\" 4) 0 0.001)\n    (check-within (candidate \"abcd\" 1 \"a\" 3) 0 0.001)\n    (check-within (candidate \"abc\" 1 \"abc\" 1) 1 0.001)\n    (check-within (candidate \"abcabcabc\" 1 \"abc\" 3) 1 0.001)\n    (check-within (candidate \"abcabcab\" 3 \"abc\" 2) 3 0.001)\n    (check-within (candidate \"abcdabcdabcdabcdabcd\" 1 \"abcd\" 5) 1 0.001)\n    (check-within (candidate \"abc\" 5 \"ab\" 1) 5 0.001)\n    (check-within (candidate \"abc\" 3 \"abcabcabc\" 1) 1 0.001)\n    (check-within (candidate \"abcdefg\" 1 \"abc\" 1) 1 0.001)\n    (check-within (candidate \"b\" 99 \"aa\" 1) 0 0.001)\n    (check-within (candidate \"abc\" 3 \"abc\" 1) 3 0.001)\n    (check-within (candidate \"abcabcabcabcabcabc\" 1 \"abcabcabc\" 2) 1 0.001)\n    (check-within (candidate \"a\" 1 \"a\" 1) 1 0.001)\n    (check-within (candidate \"abcabc\" 1 \"abc\" 1) 2 0.001)\n    (check-within (candidate \"abcdefg\" 7 \"abc\" 1) 7 0.001)\n    (check-within (candidate \"s1\" 1 \"s2\" 1) 0 0.001)\n    (check-within (candidate \"abcd\" 1 \"ab\" 4) 0 0.001)\n    (check-within (candidate \"bba\" 1 \"ab\" 1) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_359_smallest_good_base", "language": "rkt", "prompt": "#lang racket\n;; Given an integer n represented as a string, return the smallest good base of n.\n;; We call k >= 2 a good base of n, if all digits of n base k are 1's.\n;; Example 1:\n;; Input: n = \"13\"\n;; Output: \"3\"\n;; Explanation: 13 base 3 is 111.\n;; Example 2:\n;; Input: n = \"4681\"\n;; Output: \"8\"\n;; Explanation: 4681 base 8 is 11111.\n;; Example 3:\n;; Input: n = \"1000000000000000000\"\n;; Output: \"999999999999999999\"\n;; Explanation: 1000000000000000000 base 999999999999999999 is 11.\n;; Constraints:\n;; n is an integer in the range [3, 1018].\n;; n does not contain any leading zeros.\n(define (smallest_good_base n)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_359_smallest_good_base.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate smallest_good_base))\n    (check-within (candidate \"13\") \"3\" 0.001)\n    (check-within (candidate \"2\") \"-1\" 0.001)\n    (check-within (candidate \"1000000000000000011\") \"-1\" 0.001)\n    (check-within (candidate \"4681\") \"8\" 0.001)\n    (check-within (candidate \"12\") \"-1\" 0.001)\n    (check-within (candidate \"1000000000000000010\") \"-1\" 0.001)\n    (check-within (candidate \"10000000000000000101\") \"-1\" 0.001)\n    (check-within (candidate \"1234\") \"-1\" 0.001)\n    (check-within (candidate \"122221221222212223\") \"-1\" 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_35_firstMissingPositive", "language": "rkt", "prompt": "#lang racket\n;; Given an unsorted integer list nums, return the smallest missing positive integer.\n;; You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\n;; Example 1:\n;; Input: nums = [1,2,0]\n;; Output: 3\n;; Explanation: The numbers in the range [1,2] are all in the list.\n;; Example 2:\n;; Input: nums = [3,4,-1,1]\n;; Output: 2\n;; Explanation: 1 is in the list but 2 is missing.\n;; Example 3:\n;; Input: nums = [7,8,9,11,12]\n;; Output: 1\n;; Explanation: The smallest positive integer 1 is missing.\n;; Constraints:\n;; 1 <= nums.length <= 105\n;; -231 <= nums[i] <= 231 - 1\n(define (firstMissingPositive nums)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_35_firstMissingPositive.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate firstMissingPositive))\n    (check-within (candidate (list 3 4 -1 1)) 2 0.001)\n    (check-within (candidate (list 5 4 3 2 1)) 6 0.001)\n    (check-within (candidate (list 1 1 1 1)) 2 0.001)\n    (check-within (candidate (list 1)) 2 0.001)\n    (check-within (candidate (list 2)) 1 0.001)\n    (check-within (candidate (list 1 2 5 7 9 11)) 3 0.001)\n    (check-within (candidate (list 7 8 9 11 12)) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5)) 6 0.001)\n    (check-within (candidate (list 1 2 3 5 5 6 6 7 8 9 10)) 4 0.001)\n    (check-within (candidate (list 0 2 1 4 3 6 5 -2 7 9 8 11 10 12 13 14 15 16 17 18)) 19 0.001)\n    (check-within (candidate (list 3 4 -1 1)) 2 0.001)\n    (check-within (candidate (list 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3)) 4 0.001)\n    (check-within (candidate (list 1 1 1 1)) 2 0.001)\n    (check-within (candidate (list -1 -2 -3 -4)) 1 0.001)\n    (check-within (candidate (list 7 8 9 11 12)) 1 0.001)\n    (check-within (candidate (list -1)) 1 0.001)\n    (check-within (candidate (list -2 -3 -5 -1 -7 -10 -11 -12 -13 -15 -16 -17 -18 -19 -20 2 1 6 7 3)) 4 0.001)\n    (check-within (candidate (list 0)) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5 7 8 9 10)) 6 0.001)\n    (check-within (candidate (list 1 2 0)) 3 0.001)\n    (check-within (candidate (list 2 3)) 1 0.001)\n    (check-within (candidate (list 2 2 2 2 3 3 3 3)) 1 0.001)\n    (check-within (candidate (list 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3)) 4 0.001)\n    (check-within (candidate (list 1 2 0)) 3 0.001)\n    (check-within (candidate (list 0)) 1 0.001)\n    (check-within (candidate (list 100 101 102 103 104)) 1 0.001)\n    (check-within (candidate (list 2 5 6 8 11 15)) 1 0.001)\n    (check-within (candidate (list 2)) 1 0.001)\n    (check-within (candidate (list 0 0 0 0)) 1 0.001)\n    (check-within (candidate (list 1 1 2 2 3 3)) 4 0.001)\n    (check-within (candidate (list 1 2 3 5 5 6 6 7 8 9 10)) 4 0.001)\n    (check-within (candidate (list -1)) 1 0.001)\n    (check-within (candidate (list 1 2 5 7 9 11)) 3 0.001)\n    (check-within (candidate (list 5 4 3 2 1)) 6 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_364_find_min_step", "language": "rkt", "prompt": "#lang racket\n;; You are playing a variation of the game Zuma.\n;; In this variation of Zuma, there is a single row of colored balls on a board, where each ball can be colored red 'R', yellow 'Y', blue 'B', green 'G', or white 'W'. You also have several colored balls in your hand.\n;; Your goal is to clear all of the balls from the board. On each turn:\n;; Pick any ball from your hand and insert it in between two balls in the row or on either end of the row.\n;; If there is a group of three or more consecutive balls of the same color, remove the group of balls from the board.\n;; If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.\n;; If there are no more balls on the board, then you win the game.\n;; Repeat this process until you either win or do not have any more balls in your hand.\n;; Given a string board, representing the row of balls on the board, and a string hand, representing the balls in your hand, return the minimum number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return -1.\n;; Example 1:\n;; Input: board = \"WRRBBW\", hand = \"RB\"\n;; Output: -1\n;; Explanation: It is impossible to clear all the balls. The best you can do is:\n;; - Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.\n;; - Insert 'B' so the board becomes WBBBW. WBBBW -> WW.\n;; There are still balls remaining on the board, and you are out of balls to insert.\n;; Example 2:\n;; Input: board = \"WWRRBBWW\", hand = \"WRBRW\"\n;; Output: 2\n;; Explanation: To make the board empty:\n;; - Insert 'R' so the board becomes WWRRRBBWW. WWRRRBBWW -> WWBBWW.\n;; - Insert 'B' so the board becomes WWBBBWW. WWBBBWW -> WWWW -> empty.\n;; 2 balls from your hand were needed to clear the board.\n;; Example 3:\n;; Input: board = \"G\", hand = \"GGGGG\"\n;; Output: 2\n;; Explanation: To make the board empty:\n;; - Insert 'G' so the board becomes GG.\n;; - Insert 'G' so the board becomes GGG. GGG -> empty.\n;; 2 balls from your hand were needed to clear the board.\n;; Constraints:\n;; 1 <= board.length <= 16\n;; 1 <= hand.length <= 5\n;; board and hand consist of the characters 'R', 'Y', 'B', 'G', and 'W'.\n;; The initial row of balls on the board will not have any groups of three or more consecutive balls of the same color.\n(define (find_min_step board hand)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_364_find_min_step.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_min_step))\n    (check-within (candidate \"GRBGYRB\" \"GRBGYRB\") -1 0.001)\n    (check-within (candidate \"G\" \"GGGGG\") 2 0.001)\n    (check-within (candidate \"YGRBYGR\" \"YGRBYGR\") -1 0.001)\n    (check-within (candidate \"RGYBRGY\" \"RGYBRGY\") -1 0.001)\n    (check-within (candidate \"YBGYRBY\" \"YBGYRBY\") -1 0.001)\n    (check-within (candidate \"BGRYGBR\" \"BGRYGBR\") -1 0.001)\n    (check-within (candidate \"WYBWYBW\" \"WYBWYB\") -1 0.001)\n    (check-within (candidate \"YBGRBGY\" \"YBGRBGY\") -1 0.001)\n    (check-within (candidate \"WBYBRYW\" \"WBYBRYW\") -1 0.001)\n    (check-within (candidate \"RBYGRBG\" \"RBYGRBG\") -1 0.001)\n    (check-within (candidate \"YBRYBR\" \"YBRYBR\") -1 0.001)\n    (check-within (candidate \"WBRWYBW\" \"WBRWYB\") -1 0.001)\n    (check-within (candidate \"WRRBBW\" \"RB\") -1 0.001)\n    (check-within (candidate \"RBYGGRB\" \"RBYGGRB\") -1 0.001)\n    (check-within (candidate \"BGRYBGR\" \"BGRYBGR\") -1 0.001)\n    (check-within (candidate \"BGYRBGY\" \"BGYRBGY\") -1 0.001)\n    (check-within (candidate \"WBRYBWR\" \"WBRYBWR\") -1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_376_findMaximizedCapital", "language": "rkt", "prompt": "#lang racket\n;; Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\n;; You are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\n;; Initially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n;; Pick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\n;; The answer is guaranteed to fit in a 32-bit signed integer.\n;; Example 1:\n;; Input: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n;; Output: 4\n;; Explanation: Since your initial capital is 0, you can only start the project indexed 0.\n;; After finishing it you will obtain profit 1 and your capital becomes 1.\n;; With capital 1, you can either start the project indexed 1 or the project indexed 2.\n;; Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\n;; Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n;; Example 2:\n;; Input: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\n;; Output: 6\n;; Constraints:\n;; 1 <= k <= 105\n;; 0 <= w <= 109\n;; n == profits.length\n;; n == capital.length\n;; 1 <= n <= 105\n;; 0 <= profits[i] <= 104\n;; 0 <= capital[i] <= 109\n(define (findMaximizedCapital k w profits capital)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_376_findMaximizedCapital.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate findMaximizedCapital))\n    (check-within (candidate 3 0 (list 3 2 1) (list 0 1 2)) 6 0.001)\n    (check-within (candidate 1 1 (list 1 2 3) (list 0 1 2)) 3 0.001)\n    (check-within (candidate 3 0 (list 1 2 3) (list 0 1 2)) 6 0.001)\n    (check-within (candidate 3 1 (list 1 1 1) (list 0 0 0)) 4 0.001)\n    (check-within (candidate 3 1 (list 3 2 1) (list 0 1 2)) 7 0.001)\n    (check-within (candidate 3 0 (list 1 2 3) (list 0 0 0)) 6 0.001)\n    (check-within (candidate 1 2 (list 1 2 3) (list 0 1 2)) 5 0.001)\n    (check-within (candidate 4 2 (list 1 2 1) (list 0 0 1)) 6 0.001)\n    (check-within (candidate 3 2 (list 3 2 1) (list 0 1 2)) 8 0.001)\n    (check-within (candidate 3 2 (list 1 1 1) (list 0 0 0)) 5 0.001)\n    (check-within (candidate 4 0 (list 1 2 3) (list 0 1 1)) 6 0.001)\n    (check-within (candidate 0 0 (list 1 2 3) (list 0 0 0)) 0 0.001)\n    (check-within (candidate 3 0 (list 2 2 3) (list 0 1 1)) 7 0.001)\n    (check-within (candidate 2 0 (list 2 1 1) (list 0 1 0)) 3 0.001)\n    (check-within (candidate 1 0 (list 3) (list 0)) 3 0.001)\n    (check-within (candidate 2 0 (list 1 2 3) (list 0 1 1)) 4 0.001)\n    (check-within (candidate 3 0 (list 1 1 1) (list 0 0 0)) 3 0.001)\n    (check-within (candidate 1 2 (list 1 2 3) (list 0 1 1)) 5 0.001)\n    (check-within (candidate 1 0 (list 5) (list 0)) 5 0.001)\n    (check-within (candidate 4 0 (list 1 1 1 1) (list 0 0 1 1)) 4 0.001)\n    (check-within (candidate 4 2 (list 1 3 1 1) (list 0 0 1 2)) 8 0.001)\n    (check-within (candidate 4 0 (list 2 2 3) (list 0 1 1)) 7 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_385_find_rotate_steps", "language": "rkt", "prompt": "#lang racket\n;; In the video game Fallout 4, the quest \"Road to Freedom\" requires players to reach a metal dial called the \"Freedom Trail Ring\" and use the dial to spell a specific keyword to open the door.\n;; Given a string ring that represents the code engraved on the outer ring and another string key that represents the keyword that needs to be spelled, return the minimum number of steps to spell all the characters in the keyword.\n;; Initially, the first character of the ring is aligned at the \"12:00\" direction. You should spell all the characters in key one by one by rotating ring clockwise or anticlockwise to make each character of the string key aligned at the \"12:00\" direction and then by pressing the center button.\n;; At the stage of rotating the ring to spell the key character key[i]:\n;; You can rotate the ring clockwise or anticlockwise by one place, which counts as one step. The final purpose of the rotation is to align one of ring's characters at the \"12:00\" direction, where this character must equal key[i].\n;; If the character key[i] has been aligned at the \"12:00\" direction, press the center button to spell, which also counts as one step. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.\n;; Example 1:\n;; Input: ring = \"godding\", key = \"gd\"\n;; Output: 4\n;; Explanation:\n;; For the first key character 'g', since it is already in place, we just need 1 step to spell this character. \n;; For the second key character 'd', we need to rotate the ring \"godding\" anticlockwise by two steps to make it become \"ddinggo\".\n;; Also, we need 1 more step for spelling.\n;; So the final output is 4.\n;; Example 2:\n;; Input: ring = \"godding\", key = \"godding\"\n;; Output: 13\n;; Constraints:\n;; 1 <= ring.length, key.length <= 100\n;; ring and key consist of only lower case English letters.\n;; It is guaranteed that key could always be spelled by rotating ring.\n(define (find_rotate_steps ring key)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_385_find_rotate_steps.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_rotate_steps))\n    (check-within (candidate \"abc\" \"c\") 2 0.001)\n    (check-within (candidate \"abcde\" \"ba\") 4 0.001)\n    (check-within (candidate \"godding\" \"gd\") 4 0.001)\n    (check-within (candidate \"godding\" \"godding\") 13 0.001)\n    (check-within (candidate \"abcde\" \"c\") 3 0.001)\n    (check-within (candidate \"godding\" \"godding\") 13 0.001)\n    (check-within (candidate \"x\" \"x\") 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_387_find_min_moves", "language": "rkt", "prompt": "#lang racket\n;; You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.\n;; For each move, you could choose any m (1 <= m <= n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\n;; Given an integer list machines representing the number of dresses in each washing machine from left to right on the line, return the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.\n;; Example 1:\n;; Input: machines = [1,0,5]\n;; Output: 3\n;; Explanation:\n;; 1st move:    1     0 <-- 5    =>    1     1     4\n;; 2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n;; 3rd move:    2     1 <-- 3    =>    2     2     2\n;; Example 2:\n;; Input: machines = [0,3,0]\n;; Output: 2\n;; Explanation:\n;; 1st move:    0 <-- 3     0    =>    1     2     0\n;; 2nd move:    1     2 --> 0    =>    1     1     1\n;; Example 3:\n;; Input: machines = [0,2,0]\n;; Output: -1\n;; Explanation:\n;; It's impossible to make all three washing machines have the same number of dresses.\n;; Constraints:\n;; n == machines.length\n;; 1 <= n <= 104\n;; 0 <= machines[i] <= 105\n(define (find_min_moves machines)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_387_find_min_moves.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_min_moves))\n    (check-within (candidate (list 10 0 0)) -1 0.001)\n    (check-within (candidate (list 1 0 5)) 3 0.001)\n    (check-within (candidate (list 0 3 0)) 2 0.001)\n    (check-within (candidate (list 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000)) 0 0.001)\n    (check-within (candidate (list 10 10 10)) 0 0.001)\n    (check-within (candidate (list 0 0 0)) 0 0.001)\n    (check-within (candidate (list 1000 1000 1000)) 0 0.001)\n    (check-within (candidate (list 1000 1000 1000 1000 1000)) 0 0.001)\n    (check-within (candidate (list 1000 0 0)) -1 0.001)\n    (check-within (candidate (list 1 1 1 1 1)) 0 0.001)\n    (check-within (candidate (list 0 0 100)) -1 0.001)\n    (check-within (candidate (list 0 100 0)) -1 0.001)\n    (check-within (candidate (list 200000000000000000 200000000000000000 200000000000000000)) 0 0.001)\n    (check-within (candidate (list 2 2 2 2 2)) 0 0.001)\n    (check-within (candidate (list 1 1 1)) 0 0.001)\n    (check-within (candidate (list 0 2 0)) -1 0.001)\n    (check-within (candidate (list 100 100 100)) 0 0.001)\n    (check-within (candidate (list 5 5 5)) 0 0.001)\n    (check-within (candidate (list 1000000000000000000 1000000000000000000)) 0 0.001)\n    (check-within (candidate (list 5 0 0)) -1 0.001)\n    (check-within (candidate (list 3 3 3 3 3)) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_439_findIntegers", "language": "rkt", "prompt": "#lang racket\n;; Given a positive integer n, return the number of the integers in the range [0, n] whose binary representations do not contain consecutive ones.\n;; Example 1:\n;; Input: n = 5\n;; Output: 5\n;; Explanation:\n;; Here are the non-negative integers <= 5 with their corresponding binary representations:\n;; 0 : 0\n;; 1 : 1\n;; 2 : 10\n;; 3 : 11\n;; 4 : 100\n;; 5 : 101\n;; Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \n;; Example 2:\n;; Input: n = 1\n;; Output: 2\n;; Example 3:\n;; Input: n = 2\n;; Output: 3\n;; Constraints:\n;; 1 <= n <= 109\n(define (findIntegers n)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_439_findIntegers.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate findIntegers))\n    (check-within (candidate 7) 6 0.001)\n    (check-within (candidate 1) 2 0.001)\n    (check-within (candidate 3) 4 0.001)\n    (check-within (candidate 9) 7 0.001)\n    (check-within (candidate 5) 5 0.001)\n    (check-within (candidate 8) 6 0.001)\n    (check-within (candidate 0) 1 0.001)\n    (check-within (candidate 2) 3 0.001)\n    (check-within (candidate 20) 12 0.001)\n    (check-within (candidate 4) 4 0.001)\n    (check-within (candidate 10) 8 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_450_scheduleCourse", "language": "rkt", "prompt": "#lang racket\n;; There are n different online courses numbered from 1 to n. You are given a list courses where courses[i] = [durationi, lastDayi] indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi.\n;; You will start on the 1st day and you cannot take two or more courses simultaneously.\n;; Return the maximum number of courses that you can take.\n;; Example 1:\n;; Input: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]\n;; Output: 3\n;; Explanation: \n;; There are totally 4 courses, but you can take 3 courses at most:\n;; First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\n;; Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. \n;; Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. \n;; The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n;; Example 2:\n;; Input: courses = [[1,2]]\n;; Output: 1\n;; Example 3:\n;; Input: courses = [[3,2],[4,3]]\n;; Output: 0\n;; Constraints:\n;; 1 <= courses.length <= 104\n;; 1 <= durationi, lastDayi <= 104\n(define (scheduleCourse courses)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_450_scheduleCourse.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate scheduleCourse))\n    (check-within (candidate (list (list 100 200) (list 200 1300) (list 1000 1250) (list 2000 3200))) 3 0.001)\n    (check-within (candidate (list (list 3 2) (list 4 3))) 0 0.001)\n    (check-within (candidate (list (list 5 3) (list 4 2) (list 3 1) (list 2 4) (list 1 5))) 2 0.001)\n    (check-within (candidate (list (list 1 2))) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_451_smallestRange", "language": "rkt", "prompt": "#lang racket\n;; You have k lists of sorted integers in non-decreasing\u00a0order. Find the smallest range that includes at least one number from each of the k lists.\n;; We define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.\n;; Example 1:\n;; Input: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\n;; Output: [20,24]\n;; Explanation: \n;; List 1: [4, 10, 15, 24,26], 24 is in range [20,24].\n;; List 2: [0, 9, 12, 20], 20 is in range [20,24].\n;; List 3: [5, 18, 22, 30], 22 is in range [20,24].\n;; Example 2:\n;; Input: nums = [[1,2,3],[1,2,3],[1,2,3]]\n;; Output: [1,1]\n;; Constraints:\n;; nums.length == k\n;; 1 <= k <= 3500\n;; 1 <= nums[i].length <= 50\n;; -105 <= nums[i][j] <= 105\n;; nums[i]\u00a0is sorted in non-decreasing order.\n(define (smallestRange nums)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_451_smallestRange.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate smallestRange))\n    (check-within (candidate (list (list 100 200 300 400 500) (list 150 250 350 450 550) (list 175 275 375 475 575))) (list 150 200) 0.001)\n    (check-within (candidate (list (list 4 10 15 24 26) (list 0 9 12 20) (list 5 18 22 30))) (list 20 24) 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 0 0 0) (list 0 0 0))) (list 0 0) 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 1 2 3) (list 1 2 3))) (list 1 1) 0.001)\n    (check-within (candidate (list (list 1 10) (list 2 9) (list 3 8))) (list 1 3) 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5) (list 2 3 4 5 6) (list 3 4 5 6 7))) (list 3 3) 0.001)\n    (check-within (candidate (list (list 1 5 9) (list 2 6 10) (list 3 7 11))) (list 1 3) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_46_total_n_queens", "language": "rkt", "prompt": "#lang racket\n;; The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n;; Given an integer n, return the number of distinct solutions to the\u00a0n-queens puzzle.\n;; Example 1:\n;; Input: n = 4\n;; Output: 2\n;; Explanation: There are two distinct solutions to the 4-queens puzzle as shown.\n;; Example 2:\n;; Input: n = 1\n;; Output: 1\n;; Constraints:\n;; 1 <= n <= 9\n(define (total_n_queens n)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_46_total_n_queens.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate total_n_queens))\n    (check-within (candidate 6) 4 0.001)\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 5) 10 0.001)\n    (check-within (candidate 8) 92 0.001)\n    (check-within (candidate 4) 2 0.001)\n    (check-within (candidate 9) 352 0.001)\n    (check-within (candidate 7) 40 0.001)\n    (check-within (candidate 11) 2680 0.001)\n    (check-within (candidate 3) 0 0.001)\n    (check-within (candidate 2) 0 0.001)\n    (check-within (candidate 10) 724 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_479_findKthNumber", "language": "rkt", "prompt": "#lang racket\n;; Nearly everyone has used the Multiplication Table. The multiplication table of size m x n is an integer matrix mat where mat[i][j] == i * j (1-indexed).\n;; Given three integers m, n, and k, return the kth smallest element in the m x n multiplication table.\n;; Example 1:\n;; Input: m = 3, n = 3, k = 5\n;; Output: 3\n;; Explanation: The 5th smallest number is 3.\n;; Example 2:\n;; Input: m = 2, n = 3, k = 6\n;; Output: 6\n;; Explanation: The 6th smallest number is 6.\n;; Constraints:\n;; 1 <= m, n <= 3 * 104\n;; 1 <= k <= m * n\n(define (findKthNumber m n k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_479_findKthNumber.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate findKthNumber))\n    (check-within (candidate 7 8 58) 56 0.001)\n    (check-within (candidate 1 10 1) 1 0.001)\n    (check-within (candidate 3 2 6) 6 0.001)\n    (check-within (candidate 30000 30000 1) 1 0.001)\n    (check-within (candidate 1 1 1) 1 0.001)\n    (check-within (candidate 2 2 4) 4 0.001)\n    (check-within (candidate 3 3 1) 1 0.001)\n    (check-within (candidate 7 8 56) 56 0.001)\n    (check-within (candidate 7 8 57) 56 0.001)\n    (check-within (candidate 2 3 1) 1 0.001)\n    (check-within (candidate 1 30000 30000) 30000 0.001)\n    (check-within (candidate 6 6 36) 36 0.001)\n    (check-within (candidate 10 10 100) 100 0.001)\n    (check-within (candidate 7 7 49) 49 0.001)\n    (check-within (candidate 5 5 1) 1 0.001)\n    (check-within (candidate 2 1 1) 1 0.001)\n    (check-within (candidate 1 2 1) 1 0.001)\n    (check-within (candidate 3 3 2) 2 0.001)\n    (check-within (candidate 2 3 2) 2 0.001)\n    (check-within (candidate 1 2 2) 2 0.001)\n    (check-within (candidate 2 2 2) 2 0.001)\n    (check-within (candidate 7 7 45) 35 0.001)\n    (check-within (candidate 7 8 59) 56 0.001)\n    (check-within (candidate 10 10 1) 1 0.001)\n    (check-within (candidate 2 3 6) 6 0.001)\n    (check-within (candidate 10 1 10) 10 0.001)\n    (check-within (candidate 1 10 10) 10 0.001)\n    (check-within (candidate 2 1 2) 2 0.001)\n    (check-within (candidate 30000 1 30000) 30000 0.001)\n    (check-within (candidate 3 3 5) 3 0.001)\n    (check-within (candidate 5 5 25) 25 0.001)\n    (check-within (candidate 2 3 7) 6 0.001)\n    (check-within (candidate 7 7 48) 42 0.001)\n    (check-within (candidate 3 3 9) 9 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_492_findRedundantDirectedConnection", "language": "rkt", "prompt": "#lang racket\n;; In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\n;; The given input is a directed graph that started as a rooted tree with n nodes (with distinct values from 1 to n), with one additional directed edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed.\n;; The resulting graph is given as a 2D-list of edges. Each element of edges is a pair [ui, vi] that represents a directed edge connecting nodes ui and vi, where ui is a parent of child vi.\n;; Return an edge that can be removed so that the resulting graph is a rooted tree of n nodes. If there are multiple answers, return the answer that occurs last in the given 2D-list.\n;; Example 1:\n;; Input: edges = [[1,2],[1,3],[2,3]]\n;; Output: [2,3]\n;; Example 2:\n;; Input: edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\n;; Output: [4,1]\n;; Constraints:\n;; n == edges.length\n;; 3 <= n <= 1000\n;; edges[i].length == 2\n;; 1 <= ui, vi <= n\n;; ui != vi\n(define (findRedundantDirectedConnection edges)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_492_findRedundantDirectedConnection.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate findRedundantDirectedConnection))\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 7) (list 7 1))) (list 7 1) 0.001)\n    (check-within (candidate (list (list 1 2) (list 1 3) (list 2 3))) (list 2 3) 0.001)\n    (check-within (candidate (list (list 1 2) (list 1 3) (list 3 2))) (list 3 2) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 1) (list 4 1))) (list 3 1) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 1) (list 1 5))) (list 4 1) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 2))) (list 6 2) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 2 4) (list 3 5))) (list 2 4) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 1))) (list 3 1) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 4))) (list 6 4) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 2 5))) (list 2 5) 0.001)\n    (check-within (candidate (list (list 1 2) (list 1 3) (list 2 3))) (list 2 3) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 1))) (list 3 1) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 1 5))) (list 1 5) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 1 4))) (list 1 4) 0.001)\n    (check-within (candidate (list (list 1 2) (list 1 3) (list 3 4) (list 4 2))) (list 4 2) 0.001)\n    (check-within (candidate (list (list 1 2) (list 1 3) (list 3 4) (list 4 5) (list 5 6) (list 6 2))) (list 6 2) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 2 1))) (list 2 1) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 1))) (list 5 1) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 1) (list 1 7))) (list 6 1) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 1) (list 1 5))) (list 4 1) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_496_max_sum_of_three_subarrays", "language": "rkt", "prompt": "#lang racket\n;; Given an integer list nums and an integer k, find three non-overlapping sublists of length k with maximum sum and return them.\n;; Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.\n;; Example 1:\n;; Input: nums = [1,2,1,2,6,7,5,1], k = 2\n;; Output: [0,3,5]\n;; Explanation: Sublists [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].\n;; We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.\n;; Example 2:\n;; Input: nums = [1,2,1,2,1,2,1,2,1], k = 2\n;; Output: [0,2,4]\n;; Constraints:\n;; 1 <= nums.length <= 2 * 104\n;; 1 <= nums[i] <\u00a0216\n;; 1 <= k <= floor(nums.length / 3)\n(define (max_sum_of_three_subarrays nums k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_496_max_sum_of_three_subarrays.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_sum_of_three_subarrays))\n    (check-within (candidate (list 1 2 1 2 1 2 1 2 1) 2) (list 0 2 4) 0.001)\n    (check-within (candidate (list 9 8 7 6 5 4 3 2 1) 2) (list 0 2 4) 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1) 2) (list 0 2 4) 0.001)\n    (check-within (candidate (list 1 2 1 2 1 2 1 2 1 2 1 2 1) 2) (list 0 2 4) 0.001)\n    (check-within (candidate (list 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1) 2) (list 0 2 4) 0.001)\n    (check-within (candidate (list 1 2 1 2 6 7 5 1) 2) (list 0 3 5) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_505_fallingSquares", "language": "rkt", "prompt": "#lang racket\n;; There are several squares being dropped onto the X-axis of a 2D plane.\n;; You are given a 2D integer list positions where positions[i] = [lefti, sideLengthi] represents the ith square with a side length of sideLengthi that is dropped with its left edge aligned with X-coordinate lefti.\n;; Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.\n;; After each square is dropped, you must record the height of the current tallest stack of squares.\n;; Return an integer list ans where ans[i] represents the height described above after dropping the ith square.\n;; Example 1:\n;; Input: positions = [[1,2],[2,3],[6,1]]\n;; Output: [2,5,5]\n;; Explanation:\n;; After the first drop, the tallest stack is square 1 with a height of 2.\n;; After the second drop, the tallest stack is squares 1 and 2 with a height of 5.\n;; After the third drop, the tallest stack is still squares 1 and 2 with a height of 5.\n;; Thus, we return an answer of [2, 5, 5].\n;; Example 2:\n;; Input: positions = [[100,100],[200,100]]\n;; Output: [100,100]\n;; Explanation:\n;; After the first drop, the tallest stack is square 1 with a height of 100.\n;; After the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.\n;; Thus, we return an answer of [100, 100].\n;; Note that square 2 only brushes the right side of square 1, which does not count as landing on it.\n;; Constraints:\n;; 1 <= positions.length <= 1000\n;; 1 <= lefti <= 108\n;; 1 <= sideLengthi <= 106\n(define (fallingSquares positions)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_505_fallingSquares.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fallingSquares))\n    (check-within (candidate (list (list 1 2) (list 5 3) (list 3 1))) (list 2 3 3) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 2) (list 3 2))) (list 2 4 6) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 2) (list 2 1))) (list 2 4 4) 0.001)\n    (check-within (candidate (list (list 1 1))) (list 1) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 6 1))) (list 2 5 5) 0.001)\n    (check-within (candidate (list (list 1 2) (list 3 2) (list 5 2))) (list 2 2 2) 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 2) (list 1 2))) (list 2 4 4) 0.001)\n    (check-within (candidate (list (list 100 100) (list 200 100))) (list 100 100) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_514_smallestDistancePair", "language": "rkt", "prompt": "#lang racket\n;; The distance of a pair of integers a and b is defined as the absolute difference between a and b.\n;; Given an integer list nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 <= i < j < nums.length.\n;; Example 1:\n;; Input: nums = [1,3,1], k = 1\n;; Output: 0\n;; Explanation: Here are all the pairs:\n;; (1,3) -> 2\n;; (1,1) -> 0\n;; (3,1) -> 2\n;; Then the 1st smallest distance pair is (1,1), and its distance is 0.\n;; Example 2:\n;; Input: nums = [1,1,1], k = 2\n;; Output: 0\n;; Example 3:\n;; Input: nums = [1,6,1], k = 3\n;; Output: 5\n;; Constraints:\n;; n == nums.length\n;; 2 <= n <= 104\n;; 0 <= nums[i] <= 106\n;; 1 <= k <= n * (n - 1) / 2\n(define (smallestDistancePair nums k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_514_smallestDistancePair.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate smallestDistancePair))\n    (check-within (candidate (list 3 1 3 4) 1) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7) 5) 1 0.001)\n    (check-within (candidate (list 1 3 1) 1) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 4) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7) 4) 1 0.001)\n    (check-within (candidate (list 2 1 1) 1) 0 0.001)\n    (check-within (candidate (list 1 1 1 2 2 2) 3) 0 0.001)\n    (check-within (candidate (list 1) 1) 0 0.001)\n    (check-within (candidate (list 1 1 1 1 2) 4) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 6) 2 0.001)\n    (check-within (candidate (list 1 100000) 1) 99999 0.001)\n    (check-within (candidate (list 1 2) 1) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6) 5) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22) 10) 1 0.001)\n    (check-within (candidate (list 100 200 300 400 500 600) 15) 500 0.001)\n    (check-within (candidate (list 1 2 3) 2) 1 0.001)\n    (check-within (candidate (list 2 2 2 2 2) 5) 0 0.001)\n    (check-within (candidate (list 1 2 3) 1) 1 0.001)\n    (check-within (candidate (list 1000 1000 3 2) 1) 0 0.001)\n    (check-within (candidate (list 1 1 1) 2) 0 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 7) 2 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7) 3) 1 0.001)\n    (check-within (candidate (list 2 2 2 2 2) 10) 0 0.001)\n    (check-within (candidate (list 1 2 3 4) 1) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7) 6) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 1) 1 0.001)\n    (check-within (candidate (list 1 10 20 30 40 50) 1) 9 0.001)\n    (check-within (candidate (list 6 3 7 4 1 2) 4) 1 0.001)\n    (check-within (candidate (list 2 2 2 3 3 3 5 5) 12) 1 0.001)\n    (check-within (candidate (list 1 6 1) 3) 5 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 2) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 3) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 5) 2 0.001)\n    (check-within (candidate (list 100 200 300 400 500 600) 1) 100 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10) 1) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_520_countOfAtoms", "language": "rkt", "prompt": "#lang racket\n;; Given a string formula representing a chemical formula, return the count of each atom.\n;; The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\n;; One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.\n;; For example, \"H2O\" and \"H2O2\" are possible, but \"H1O2\" is impossible.\n;; Two formulas are concatenated together to produce another formula.\n;; For example, \"H2O2He3Mg4\" is also a formula.\n;; A formula placed in parentheses, and a count (optionally added) is also a formula.\n;; For example, \"(H2O2)\" and \"(H2O2)3\" are formulas.\n;; Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\n;; The test cases are generated so that all the values in the output fit in a 32-bit integer.\n;; Example 1:\n;; Input: formula = \"H2O\"\n;; Output: \"H2O\"\n;; Explanation: The count of elements are {'H': 2, 'O': 1}.\n;; Example 2:\n;; Input: formula = \"Mg(OH)2\"\n;; Output: \"H2MgO2\"\n;; Explanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.\n;; Example 3:\n;; Input: formula = \"K4(ON(SO3)2)2\"\n;; Output: \"K4N2O14S4\"\n;; Explanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.\n;; Constraints:\n;; 1 <= formula.length <= 1000\n;; formula consists of English letters, digits, '(', and ')'.\n;; formula is always valid.\n(define (countOfAtoms formula)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_520_countOfAtoms.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate countOfAtoms))\n    (check-within (candidate \"(H2O2)3\") \"H6O6\" 0.001)\n    (check-within (candidate \"(((H)2)8)4\") \"H64\" 0.001)\n    (check-within (candidate \"(((H)2)8)4N2O14S4\") \"H64N2O14S4\" 0.001)\n    (check-within (candidate \"Be32\") \"Be32\" 0.001)\n    (check-within (candidate \"(H2O2)\") \"H2O2\" 0.001)\n    (check-within (candidate \"(C6H12O6)2\") \"C12H24O12\" 0.001)\n    (check-within (candidate \"((H)8)4\") \"H32\" 0.001)\n    (check-within (candidate \"((H))4\") \"H4\" 0.001)\n    (check-within (candidate \"(Cl)3(F)7\") \"Cl3F7\" 0.001)\n    (check-within (candidate \"H2O2(H2O2)H2O2\") \"H6O6\" 0.001)\n    (check-within (candidate \"(H2O)10\") \"H20O10\" 0.001)\n    (check-within (candidate \"\") \"\" 0.001)\n    (check-within (candidate \"H50\") \"H50\" 0.001)\n    (check-within (candidate \"O0\") \"O\" 0.001)\n    (check-within (candidate \"(C12H22O11)2\") \"C24H44O22\" 0.001)\n    (check-within (candidate \"C6H12O6\") \"C6H12O6\" 0.001)\n    (check-within (candidate \"(H)2\") \"H2\" 0.001)\n    (check-within (candidate \"H2O\") \"H2O\" 0.001)\n    (check-within (candidate \"(H)2(H)2\") \"H4\" 0.001)\n    (check-within (candidate \"H2O2\") \"H2O2\" 0.001)\n    (check-within (candidate \"C12H22O11\") \"C12H22O11\" 0.001)\n    (check-within (candidate \"(H)0\") \"H\" 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_54_getPermutation", "language": "rkt", "prompt": "#lang racket\n;; The set [1, 2, 3, ...,\u00a0n] contains a total of n! unique permutations.\n;; By listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n;; \"123\"\n;; \"132\"\n;; \"213\"\n;; \"231\"\n;; \"312\"\n;; \"321\"\n;; Given n and k, return the kth permutation sequence.\n;; Example 1:\n;; Input: n = 3, k = 3\n;; Output: \"213\"\n;; Example 2:\n;; Input: n = 4, k = 9\n;; Output: \"2314\"\n;; Example 3:\n;; Input: n = 3, k = 1\n;; Output: \"123\"\n;; Constraints:\n;; 1 <= n <= 9\n;; 1 <= k <= n!\n(define (getPermutation n k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_54_getPermutation.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate getPermutation))\n    (check-within (candidate 9 2) \"123456798\" 0.001)\n    (check-within (candidate 9 3) \"123456879\" 0.001)\n    (check-within (candidate 7 1) \"1234567\" 0.001)\n    (check-within (candidate 3 1) \"123\" 0.001)\n    (check-within (candidate 2 2) \"21\" 0.001)\n    (check-within (candidate 9 1) \"123456789\" 0.001)\n    (check-within (candidate 7 5040) \"7654321\" 0.001)\n    (check-within (candidate 6 1) \"123456\" 0.001)\n    (check-within (candidate 4 9) \"2314\" 0.001)\n    (check-within (candidate 4 24) \"4321\" 0.001)\n    (check-within (candidate 8 40320) \"87654321\" 0.001)\n    (check-within (candidate 4 14) \"3142\" 0.001)\n    (check-within (candidate 5 120) \"54321\" 0.001)\n    (check-within (candidate 5 1) \"12345\" 0.001)\n    (check-within (candidate 1 1) \"1\" 0.001)\n    (check-within (candidate 2 1) \"12\" 0.001)\n    (check-within (candidate 4 20) \"4132\" 0.001)\n    (check-within (candidate 4 1) \"1234\" 0.001)\n    (check-within (candidate 5 4) \"12453\" 0.001)\n    (check-within (candidate 4 15) \"3214\" 0.001)\n    (check-within (candidate 9 362880) \"987654321\" 0.001)\n    (check-within (candidate 3 3) \"213\" 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_551_makeLargestSpecial", "language": "rkt", "prompt": "#lang racket\n;; Special binary strings are binary strings with the following two properties:\n;; The number of 0's is equal to the number of 1's.\n;; Every prefix of the binary string has at least as many 1's as 0's.\n;; You are given a special binary string s.\n;; A move consists of choosing two consecutive, non-empty, special substrings of s, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.\n;; Return the lexicographically largest resulting string possible after applying the mentioned operations on the string.\n;; Example 1:\n;; Input: s = \"11011000\"\n;; Output: \"11100100\"\n;; Explanation: The strings \"10\" [occuring at s[1]] and \"1100\" [at s[3]] are swapped.\n;; This is the lexicographically largest string possible after some number of swaps.\n;; Example 2:\n;; Input: s = \"10\"\n;; Output: \"10\"\n;; Constraints:\n;; 1 <= s.length <= 50\n;; s[i] is either '0' or '1'.\n;; s is a special binary string.\n(define (makeLargestSpecial s)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_551_makeLargestSpecial.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate makeLargestSpecial))\n    (check-within (candidate \"101010101010\") \"101010101010\" 0.001)\n    (check-within (candidate \"11110000\") \"11110000\" 0.001)\n    (check-within (candidate \"11001100\") \"11001100\" 0.001)\n    (check-within (candidate \"10\") \"10\" 0.001)\n    (check-within (candidate \"10101010\") \"10101010\" 0.001)\n    (check-within (candidate \"111000\") \"111000\" 0.001)\n    (check-within (candidate \"1010\") \"1010\" 0.001)\n    (check-within (candidate \"11011000\") \"11100100\" 0.001)\n    (check-within (candidate \"1100\") \"1100\" 0.001)\n    (check-within (candidate \"101010\") \"101010\" 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_554_minSwapsCouples", "language": "rkt", "prompt": "#lang racket\n;; There are n couples sitting in 2n seats arranged in a row and want to hold hands.\n;; The people and seats are represented by an integer list row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1).\n;; Return the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.\n;; Example 1:\n;; Input: row = [0,2,1,3]\n;; Output: 1\n;; Explanation: We only need to swap the second (row[1]) and third (row[2]) person.\n;; Example 2:\n;; Input: row = [3,2,0,1]\n;; Output: 0\n;; Explanation: All couples are already seated side by side.\n;; Constraints:\n;; 2n == row.length\n;; 2 <= n <= 30\n;; n is even.\n;; 0 <= row[i] < 2n\n;; All the elements of row are unique.\n(define (minSwapsCouples row)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_554_minSwapsCouples.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minSwapsCouples))\n    (check-within (candidate (list 0 1 2 3)) 0 0.001)\n    (check-within (candidate (list 0 2 1 3 4 5)) 1 0.001)\n    (check-within (candidate (list 0 3 2 1 6 5 4 7)) 2 0.001)\n    (check-within (candidate (list 0 2 1 3)) 1 0.001)\n    (check-within (candidate (list 0 1 2 3)) 0 0.001)\n    (check-within (candidate (list 0 3 2 1)) 1 0.001)\n    (check-within (candidate (list 0 2 1 4 3 5)) 2 0.001)\n    (check-within (candidate (list 2 0 1 3)) 1 0.001)\n    (check-within (candidate (list 5 0 2 1 4 3)) 2 0.001)\n    (check-within (candidate (list 3 2 0 1)) 0 0.001)\n    (check-within (candidate (list 0 1 2 3 4 5)) 0 0.001)\n    (check-within (candidate (list 0 2 1 3)) 1 0.001)\n    (check-within (candidate (list 0 2 1 3 4 5 6 7)) 1 0.001)\n    (check-within (candidate (list 0 2 5 3 4 1)) 2 0.001)\n    (check-within (candidate (list 3 2 0 1)) 0 0.001)\n    (check-within (candidate (list 0 2 1 3 5 4)) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_558_minSwapsCouples", "language": "rkt", "prompt": "#lang racket\n;; There are n couples sitting in 2n seats arranged in a row and want to hold hands.\n;; The people and seats are represented by an integer list row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1).\n;; Return the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.\n;; Example 1:\n;; Input: row = [0,2,1,3]\n;; Output: 1\n;; Explanation: We only need to swap the second (row[1]) and third (row[2]) person.\n;; Example 2:\n;; Input: row = [3,2,0,1]\n;; Output: 0\n;; Explanation: All couples are already seated side by side.\n;; Constraints:\n;; 2n == row.length\n;; 2 <= n <= 30\n;; n is even.\n;; 0 <= row[i] < 2n\n;; All the elements of row are unique.\n(define (minSwapsCouples row)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_558_minSwapsCouples.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minSwapsCouples))\n    (check-within (candidate (list 0 1 2 3)) 0 0.001)\n    (check-within (candidate (list 0 1 4 2 3 6 7 5 8 9)) 3 0.001)\n    (check-within (candidate (list 0 2 4 3 1 5 7 6 8 9)) 2 0.001)\n    (check-within (candidate (list 0 1 2 3 4 5 6 7 8 9)) 0 0.001)\n    (check-within (candidate (list 1 0 3 2 5 4 7 6 9 8)) 0 0.001)\n    (check-within (candidate (list 3 0 4 1 7 2 9 5 6 8)) 4 0.001)\n    (check-within (candidate (list 1 4 0 2 3 5)) 2 0.001)\n    (check-within (candidate (list 0 2 1 3 5 4 7 6 8 9)) 1 0.001)\n    (check-within (candidate (list 0 1 2 4 3 5)) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_568_slidingPuzzle", "language": "rkt", "prompt": "#lang racket\n;; On an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.\n;; The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].\n;; Given the puzzle board board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.\n;; Example 1:\n;; Input: board = [[1,2,3],[4,0,5]]\n;; Output: 1\n;; Explanation: Swap the 0 and the 5 in one move.\n;; Example 2:\n;; Input: board = [[1,2,3],[5,4,0]]\n;; Output: -1\n;; Explanation: No number of moves will make the board solved.\n;; Example 3:\n;; Input: board = [[4,1,2],[5,0,3]]\n;; Output: 5\n;; Explanation: 5 is the smallest number of moves that solves the board.\n;; An example path:\n;; After move 0: [[4,1,2],[5,0,3]]\n;; After move 1: [[4,1,2],[0,5,3]]\n;; After move 2: [[0,1,2],[4,5,3]]\n;; After move 3: [[1,0,2],[4,5,3]]\n;; After move 4: [[1,2,0],[4,5,3]]\n;; After move 5: [[1,2,3],[4,5,0]]\n;; Constraints:\n;; board.length == 2\n;; board[i].length == 3\n;; 0 <= board[i][j] <= 5\n;; Each value board[i][j] is unique.\n(define (slidingPuzzle board)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_568_slidingPuzzle.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate slidingPuzzle))\n    (check-within (candidate (list (list 3 5 4) (list 2 1 0))) 12 0.001)\n    (check-within (candidate (list (list 5 4 0) (list 1 2 3))) -1 0.001)\n    (check-within (candidate (list (list 4 1 2) (list 5 0 3))) 5 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 5 4 0))) -1 0.001)\n    (check-within (candidate (list (list 3 2 1) (list 4 0 5))) -1 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 0 5))) 1 0.001)\n    (check-within (candidate (list (list 3 2 4) (list 1 5 0))) 14 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 5 0))) 0 0.001)\n    (check-within (candidate (list (list 3 2 4) (list 1 5 0))) 14 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 5 0))) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_58_is_number", "language": "rkt", "prompt": "#lang racket\n;; A valid number can be split up into these components (in order):\n;; A decimal number or an integer.\n;; (Optional) An 'e' or 'E', followed by an integer.\n;; A decimal number can be split up into these components (in order):\n;; (Optional) A sign character (either '+' or '-').\n;; One of the following formats:\n;; One or more digits, followed by a dot '.'.\n;; One or more digits, followed by a dot '.', followed by one or more digits.\n;; A dot '.', followed by one or more digits.\n;; An integer can be split up into these components (in order):\n;; (Optional) A sign character (either '+' or '-').\n;; One or more digits.\n;; For example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\n;; Given a string s, return true if s is a valid number.\n;; Example 1:\n;; Input: s = \"0\"\n;; Output: true\n;; Example 2:\n;; Input: s = \"e\"\n;; Output: false\n;; Example 3:\n;; Input: s = \".\"\n;; Output: false\n;; Constraints:\n;; 1 <= s.length <= 20\n;; s consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'.\n(define (is_number s)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_58_is_number.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_number))\n    (check-within (candidate \"3e+\") #f 0.001)\n    (check-within (candidate \"-1.2e-5.\") #f 0.001)\n    (check-within (candidate \"6e-1.\") #f 0.001)\n    (check-within (candidate \".\") #f 0.001)\n    (check-within (candidate \"-.8e-1\") #t 0.001)\n    (check-within (candidate \".1e2\") #t 0.001)\n    (check-within (candidate \"0e\") #f 0.001)\n    (check-within (candidate \"0.123e7\") #t 0.001)\n    (check-within (candidate \"3e+7\") #t 0.001)\n    (check-within (candidate \"123.e-2\") #t 0.001)\n    (check-within (candidate \"2\") #t 0.001)\n    (check-within (candidate \"+.8\") #t 0.001)\n    (check-within (candidate \"+3.14\") #t 0.001)\n    (check-within (candidate \"1.2e5.\") #f 0.001)\n    (check-within (candidate \".1e\") #f 0.001)\n    (check-within (candidate \"-4.3e-10\") #t 0.001)\n    (check-within (candidate \"--6\") #f 0.001)\n    (check-within (candidate \"+\") #f 0.001)\n    (check-within (candidate \"2e10\") #t 0.001)\n    (check-within (candidate \"99e2.5\") #f 0.001)\n    (check-within (candidate \"3.e2\") #t 0.001)\n    (check-within (candidate \"+12E\") #f 0.001)\n    (check-within (candidate \"+.123\") #t 0.001)\n    (check-within (candidate \"123.456e789\") #t 0.001)\n    (check-within (candidate \"12.3\") #t 0.001)\n    (check-within (candidate \"0\") #t 0.001)\n    (check-within (candidate \"+6e-1\") #t 0.001)\n    (check-within (candidate \"12e5\") #t 0.001)\n    (check-within (candidate \"-.\") #f 0.001)\n    (check-within (candidate \"3e-\") #f 0.001)\n    (check-within (candidate \"-.9\") #t 0.001)\n    (check-within (candidate \"3e+7.\") #f 0.001)\n    (check-within (candidate \"-.123e-4\") #t 0.001)\n    (check-within (candidate \"-\") #f 0.001)\n    (check-within (candidate \"+12e-\") #f 0.001)\n    (check-within (candidate \"e3\") #f 0.001)\n    (check-within (candidate \"-1.2e-5\") #t 0.001)\n    (check-within (candidate \"1.2e+5\") #t 0.001)\n    (check-within (candidate \"e2\") #f 0.001)\n    (check-within (candidate \"46.00\") #t 0.001)\n    (check-within (candidate \"1a\") #f 0.001)\n    (check-within (candidate \".e1\") #f 0.001)\n    (check-within (candidate \"+1.23e4\") #t 0.001)\n    (check-within (candidate \"e-1\") #f 0.001)\n    (check-within (candidate \"12e5.\") #f 0.001)\n    (check-within (candidate \"-0.1\") #t 0.001)\n    (check-within (candidate \"+1.2E-5.\") #f 0.001)\n    (check-within (candidate \"46.e3\") #t 0.001)\n    (check-within (candidate \"+E3\") #f 0.001)\n    (check-within (candidate \"+.123e+4\") #t 0.001)\n    (check-within (candidate \"1.2e-5\") #t 0.001)\n    (check-within (candidate \"-123.456e789\") #t 0.001)\n    (check-within (candidate \"3.\") #t 0.001)\n    (check-within (candidate \"1.23\") #t 0.001)\n    (check-within (candidate \"-1.2E5.\") #f 0.001)\n    (check-within (candidate \"-0.1e-2\") #t 0.001)\n    (check-within (candidate \"+-3\") #f 0.001)\n    (check-within (candidate \"+22.\") #t 0.001)\n    (check-within (candidate \"-.9e-1\") #t 0.001)\n    (check-within (candidate \"3e-7\") #t 0.001)\n    (check-within (candidate \"-.123\") #t 0.001)\n    (check-within (candidate \"-e\") #f 0.001)\n    (check-within (candidate \"abc\") #f 0.001)\n    (check-within (candidate \"-.1e2\") #t 0.001)\n    (check-within (candidate \"3e7\") #t 0.001)\n    (check-within (candidate \"-e3\") #f 0.001)\n    (check-within (candidate \"7.e-1\") #t 0.001)\n    (check-within (candidate \"+1.23\") #t 0.001)\n    (check-within (candidate \"0e-2\") #t 0.001)\n    (check-within (candidate \"+1.2e-5.\") #f 0.001)\n    (check-within (candidate \"-1.23e4\") #t 0.001)\n    (check-within (candidate \"123.E-2.5\") #f 0.001)\n    (check-within (candidate \"0089\") #t 0.001)\n    (check-within (candidate \"4.\") #t 0.001)\n    (check-within (candidate \"1e\") #f 0.001)\n    (check-within (candidate \"-+3\") #f 0.001)\n    (check-within (candidate \".1\") #t 0.001)\n    (check-within (candidate \"e+789\") #f 0.001)\n    (check-within (candidate \" \") #f 0.001)\n    (check-within (candidate \"-6.e+8\") #t 0.001)\n    (check-within (candidate \"12e-3.5\") #f 0.001)\n    (check-within (candidate \"1e-1.3\") #f 0.001)\n    (check-within (candidate \"+1.2e-5\") #t 0.001)\n    (check-within (candidate \".00e+2\") #t 0.001)\n    (check-within (candidate \"3e-6\") #t 0.001)\n    (check-within (candidate \"e\") #f 0.001)\n    (check-within (candidate \"123.e-2.5\") #f 0.001)\n    (check-within (candidate \"1e2.458\") #f 0.001)\n    (check-within (candidate \"-e10\") #f 0.001)\n    (check-within (candidate \"4\") #t 0.001)\n    (check-within (candidate \"-1.2e5\") #t 0.001)\n    (check-within (candidate \"95a54e53\") #f 0.001)\n    (check-within (candidate \"53.5e93\") #t 0.001)\n    (check-within (candidate \"123.\") #t 0.001)\n    (check-within (candidate \"-12E\") #f 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_593_best_rotation", "language": "rkt", "prompt": "#lang racket\n;; You are given a list nums. You can rotate it by a non-negative integer k so that the list becomes [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]. Afterward, any entries that are less than or equal to their index are worth one point.\n;; For example, if we have nums = [2,4,1,3,0], and we rotate by k = 2, it becomes [1,3,0,2,4]. This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point].\n;; Return the rotation index k that corresponds to the highest score we can achieve if we rotated nums by it. If there are multiple answers, return the smallest such index k.\n;; Example 1:\n;; Input: nums = [2,3,1,4,0]\n;; Output: 3\n;; Explanation: Scores for each k are listed below: \n;; k = 0,  nums = [2,3,1,4,0],    score 2\n;; k = 1,  nums = [3,1,4,0,2],    score 3\n;; k = 2,  nums = [1,4,0,2,3],    score 3\n;; k = 3,  nums = [4,0,2,3,1],    score 4\n;; k = 4,  nums = [0,2,3,1,4],    score 3\n;; So we should choose k = 3, which has the highest score.\n;; Example 2:\n;; Input: nums = [1,3,0,2,4]\n;; Output: 0\n;; Explanation: nums will always have 3 points no matter how it shifts.\n;; So we will choose the smallest k, which is 0.\n;; Constraints:\n;; 1 <= nums.length <= 105\n;; 0 <= nums[i] < nums.length\n(define (best_rotation nums)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_593_best_rotation.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate best_rotation))\n    (check-within (candidate (list 1)) 0 0.001)\n    (check-within (candidate (list 3 4 5 1 2)) 3 0.001)\n    (check-within (candidate (list 5 3 4 2 1)) 2 0.001)\n    (check-within (candidate (list 10 10 10 10 10 10 10 10 10 10)) 0 0.001)\n    (check-within (candidate (list 10 9 8 7 6 5 4 3 2 1)) 1 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1)) 0 0.001)\n    (check-within (candidate (list 1 3 0 2 4)) 0 0.001)\n    (check-within (candidate (list 4 2 3 5 1)) 1 0.001)\n    (check-within (candidate (list 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_609_numBusesToDestination", "language": "rkt", "prompt": "#lang racket\n;; You are given a list routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.\n;; For example, if routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever.\n;; You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.\n;; Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible.\n;; Example 1:\n;; Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6\n;; Output: 2\n;; Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.\n;; Example 2:\n;; Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\n;; Output: -1\n;; Constraints:\n;; 1 <= routes.length <= 500.\n;; 1 <= routes[i].length <= 105\n;; All the values of routes[i] are unique.\n;; sum(routes[i].length) <= 105\n;; 0 <= routes[i][j] < 106\n;; 0 <= source, target < 106\n(define (numBusesToDestination routes source target)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_609_numBusesToDestination.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate numBusesToDestination))\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 6) (list 6 7)) 1 7) 5 0.001)\n    (check-within (candidate (list (list 1 2) (list 3 4) (list 5 6) (list 7 8)) 1 8) -1 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 7)) 1 4) 3 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5)) 1 5) 4 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6)) 1 6) 5 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6)) 1 8) -1 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 6 7) (list 9 10) (list 9 11) (list 10 12)) 1 12) -1 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 7)) 1 2) 1 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 5 6) (list 6 7) (list 8 9)) 1 8) -1 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 7)) 1 7) 6 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5)) 1 5) 1 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 6 7)) 1 7) -1 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 7)) 2 5) 3 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 3 6 7) (list 5 7 8)) 1 1) 0 0.001)\n    (check-within (candidate (list (list 1 2) (list 1 3) (list 1 4) (list 1 5) (list 1 6)) 1 6) 1 0.001)\n    (check-within (candidate (list (list 1 2 7) (list 3 6 7) (list 5 7 8)) 1 8) 2 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_625_rectangleArea", "language": "rkt", "prompt": "#lang racket\n;; You are given a 2D list of axis-aligned rectangles. Each rectangle[i] = [xi1, yi1, xi2, yi2] denotes the ith rectangle where (xi1, yi1) are the coordinates of the bottom-left corner, and (xi2, yi2) are the coordinates of the top-right corner.\n;; Calculate the total area covered by all rectangles in the plane. Any area covered by two or more rectangles should only be counted once.\n;; Return the total area. Since the answer may be too large, return it modulo 109 + 7.\n;; Example 1:\n;; Input: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\n;; Output: 6\n;; Explanation: A total area of 6 is covered by all three rectangles, as illustrated in the picture.\n;; From (1,1) to (2,2), the green and red rectangles overlap.\n;; From (1,0) to (2,3), all three rectangles overlap.\n;; Example 2:\n;; Input: rectangles = [[0,0,1000000000,1000000000]]\n;; Output: 49\n;; Explanation: The answer is 1018 modulo (109 + 7), which is 49.\n;; Constraints:\n;; 1 <= rectangles.length <= 200\n;; rectanges[i].length == 4\n;; 0 <= xi1, yi1, xi2, yi2 <= 109\n;; xi1 <= xi2\n;; yi1 <= yi2\n(define (rectangleArea rectangles)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_625_rectangleArea.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rectangleArea))\n    (check-within (candidate (list (list 0 0 1 1) (list 1 1 2 2))) 2 0.001)\n    (check-within (candidate (list (list 0 0 2 2) (list 0 2 2 4) (list 2 0 4 2) (list 2 2 4 4))) 16 0.001)\n    (check-within (candidate (list (list 0 0 1 1) (list 0 0 1 1))) 1 0.001)\n    (check-within (candidate (list (list 0 0 1000000000 1000000000))) 49 0.001)\n    (check-within (candidate (list (list 0 0 1 1) (list 0 1 1 2) (list 1 0 2 1) (list 1 1 2 2))) 4 0.001)\n    (check-within (candidate (list (list 0 0 5 5) (list 1 1 4 4))) 25 0.001)\n    (check-within (candidate (list (list 0 0 0 0) (list 0 0 0 0))) 0 0.001)\n    (check-within (candidate (list (list 0 0 1 1) (list 1 0 2 1) (list 0 1 1 2) (list 1 1 2 2))) 4 0.001)\n    (check-within (candidate (list (list 0 0 10 10) (list 0 10 10 20) (list 0 20 10 30))) 300 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 1 1 3 3) (list 1 1 3 3))) 4 0.001)\n    (check-within (candidate (list (list 1 1 3 3))) 4 0.001)\n    (check-within (candidate (list (list 0 0 1 1) (list 1 0 2 1) (list 2 0 3 1) (list 3 0 4 1))) 4 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 1 1 4 4) (list 0 0 2 2) (list 2 2 4 4))) 12 0.001)\n    (check-within (candidate (list (list 0 0 1 1) (list 1 0 2 2) (list 1 1 3 3) (list 0 1 2 3))) 8 0.001)\n    (check-within (candidate (list (list 1 1 3 3) (list 1 1 3 3))) 4 0.001)\n    (check-within (candidate (list (list 0 0 10 10) (list 10 0 20 10) (list 20 0 30 10))) 300 0.001)\n    (check-within (candidate (list (list 0 0 2 2) (list 1 1 3 3))) 7 0.001)\n    (check-within (candidate (list (list 0 0 2 2) (list 1 0 2 3) (list 1 0 3 1))) 6 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_629_kSimilarity", "language": "rkt", "prompt": "#lang racket\n;; Strings s1 and s2 are k-similar (for some non-negative integer k) if we can swap the positions of two letters in s1 exactly k times so that the resulting string equals s2.\n;; Given two anagrams s1 and s2, return the smallest k for which s1 and s2 are k-similar.\n;; Example 1:\n;; Input: s1 = \"ab\", s2 = \"ba\"\n;; Output: 1\n;; Explanation: The two string are 1-similar because we can use one swap to change s1 to s2: \"ab\" --> \"ba\".\n;; Example 2:\n;; Input: s1 = \"abc\", s2 = \"bca\"\n;; Output: 2\n;; Explanation: The two strings are 2-similar because we can use two swaps to change s1 to s2: \"abc\" --> \"bac\" --> \"bca\".\n;; Constraints:\n;; 1 <= s1.length <= 20\n;; s2.length == s1.length\n;; s1 and s2 contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}.\n;; s2 is an anagram of s1.\n(define (kSimilarity s1 s2)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_629_kSimilarity.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate kSimilarity))\n    (check-within (candidate \"abcabcabc\" \"abcabcacb\") 1 0.001)\n    (check-within (candidate \"abcde\" \"edcba\") 2 0.001)\n    (check-within (candidate \"aabbccdd\" \"ddccbbaa\") 4 0.001)\n    (check-within (candidate \"abcabcabc\" \"abcabccab\") 2 0.001)\n    (check-within (candidate \"abcabcabc\" \"abcabccba\") 1 0.001)\n    (check-within (candidate \"abcdef\" \"fedcba\") 3 0.001)\n    (check-within (candidate \"ab\" \"ba\") 1 0.001)\n    (check-within (candidate \"abcde\" \"abced\") 1 0.001)\n    (check-within (candidate \"abcabcabc\" \"abccbaacb\") 2 0.001)\n    (check-within (candidate \"abcd\" \"dcba\") 2 0.001)\n    (check-within (candidate \"abcabcabc\" \"cbaabcabc\") 1 0.001)\n    (check-within (candidate \"abcdefabcdef\" \"fedcbafedcba\") 6 0.001)\n    (check-within (candidate \"abc\" \"acb\") 1 0.001)\n    (check-within (candidate \"abc\" \"bca\") 2 0.001)\n    (check-within (candidate \"empty\" \"empty\") 0 0.001)\n    (check-within (candidate \"abcde\" \"abcde\") 0 0.001)\n    (check-within (candidate \"abcabcabc\" \"abcabcabc\") 0 0.001)\n    (check-within (candidate \"abcdef\" \"abcdef\") 0 0.001)\n    (check-within (candidate \"abc\" \"cab\") 2 0.001)\n    (check-within (candidate \"qwertyuioplkjhgfdsazxcvbnmqwerty\" \"qwertyuioplkjhgfdsazxcvbnmqwerty\") 0 0.001)\n    (check-within (candidate \"vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\" \"vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\") 0 0.001)\n    (check-within (candidate \"abcdef\" \"acbdef\") 1 0.001)\n    (check-within (candidate \"abcabcabc\" \"abccbaabc\") 1 0.001)\n    (check-within (candidate \"a\" \"a\") 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_631_consecutive_numbers_sum", "language": "rkt", "prompt": "#lang racket\n;; Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.\n;; Example 1:\n;; Input: n = 5\n;; Output: 2\n;; Explanation: 5 = 2 + 3\n;; Example 2:\n;; Input: n = 9\n;; Output: 3\n;; Explanation: 9 = 4 + 5 = 2 + 3 + 4\n;; Example 3:\n;; Input: n = 15\n;; Output: 4\n;; Explanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\n;; Constraints:\n;; 1 <= n <= 109\n(define (consecutive_numbers_sum n)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_631_consecutive_numbers_sum.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate consecutive_numbers_sum))\n    (check-within (candidate 674) 2 0.001)\n    (check-within (candidate 1) 1 0.001)\n    (check-within (candidate 21) 4 0.001)\n    (check-within (candidate 33) 4 0.001)\n    (check-within (candidate 54) 4 0.001)\n    (check-within (candidate 12) 2 0.001)\n    (check-within (candidate 100) 3 0.001)\n    (check-within (candidate 998) 2 0.001)\n    (check-within (candidate 22) 2 0.001)\n    (check-within (candidate 41) 2 0.001)\n    (check-within (candidate 17) 2 0.001)\n    (check-within (candidate 30) 4 0.001)\n    (check-within (candidate 2) 1 0.001)\n    (check-within (candidate 15) 4 0.001)\n    (check-within (candidate 62) 2 0.001)\n    (check-within (candidate 26) 2 0.001)\n    (check-within (candidate 37) 2 0.001)\n    (check-within (candidate 43) 2 0.001)\n    (check-within (candidate 427) 4 0.001)\n    (check-within (candidate 25) 3 0.001)\n    (check-within (candidate 16) 1 0.001)\n    (check-within (candidate 31) 2 0.001)\n    (check-within (candidate 7) 2 0.001)\n    (check-within (candidate 102) 4 0.001)\n    (check-within (candidate 11) 2 0.001)\n    (check-within (candidate 19) 2 0.001)\n    (check-within (candidate 23) 2 0.001)\n    (check-within (candidate 42) 4 0.001)\n    (check-within (candidate 3) 2 0.001)\n    (check-within (candidate 40) 2 0.001)\n    (check-within (candidate 133) 4 0.001)\n    (check-within (candidate 35) 4 0.001)\n    (check-within (candidate 49) 3 0.001)\n    (check-within (candidate 9) 3 0.001)\n    (check-within (candidate 132) 4 0.001)\n    (check-within (candidate 32) 1 0.001)\n    (check-within (candidate 20) 2 0.001)\n    (check-within (candidate 103) 2 0.001)\n    (check-within (candidate 18) 3 0.001)\n    (check-within (candidate 10) 2 0.001)\n    (check-within (candidate 5) 2 0.001)\n    (check-within (candidate 6) 2 0.001)\n    (check-within (candidate 74) 2 0.001)\n    (check-within (candidate 34) 2 0.001)\n    (check-within (candidate 88) 2 0.001)\n    (check-within (candidate 53) 2 0.001)\n    (check-within (candidate 13) 2 0.001)\n    (check-within (candidate 8) 1 0.001)\n    (check-within (candidate 14) 2 0.001)\n    (check-within (candidate 36) 3 0.001)\n    (check-within (candidate 388) 2 0.001)\n    (check-within (candidate 64) 1 0.001)\n    (check-within (candidate 38) 2 0.001)\n    (check-within (candidate 29) 2 0.001)\n    (check-within (candidate 28) 2 0.001)\n    (check-within (candidate 52) 2 0.001)\n    (check-within (candidate 4) 1 0.001)\n    (check-within (candidate 45) 6 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_636_sumOfDistancesInTree", "language": "rkt", "prompt": "#lang racket\n;; There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.\n;; You are given the integer n and the list edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\n;; Return a list answer of length n where answer[i] is the sum of the distances between the ith node in the tree and all other nodes.\n;; Example 1:\n;; Input: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\n;; Output: [8,12,6,10,10,10]\n;; Explanation: The tree is shown above.\n;; We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\n;; equals 1 + 1 + 2 + 2 + 2 = 8.\n;; Hence, answer[0] = 8, and so on.\n;; Example 2:\n;; Input: n = 1, edges = []\n;; Output: [0]\n;; Example 3:\n;; Input: n = 2, edges = [[1,0]]\n;; Output: [1,1]\n;; Constraints:\n;; 1 <= n <= 3 * 104\n;; edges.length == n - 1\n;; edges[i].length == 2\n;; 0 <= ai, bi < n\n;; ai != bi\n;; The given input represents a valid tree.\n(define (sumOfDistancesInTree n edges)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_636_sumOfDistancesInTree.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sumOfDistancesInTree))\n    (check-within (candidate 3 (list (list 0 1) (list 0 2))) (list 2 3 3) 0.001)\n    (check-within (candidate 1 (list )) (list 0) 0.001)\n    (check-within (candidate 2 (list (list 1 0))) (list 1 1) 0.001)\n    (check-within (candidate 6 (list (list 0 1) (list 0 2) (list 2 3) (list 2 4) (list 2 5))) (list 8 12 6 10 10 10) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_656_k_similarity", "language": "rkt", "prompt": "#lang racket\n;; Strings s1 and s2 are k-similar (for some non-negative integer k) if we can swap the positions of two letters in s1 exactly k times so that the resulting string equals s2.\n;; Given two anagrams s1 and s2, return the smallest k for which s1 and s2 are k-similar.\n;; Example 1:\n;; Input: s1 = \"ab\", s2 = \"ba\"\n;; Output: 1\n;; Explanation: The two string are 1-similar because we can use one swap to change s1 to s2: \"ab\" --> \"ba\".\n;; Example 2:\n;; Input: s1 = \"abc\", s2 = \"bca\"\n;; Output: 2\n;; Explanation: The two strings are 2-similar because we can use two swaps to change s1 to s2: \"abc\" --> \"bac\" --> \"bca\".\n;; Constraints:\n;; 1 <= s1.length <= 20\n;; s2.length == s1.length\n;; s1 and s2 contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}.\n;; s2 is an anagram of s1.\n(define (k_similarity s1 s2)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_656_k_similarity.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate k_similarity))\n    (check-within (candidate \"This is a test\" \"This is a test\") 0 0.001)\n    (check-within (candidate \"abcdef\" \"badefc\") 2 0.001)\n    (check-within (candidate \"abcdefghijklm\" \"abcdefghijklm\") 0 0.001)\n    (check-within (candidate \"word order matters\" \"word order matters\") 0 0.001)\n    (check-within (candidate \"identical\" \"identical\") 0 0.001)\n    (check-within (candidate \"only words\" \"only words\") 0 0.001)\n    (check-within (candidate \"abab\" \"baba\") 2 0.001)\n    (check-within (candidate \"same\" \"same\") 0 0.001)\n    (check-within (candidate \"This is a test\" \"This is a test\") 0 0.001)\n    (check-within (candidate \"12345\" \"12345\") 0 0.001)\n    (check-within (candidate \"f1.0\" \"f1.0\") 0 0.001)\n    (check-within (candidate \"abcde\" \"bacde\") 1 0.001)\n    (check-within (candidate \"same length\" \"same length\") 0 0.001)\n    (check-within (candidate \"only words\" \"no numbers\") 2 0.001)\n    (check-within (candidate \"This is not a common phrase.\" \"This is not a common phrase.\") 0 0.001)\n    (check-within (candidate \"ab\" \"ba\") 1 0.001)\n    (check-within (candidate \"single word\" \"single word\") 0 0.001)\n    (check-within (candidate \"abcdef\" \"abcdef\") 0 0.001)\n    (check-within (candidate \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijlmnopqrstuvwxyz\" \"1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijlmnopqrstuvwxyz\") 0 0.001)\n    (check-within (candidate \"abcd\" \"abcd\") 0 0.001)\n    (check-within (candidate \"same chars repeated\" \"same chars repeated\") 0 0.001)\n    (check-within (candidate \"big word\" \"big word\") 0 0.001)\n    (check-within (candidate \"a2b3c4d5\" \"a2b3c4d5\") 0 0.001)\n    (check-within (candidate \"one word\" \"one word\") 0 0.001)\n    (check-within (candidate \"1ab234cd\" \"1ab234dc\") 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_658_mincost_to_hire_workers", "language": "rkt", "prompt": "#lang racket\n;; There are n workers. You are given two integer lists quality and wage where quality[i] is the quality of the ith worker and wage[i] is the minimum wage expectation for the ith worker.\n;; We want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules:\n;; Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n;; Every worker in the paid group must be paid at least their minimum wage expectation.\n;; Given the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10-5 of the actual answer will be accepted.\n;; Example 1:\n;; Input: quality = [10,20,5], wage = [70,50,30], k = 2\n;; Output: 105.00000\n;; Explanation: We pay 70 to 0th worker and 35 to 2nd worker.\n;; Example 2:\n;; Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\n;; Output: 30.66667\n;; Explanation: We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately.\n;; Constraints:\n;; n == quality.length == wage.length\n;; 1 <= k <= n <= 104\n;; 1 <= quality[i], wage[i] <= 104\n(define (mincost_to_hire_workers quality wage k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_658_mincost_to_hire_workers.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate mincost_to_hire_workers))\n    (check-within (candidate (list 4) (list 8) 1) 8.0 0.001)\n    (check-within (candidate (list 3 1 10 10 1) (list 4 8 2 2 7) 3) 30.666666666666664 0.001)\n    (check-within (candidate (list 100000000000000000000 100000000000000000000 100000000000000000000) (list 100000000000000000000 100000000000000000000 100000000000000000000) 1) 100000000000000000000 0.001)\n    (check-within (candidate (list 10 20 5) (list 70 50 30) 2) 105.0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_663_shortest_subarray", "language": "rkt", "prompt": "#lang racket\n;; Given an integer list nums and an integer k, return the length of the shortest non-empty sublist of nums with a sum of at least k. If there is no such sublist, return -1.\n;; A sublist is a contiguous part of a list.\n;; Example 1:\n;; Input: nums = [1], k = 1\n;; Output: 1\n;; Example 2:\n;; Input: nums = [1,2], k = 4\n;; Output: -1\n;; Example 3:\n;; Input: nums = [2,-1,2], k = 3\n;; Output: 3\n;; Constraints:\n;; 1 <= nums.length <= 105\n;; -105 <= nums[i] <= 105\n;; 1 <= k <= 109\n(define (shortest_subarray nums k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_663_shortest_subarray.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate shortest_subarray))\n    (check-within (candidate (list 1) 5) -1 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 50) -1 0.001)\n    (check-within (candidate (list 1 2 3 4) 32) -1 0.001)\n    (check-within (candidate (list 10 9 8 7 6 5 4 3 2 1) 15) 2 0.001)\n    (check-within (candidate (list 1 2 3 4) 29) -1 0.001)\n    (check-within (candidate (list 2 -1 2) 3) 3 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 11) 3 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1) 10) 10 0.001)\n    (check-within (candidate (list 2 4 6 8 10 12 14 16 18 20) 36) 2 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 5) 1 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1) 50) 50 0.001)\n    (check-within (candidate (list 3 6 9 12 15 18 21 24 27 30) 60) 3 0.001)\n    (check-within (candidate (list 1 2 3 4) 31) -1 0.001)\n    (check-within (candidate (list 1 2 3 4) 33) -1 0.001)\n    (check-within (candidate (list 1 2 3 4 5) 15) 5 0.001)\n    (check-within (candidate (list 1 2 3 4) 30) -1 0.001)\n    (check-within (candidate (list 1 1000000000) 1000000000) 1 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1) 50) 50 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20) 41) 3 0.001)\n    (check-within (candidate (list 2 3 1 2 4 3) 7) 2 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_664_shortestPathAllKeys", "language": "rkt", "prompt": "#lang racket\n;; You are given an m x n grid grid where:\n;; '.' is an empty cell.\n;; '#' is a wall.\n;; '@' is the starting point.\n;; Lowercase letters represent keys.\n;; Uppercase letters represent locks.\n;; You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\n;; If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n;; For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n;; Return the lowest number of moves to acquire all keys. If it is impossible, return -1.\n;; Example 1:\n;; Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\n;; Output: 8\n;; Explanation: Note that the goal is to obtain all the keys not to open all the locks.\n;; Example 2:\n;; Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\n;; Output: 6\n;; Example 3:\n;; Input: grid = [\"@Aa\"]\n;; Output: -1\n;; Constraints:\n;; m == grid.length\n;; n == grid[i].length\n;; 1 <= m, n <= 30\n;; grid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\n;; There is exactly one\u00a0'@'\u00a0in the grid.\n;; The number of keys in the grid is in the range [1, 6].\n;; Each key in the grid is unique.\n;; Each key in the grid has a matching lock.\n(define (shortestPathAllKeys grid)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_664_shortestPathAllKeys.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate shortestPathAllKeys))\n    (check-within (candidate (list \"@...a\" \".###A\" \"b.BCc\")) 10 0.001)\n    (check-within (candidate (list \"@.a.#\" \"###.#\" \"b..Bb\")) 6 0.001)\n    (check-within (candidate (list \"@..aA\" \"..B#.\" \"....b\")) 6 0.001)\n    (check-within (candidate (list \"@Aa\")) -1 0.001)\n    (check-within (candidate (list \"@...a\" \".###A\" \"b.BCc\" \".###.\" \".....\")) 10 0.001)\n    (check-within (candidate (list \"@..aA\" \".##.#A\" \"b.BCc\")) 10 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_676_nthMagicalNumber", "language": "rkt", "prompt": "#lang racket\n;; A positive integer is magical if it is divisible by either a or b.\n;; Given the three integers n, a, and b, return the nth magical number. Since the answer may be very large, return it modulo 109 + 7.\n;; Example 1:\n;; Input: n = 1, a = 2, b = 3\n;; Output: 2\n;; Example 2:\n;; Input: n = 4, a = 2, b = 3\n;; Output: 6\n;; Constraints:\n;; 1 <= n <= 109\n;; 2 <= a, b <= 4 * 104\n(define (nthMagicalNumber n a b)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_676_nthMagicalNumber.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate nthMagicalNumber))\n    (check-within (candidate 1 1 2) 1 0.001)\n    (check-within (candidate 15 15 15) 225 0.001)\n    (check-within (candidate 8 4 2) 16 0.001)\n    (check-within (candidate 1 1 8) 1 0.001)\n    (check-within (candidate 9 3 3) 27 0.001)\n    (check-within (candidate 7 7 7) 49 0.001)\n    (check-within (candidate 1 2 3) 2 0.001)\n    (check-within (candidate 11 11 11) 121 0.001)\n    (check-within (candidate 1 1 4) 1 0.001)\n    (check-within (candidate 8 8 8) 64 0.001)\n    (check-within (candidate 10 10000 10000) 100000 0.001)\n    (check-within (candidate 10 1 1) 10 0.001)\n    (check-within (candidate 1 1 9) 1 0.001)\n    (check-within (candidate 1 1 7) 1 0.001)\n    (check-within (candidate 1 3 2) 2 0.001)\n    (check-within (candidate 1 100 10000) 100 0.001)\n    (check-within (candidate 1 1 10000) 1 0.001)\n    (check-within (candidate 1 1 5) 1 0.001)\n    (check-within (candidate 4 4 4) 16 0.001)\n    (check-within (candidate 4 2 3) 6 0.001)\n    (check-within (candidate 2 2 1) 2 0.001)\n    (check-within (candidate 6 2 4) 12 0.001)\n    (check-within (candidate 1 10000 10000) 10000 0.001)\n    (check-within (candidate 2 2 2) 4 0.001)\n    (check-within (candidate 10 4 2) 20 0.001)\n    (check-within (candidate 5 5 5) 25 0.001)\n    (check-within (candidate 12 12 12) 144 0.001)\n    (check-within (candidate 6 6 6) 36 0.001)\n    (check-within (candidate 10000 10000 10000) 100000000 0.001)\n    (check-within (candidate 14 14 14) 196 0.001)\n    (check-within (candidate 10 10 10) 100 0.001)\n    (check-within (candidate 9 9 9) 81 0.001)\n    (check-within (candidate 1 1 1) 1 0.001)\n    (check-within (candidate 100000 10000 10000) 1000000000 0.001)\n    (check-within (candidate 1000 2 1) 1000 0.001)\n    (check-within (candidate 3 3 3) 9 0.001)\n    (check-within (candidate 1 2 1) 1 0.001)\n    (check-within (candidate 13 13 13) 169 0.001)\n    (check-within (candidate 10 2 2) 20 0.001)\n    (check-within (candidate 1 3 4) 3 0.001)\n    (check-within (candidate 1 1 6) 1 0.001)\n    (check-within (candidate 1 1 3) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_677_profitableSchemes", "language": "rkt", "prompt": "#lang racket\n;; There is a group of n members, and a list of various crimes they could commit. The ith crime generates a profit[i] and requires group[i] members to participate in it. If a member participates in one crime, that member can't participate in another crime.\n;; Let's call a profitable scheme any subset of these crimes that generates at least minProfit profit, and the total number of members participating in that subset of crimes is at most n.\n;; Return the number of schemes that can be chosen. Since the answer may be very large, return it modulo 109 + 7.\n;; Example 1:\n;; Input: n = 5, minProfit = 3, group = [2,2], profit = [2,3]\n;; Output: 2\n;; Explanation: To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1.\n;; In total, there are 2 schemes.\n;; Example 2:\n;; Input: n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]\n;; Output: 7\n;; Explanation: To make a profit of at least 5, the group could commit any crimes, as long as they commit one.\n;; There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).\n;; Constraints:\n;; 1 <= n <= 100\n;; 0 <= minProfit <= 100\n;; 1 <= group.length <= 100\n;; 1 <= group[i] <= 100\n;; profit.length == group.length\n;; 0 <= profit[i] <= 100\n(define (profitableSchemes n minProfit group profit)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_677_profitableSchemes.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate profitableSchemes))\n    (check-within (candidate 10 5 (list 100 100 100) (list 1 1 1)) 0 0.001)\n    (check-within (candidate 3 0 (list 1 1) (list 1 1)) 3 0.001)\n    (check-within (candidate 10 5 (list 2 3 5) (list 6 7 8)) 7 0.001)\n    (check-within (candidate 5 3 (list 2 2) (list 2 3)) 2 0.001)\n    (check-within (candidate 1 1 (list 1 1) (list 1 1)) 2 0.001)\n    (check-within (candidate 5 10 (list 3 5) (list 6 7)) 0 0.001)\n    (check-within (candidate 10 50 (list 11 11 11 11 11 11 11 11 11 11) (list 1 2 3 4 5 6 7 8 9 10)) 0 0.001)\n    (check-within (candidate 10 50 (list 11 11 11 11 11 11 11 11 11 11) (list 1 1 1 1 1 1 1 1 1 1)) 0 0.001)\n    (check-within (candidate 10 50 (list 35 10 15 30 25 20 20 5 10 25) (list 1 2 3 4 5 6 7 8 9 10)) 0 0.001)\n    (check-within (candidate 10 50 (list 11 20 100 40 222 222 444 333 55 111) (list 23 21 150 40 222 222 444 333 55 111)) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_698_superpalindromesInRange", "language": "rkt", "prompt": "#lang racket\n;; Let's say a positive integer is a super-palindrome if it is a palindrome, and it is also the square of a palindrome.\n;; Given two positive integers left and right represented as strings, return the number of super-palindromes integers in the inclusive range [left, right].\n;; Example 1:\n;; Input: left = \"4\", right = \"1000\"\n;; Output: 4\n;; Explanation: 4, 9, 121, and 484 are superpalindromes.\n;; Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.\n;; Example 2:\n;; Input: left = \"1\", right = \"2\"\n;; Output: 1\n;; Constraints:\n;; 1 <= left.length, right.length <= 18\n;; left and right consist of only digits.\n;; left and right cannot have leading zeros.\n;; left and right represent integers in the range [1, 1018 - 1].\n;; left is less than or equal to right.\n(define (superpalindromesInRange left right)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_698_superpalindromesInRange.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate superpalindromesInRange))\n    (check-within (candidate \"500000000000\" \"1000000000000\") 0 0.001)\n    (check-within (candidate \"1000000000\" \"5000000000\") 0 0.001)\n    (check-within (candidate \"50000000000\" \"100000000000\") 0 0.001)\n    (check-within (candidate \"1\" \"1000\") 5 0.001)\n    (check-within (candidate \"1\" \"1\") 1 0.001)\n    (check-within (candidate \"500\" \"1000\") 0 0.001)\n    (check-within (candidate \"200\" \"500\") 1 0.001)\n    (check-within (candidate \"100000000000\" \"500000000000\") 0 0.001)\n    (check-within (candidate \"10000000\" \"100000000\") 0 0.001)\n    (check-within (candidate \"5000000000\" \"10000000000\") 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_69_min_window", "language": "rkt", "prompt": "#lang racket\n;; Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n;; The testcases will be generated such that the answer is unique.\n;; Example 1:\n;; Input: s = \"ADOBECODEBANC\", t = \"ABC\"\n;; Output: \"BANC\"\n;; Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n;; Example 2:\n;; Input: s = \"a\", t = \"a\"\n;; Output: \"a\"\n;; Explanation: The entire string s is the minimum window.\n;; Example 3:\n;; Input: s = \"a\", t = \"aa\"\n;; Output: \"\"\n;; Explanation: Both 'a's from t must be included in the window.\n;; Since the largest window of s only has one 'a', return empty string.\n;; Constraints:\n;; m == s.length\n;; n == t.length\n;; 1 <= m, n <= 105\n;; s and t consist of uppercase and lowercase English letters.\n;; Follow up: Could you find an algorithm that runs in O(m + n) time?\n(define (min_window s t)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_69_min_window.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate min_window))\n    (check-within (candidate \"ZZZZZZXYZ\" \"ZZZZZZZZ\") \"\" 0.001)\n    (check-within (candidate \"ZZZZZXYZ\" \"ZZZZ\") \"ZZZZ\" 0.001)\n    (check-within (candidate \"XYZ\" \"XYZ\") \"XYZ\" 0.001)\n    (check-within (candidate \"ab\" \"a\") \"a\" 0.001)\n    (check-within (candidate \"XYZ\" \"ZZY\") \"\" 0.001)\n    (check-within (candidate \"ZZZZZZXYZ\" \"ZZZZZZ\") \"ZZZZZZ\" 0.001)\n    (check-within (candidate \"aaa\" \"aaa\") \"aaa\" 0.001)\n    (check-within (candidate \"aab\" \"aab\") \"aab\" 0.001)\n    (check-within (candidate \"XYZ\" \"YXZ\") \"XYZ\" 0.001)\n    (check-within (candidate \"AABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" 0.001)\n    (check-within (candidate \"ZZZZZZXYZ\" \"ZZZZ\") \"ZZZZ\" 0.001)\n    (check-within (candidate \"abccbcccsd\" \"bcccsdabx\") \"\" 0.001)\n    (check-within (candidate \"aaaaaaaa\" \"aaaaaaaa\") \"aaaaaaaa\" 0.001)\n    (check-within (candidate \"abcabccbcccsd\" \"bcccsdabx\") \"\" 0.001)\n    (check-within (candidate \"ABAZBC\" \"AC\") \"AZBC\" 0.001)\n    (check-within (candidate \"XYZ\" \"YZZ\") \"\" 0.001)\n    (check-within (candidate \"aaaaaaaa\" \"a\") \"a\" 0.001)\n    (check-within (candidate \"ZZZZZZXYZ\" \"ZZZZZ\") \"ZZZZZ\" 0.001)\n    (check-within (candidate \"aaaaaaaa\" \"aaaaa\") \"aaaaa\" 0.001)\n    (check-within (candidate \"aaaaaaaa\" \"aaaaaaaaa\") \"\" 0.001)\n    (check-within (candidate \"ABAZBC\" \"AB\") \"AB\" 0.001)\n    (check-within (candidate \"XYZ\" \"YZX\") \"XYZ\" 0.001)\n    (check-within (candidate \"\" \"\") \"\" 0.001)\n    (check-within (candidate \"XYZ\" \"YYZ\") \"\" 0.001)\n    (check-within (candidate \"aaaaaaaa\" \"aaaaaaa\") \"aaaaaaa\" 0.001)\n    (check-within (candidate \"abccbcccsde\" \"bcccsdabx\") \"\" 0.001)\n    (check-within (candidate \"\" \"aa\") \"\" 0.001)\n    (check-within (candidate \"XYZ\" \"ZYZ\") \"\" 0.001)\n    (check-within (candidate \"a\" \"aa\") \"\" 0.001)\n    (check-within (candidate \"ADOBECODEBANC\" \"ABC\") \"BANC\" 0.001)\n    (check-within (candidate \"aa\" \"aa\") \"aa\" 0.001)\n    (check-within (candidate \"aaaaaaaa\" \"aaaa\") \"aaaa\" 0.001)\n    (check-within (candidate \"aaaaaaaa\" \"aaaaaa\") \"aaaaaa\" 0.001)\n    (check-within (candidate \"a\" \"a\") \"a\" 0.001)\n    (check-within (candidate \"aaa\" \"aa\") \"aa\" 0.001)\n    (check-within (candidate \"ADOBECODEBANC\" \"ABCDEFOO\") \"\" 0.001)\n    (check-within (candidate \"abccbcccsd\" \"bcccsdab\") \"abccbcccsd\" 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_704_catMouseGame", "language": "rkt", "prompt": "#lang racket\n;; A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns.\n;; The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph.\n;; The mouse starts at node 1 and goes first, the cat starts at node 2 and goes second, and there is a hole at node 0.\n;; During each player's turn, they must travel along one\u00a0edge of the graph that meets where they are.\u00a0 For example, if the Mouse is at node 1, it must travel to any node in graph[1].\n;; Additionally, it is not allowed for the Cat to travel to the Hole (node 0.)\n;; Then, the game can end in three\u00a0ways:\n;; If ever the Cat occupies the same node as the Mouse, the Cat wins.\n;; If ever the Mouse reaches the Hole, the Mouse wins.\n;; If ever a position is repeated (i.e., the players are in the same position as a previous turn, and\u00a0it is the same player's turn to move), the game is a draw.\n;; Given a graph, and assuming both players play optimally, return\n;; 1\u00a0if the mouse wins the game,\n;; 2\u00a0if the cat wins the game, or\n;; 0\u00a0if the game is a draw.\n;; Example 1:\n;; Input: graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\n;; Output: 0\n;; Example 2:\n;; Input: graph = [[1,3],[0],[3],[0,2]]\n;; Output: 1\n;; Constraints:\n;; 3 <= graph.length <= 50\n;; 1\u00a0<= graph[i].length < graph.length\n;; 0 <= graph[i][j] < graph.length\n;; graph[i][j] != i\n;; graph[i] is unique.\n;; The mouse and the cat can always move.\u00a0\n(define (catMouseGame graph)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_704_catMouseGame.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate catMouseGame))\n    (check-within (candidate (list (list 2 5) (list 3) (list 0 4 5) (list 1 4 5) (list 2 3) (list 0 2 3))) 0 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5) (list 0 2 3 4) (list 0 1 3 4) (list 0 1 2 4 5) (list 0 1 2 3) (list 0 3))) 1 0.001)\n    (check-within (candidate (list (list 2 5) (list 3) (list 0 4 5) (list 1 4 5) (list 2 3) (list 0 2 3) (list 0))) 0 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 0 2 4) (list 0 1 3 4) (list 0 2) (list 1 2))) 1 0.001)\n    (check-within (candidate (list (list 1 2) (list 3 4) (list 3 4 5) (list 4) (list 0) (list 2 3 4 5) (list 2 3) (list 2 3 4) (list 2 5) (list 3) (list 3 4))) 0 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 0 2 4) (list 0 1 3 4) (list 0 2) (list 1 2 4) (list 1 3))) 1 0.001)\n    (check-within (candidate (list (list 1 3) (list 0 2) (list 2) (list 2 3) (list 0 2 3))) 0 0.001)\n    (check-within (candidate (list (list 1 2 3 4) (list 0 2 3 4 5) (list 0 1 3 4) (list 0 1 2 4 5) (list 0 1 2 3 5) (list 1 2 3 4))) 1 0.001)\n    (check-within (candidate (list (list 1 2 3 4 5) (list 0) (list 0 2 3 4) (list 0 1 3 4 5) (list 0 1 2 4 5) (list 0 1 2 3 5) (list 1 2 3 4))) 0 0.001)\n    (check-within (candidate (list (list 1 2 3 4) (list 0 2 3 4 5) (list 0 1 3 4 5) (list 0 1 2 4 5) (list 0 1 2 3 5) (list 1 2 3 4))) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_710_numMusicPlaylists", "language": "rkt", "prompt": "#lang racket\n;; Your music player contains n different songs. You want to listen to goal songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that:\n;; Every song is played at least once.\n;; A song can only be played again only if k other songs have been played.\n;; Given n, goal, and k, return the number of possible playlists that you can create. Since the answer can be very large, return it modulo 109 + 7.\n;; Example 1:\n;; Input: n = 3, goal = 3, k = 1\n;; Output: 6\n;; Explanation: There are 6 possible playlists: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n;; Example 2:\n;; Input: n = 2, goal = 3, k = 0\n;; Output: 6\n;; Explanation: There are 6 possible playlists: [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], and [1, 2, 2].\n;; Example 3:\n;; Input: n = 2, goal = 3, k = 1\n;; Output: 2\n;; Explanation: There are 2 possible playlists: [1, 2, 1] and [2, 1, 2].\n;; Constraints:\n;; 0 <= k < n <= goal <= 100\n(define (numMusicPlaylists n goal k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_710_numMusicPlaylists.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate numMusicPlaylists))\n    (check-within (candidate 6 6 1) 720 0.001)\n    (check-within (candidate 3 3 1) 6 0.001)\n    (check-within (candidate 2 2 1) 2 0.001)\n    (check-within (candidate 10 1 3) 0 0.001)\n    (check-within (candidate 4 4 1) 24 0.001)\n    (check-within (candidate 10 10 1) 3628800 0.001)\n    (check-within (candidate 10 10 0) 3628800 0.001)\n    (check-within (candidate 1 1 0) 1 0.001)\n    (check-within (candidate 4 4 0) 24 0.001)\n    (check-within (candidate 1 1 1) 1 0.001)\n    (check-within (candidate 1 1 10) 1 0.001)\n    (check-within (candidate 3 3 2) 6 0.001)\n    (check-within (candidate 10 10 4) 3628800 0.001)\n    (check-within (candidate 6 6 0) 720 0.001)\n    (check-within (candidate 10 10 2) 3628800 0.001)\n    (check-within (candidate 5 5 2) 120 0.001)\n    (check-within (candidate 2 2 10) 2 0.001)\n    (check-within (candidate 10 10 5) 3628800 0.001)\n    (check-within (candidate 1 1 2) 1 0.001)\n    (check-within (candidate 10 10 10) 3628800 0.001)\n    (check-within (candidate 5 5 0) 120 0.001)\n    (check-within (candidate 10 10 7) 3628800 0.001)\n    (check-within (candidate 2 2 2) 2 0.001)\n    (check-within (candidate 10 10 8) 3628800 0.001)\n    (check-within (candidate 10 10 3) 3628800 0.001)\n    (check-within (candidate 2 2 0) 2 0.001)\n    (check-within (candidate 2 3 0) 6 0.001)\n    (check-within (candidate 3 3 0) 6 0.001)\n    (check-within (candidate 10 10 9) 3628800 0.001)\n    (check-within (candidate 10 10 6) 3628800 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_726_moves_to_stamp", "language": "rkt", "prompt": "#lang racket\n;; You are given two strings stamp and target. Initially, there is a string s of length target.length with all s[i] == '?'.\n;; In one turn, you can place stamp over s and replace every letter in the s with the corresponding letter from stamp.\n;; For example, if stamp = \"abc\" and target = \"abcba\", then s is \"?????\" initially. In one turn you can:\n;; place stamp at index 0 of s to obtain \"abc??\",\n;; place stamp at index 1 of s to obtain \"?abc?\", or\n;; place stamp at index 2 of s to obtain \"??abc\".\n;;     Note that stamp must be fully contained in the boundaries of s in order to stamp (i.e., you cannot place stamp at index 3 of s).\n;; We want to convert s to target using at most 10 * target.length turns.\n;; Return a list of the index of the left-most letter being stamped at each turn. If we cannot obtain target from s within 10 * target.length turns, return an empty list.\n;; Example 1:\n;; Input: stamp = \"abc\", target = \"ababc\"\n;; Output: [0,2]\n;; Explanation: Initially s = \"?????\".\n;; - Place stamp at index 0 to get \"abc??\".\n;; - Place stamp at index 2 to get \"ababc\".\n;; [1,0,2] would also be accepted as an answer, as well as some other answers.\n;; Example 2:\n;; Input: stamp = \"abca\", target = \"aabcaca\"\n;; Output: [3,0,1]\n;; Explanation: Initially s = \"???????\".\n;; - Place stamp at index 3 to get \"???abca\".\n;; - Place stamp at index 0 to get \"abcabca\".\n;; - Place stamp at index 1 to get \"aabcaca\".\n;; Constraints:\n;; 1 <= stamp.length <= target.length <= 1000\n;; stamp and target consist of lowercase English letters.\n(define (moves_to_stamp stamp target)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_726_moves_to_stamp.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate moves_to_stamp))\n    (check-within (candidate \"abc\" \"bbabca\") (list ) 0.001)\n    (check-within (candidate \"abab\" \"baba\") (list ) 0.001)\n    (check-within (candidate \"abca\" \"bca\") (list ) 0.001)\n    (check-within (candidate \"abca\" \"aabc\") (list ) 0.001)\n    (check-within (candidate \"aaaaaaaaaaaaaaab\" \"aaaaaaaaaaaaaaab\") (list 0) 0.001)\n    (check-within (candidate \"ab\" \"ab\") (list 0) 0.001)\n    (check-within (candidate \"abc\" \"abcabcabcd\") (list ) 0.001)\n    (check-within (candidate \"abc\" \"abcabcabcd\") (list ) 0.001)\n    (check-within (candidate \"abc\" \"ababba\") (list ) 0.001)\n    (check-within (candidate \"abca\" \"aabcac\") (list ) 0.001)\n    (check-within (candidate \"abc\" \"cccc\") (list ) 0.001)\n    (check-within (candidate \"abca\" \"aabcac\") (list ) 0.001)\n    (check-within (candidate \"aab\" \"aaaaaabaaa\") (list ) 0.001)\n    (check-within (candidate \"ab\" \"ababc\") (list ) 0.001)\n    (check-within (candidate \"abc\" \"abcabcabcd\") (list ) 0.001)\n    (check-within (candidate \"abc\" \"babca\") (list ) 0.001)\n    (check-within (candidate \"abc\" \"ababc\") (list 0 2) 0.001)\n    (check-within (candidate \"abca\" \"abca\") (list 0) 0.001)\n    (check-within (candidate \"abc\" \"ab\") (list ) 0.001)\n    (check-within (candidate \"abcd\" \"abcd\") (list 0) 0.001)\n    (check-within (candidate \"abca\" \"abcabcabcd\") (list ) 0.001)\n    (check-within (candidate \"abca\" \"aabcac\") (list ) 0.001)\n    (check-within (candidate \"a\" \"a\") (list 0) 0.001)\n    (check-within (candidate \"abc\" \"abc\") (list 0) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_730_distinctSubseqII", "language": "rkt", "prompt": "#lang racket\n;; Given a string s, return the number of distinct non-empty subsequences of s. Since the answer may be very large, return it modulo 109 + 7.\n;; A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not.\n;; Example 1:\n;; Input: s = \"abc\"\n;; Output: 7\n;; Explanation: The 7 distinct subsequences are \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", and \"abc\".\n;; Example 2:\n;; Input: s = \"aba\"\n;; Output: 6\n;; Explanation: The 6 distinct subsequences are \"a\", \"b\", \"ab\", \"aa\", \"ba\", and \"aba\".\n;; Example 3:\n;; Input: s = \"aaa\"\n;; Output: 3\n;; Explanation: The 3 distinct subsequences are \"a\", \"aa\" and \"aaa\".\n;; Constraints:\n;; 1 <= s.length <= 2000\n;; s consists of lowercase English letters.\n(define (distinctSubseqII s)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_730_distinctSubseqII.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate distinctSubseqII))\n    (check-within (candidate \"ab\") 3 0.001)\n    (check-within (candidate \"abcdefghijklm\") 8191 0.001)\n    (check-within (candidate \"abcd\") 15 0.001)\n    (check-within (candidate \"abcdefghi\") 511 0.001)\n    (check-within (candidate \"aaa\") 3 0.001)\n    (check-within (candidate \"abcde\") 31 0.001)\n    (check-within (candidate \"abc\") 7 0.001)\n    (check-within (candidate \"aaa\") 3 0.001)\n    (check-within (candidate \"ba\") 3 0.001)\n    (check-within (candidate \"aba\") 6 0.001)\n    (check-within (candidate \"abcdefg\") 127 0.001)\n    (check-within (candidate \"abcdefghijklmnopqrstuvwx\") 16777215 0.001)\n    (check-within (candidate \"abcdefghij\") 1023 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_746_min_k_bit_flips", "language": "rkt", "prompt": "#lang racket\n;; You are given a binary list nums and an integer k.\n;; A k-bit flip is choosing a sublist of length k from nums and simultaneously changing every 0 in the sublist to 1, and every 1 in the sublist to 0.\n;; Return the minimum number of k-bit flips required so that there is no 0 in the list. If it is not possible, return -1.\n;; A sublist is a contiguous part of a list.\n;; Example 1:\n;; Input: nums = [0,1,0], k = 1\n;; Output: 2\n;; Explanation: Flip nums[0], then flip nums[2].\n;; Example 2:\n;; Input: nums = [1,1,0], k = 2\n;; Output: -1\n;; Explanation: No matter how we flip sublists of size 2, we cannot make the list become [1,1,1].\n;; Example 3:\n;; Input: nums = [0,0,0,1,0,1,1,0], k = 3\n;; Output: 3\n;; Explanation: \n;; Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]\n;; Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]\n;; Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]\n;; Constraints:\n;; 1 <= nums.length <= 105\n;; 1 <= k <= nums.length\n(define (min_k_bit_flips nums k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_746_min_k_bit_flips.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate min_k_bit_flips))\n    (check-within (candidate (list 0 1 0 1 0 1 0 1) 1) 4 0.001)\n    (check-within (candidate (list 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) 3) -1 0.001)\n    (check-within (candidate (list 0 0 0 1 0 1 1 0) 3) 3 0.001)\n    (check-within (candidate (list 0 1 0) 1) 2 0.001)\n    (check-within (candidate (list 1 0 0 1 0 1 1 0) 2) 4 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) 2) 8 0.001)\n    (check-within (candidate (list 1 1 0) 1) 1 0.001)\n    (check-within (candidate (list 1 1 0) 2) -1 0.001)\n    (check-within (candidate (list 1 1 1 1) 1) 0 0.001)\n    (check-within (candidate (list 0) 1) 1 0.001)\n    (check-within (candidate (list 0 0 0 1 0 1 1 0) 2) -1 0.001)\n    (check-within (candidate (list 1 0) 2) -1 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) 4) 4 0.001)\n    (check-within (candidate (list 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1) 2) 8 0.001)\n    (check-within (candidate (list 0 0 0 0 0 0 0 0 0 0) 2) 5 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_747_numSquarefulPerms", "language": "rkt", "prompt": "#lang racket\n;; An list is squareful if the sum of every pair of adjacent elements is a perfect square.\n;; Given an integer list nums, return the number of permutations of nums that are squareful.\n;; Two permutations perm1 and perm2 are different if there is some index i such that perm1[i] != perm2[i].\n;; Example 1:\n;; Input: nums = [1,17,8]\n;; Output: 2\n;; Explanation: [1,8,17] and [17,8,1] are the valid permutations.\n;; Example 2:\n;; Input: nums = [2,2,2]\n;; Output: 1\n;; Constraints:\n;; 1 <= nums.length <= 12\n;; 0 <= nums[i] <= 109\n(define (numSquarefulPerms nums)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_747_numSquarefulPerms.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate numSquarefulPerms))\n    (check-within (candidate (list 1 2 2 3 3 3)) 0 0.001)\n    (check-within (candidate (list 2 2 2 2 2 2 2 2 2 2 2 2)) 1 0.001)\n    (check-within (candidate (list 2 2 2)) 1 0.001)\n    (check-within (candidate (list 2 2 2 2 2 2)) 1 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1 1 8)) 0 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1 1 17)) 0 0.001)\n    (check-within (candidate (list 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2)) 1 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9)) 0 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1 1 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17)) 0 0.001)\n    (check-within (candidate (list 1 17 8)) 2 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1 1 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17)) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_761_isRationalEqual", "language": "rkt", "prompt": "#lang racket\n;; Given two strings s and t, each of which represents a non-negative rational number, return true if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number.\n;; A rational number can be represented using up to three parts: <IntegerPart>, <NonRepeatingPart>, and a <RepeatingPart>. The number will be represented in one of the following three ways:\n;; <IntegerPart>\n;; For example, 12, 0, and 123.\n;; <IntegerPart><.><NonRepeatingPart>\n;; For example, 0.5, 1., 2.12, and 123.0001.\n;; <IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)>\n;; For example, 0.1(6), 1.(9), 123.00(1212).\n;; The repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets. For example:\n;; 1/6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66).\n;; Example 1:\n;; Input: s = \"0.(52)\", t = \"0.5(25)\"\n;; Output: true\n;; Explanation: Because \"0.(52)\" represents 0.52525252..., and \"0.5(25)\" represents 0.52525252525..... , the strings represent the same number.\n;; Example 2:\n;; Input: s = \"0.1666(6)\", t = \"0.166(66)\"\n;; Output: true\n;; Example 3:\n;; Input: s = \"0.9(9)\", t = \"1.\"\n;; Output: true\n;; Explanation: \"0.9(9)\" represents 0.999999999... repeated forever, which equals 1.  [See this link for an explanation.]\n;; \"1.\" represents the number 1, which is formed correctly: (IntegerPart) = \"1\" and (NonRepeatingPart) = \"\".\n;; Constraints:\n;; Each part consists only of digits.\n;; The <IntegerPart> does not have leading zeros (except for the zero itself).\n;; 1 <= <IntegerPart>.length <= 4\n;; 0 <= <NonRepeatingPart>.length <= 4\n;; 1 <= <RepeatingPart>.length <= 4\n(define (isRationalEqual s t)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_761_isRationalEqual.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate isRationalEqual))\n    (check-within (candidate \"0.00001\" \"0.00002\") #f 0.001)\n    (check-within (candidate \"0.9999\" \"0.99989\") #f 0.001)\n    (check-within (candidate \"0.(9)\" \"0.99\") #f 0.001)\n    (check-within (candidate \"0.999(9)\" \"1.000000001\") #f 0.001)\n    (check-within (candidate \"0.58(3)\" \"0.58333333\") #f 0.001)\n    (check-within (candidate \"0.11111\" \"0.111111\") #f 0.001)\n    (check-within (candidate \"0.9(9)\" \"1.\") #t 0.001)\n    (check-within (candidate \"1.00000000000000000000000000000000000\" \"1.0000000000\") #t 0.001)\n    (check-within (candidate \"0.0000000001\" \"0.0000000002\") #f 0.001)\n    (check-within (candidate \"0.(12)\" \"0.12000000000000000000000000000000001\") #f 0.001)\n    (check-within (candidate \"0.00000\" \"0\") #t 0.001)\n    (check-within (candidate \"0.(52)\" \"0.5252525252\") #f 0.001)\n    (check-within (candidate \"0.5555\" \"0.55550\") #t 0.001)\n    (check-within (candidate \"0.1(1)\" \"0.11\") #f 0.001)\n    (check-within (candidate \"0.1666(6)\" \"0.166(66)\") #t 0.001)\n    (check-within (candidate \"0.(9983)\" \"0.99830000\") #f 0.001)\n    (check-within (candidate \"0.(92)\" \"0.929\") #f 0.001)\n    (check-within (candidate \"0.(9)\" \"0.999999\") #f 0.001)\n    (check-within (candidate \"0.9(9)\" \"1.0\") #t 0.001)\n    (check-within (candidate \"0.1\" \"0.1000000001\") #f 0.001)\n    (check-within (candidate \"0.999(9)\" \"1.0000000001\") #f 0.001)\n    (check-within (candidate \"0.(9)\" \"1.0\") #t 0.001)\n    (check-within (candidate \"0.5000\" \"0.5\") #t 0.001)\n    (check-within (candidate \"0.123(4)\" \"0.12340000000000000000000000000000001\") #f 0.001)\n    (check-within (candidate \"0.(9999999999999999999999999999999999)\" \"1.00000000000000000000000000000000000\") #t 0.001)\n    (check-within (candidate \"1.0\" \"1.0000\") #t 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_771_uniquePathsIII", "language": "rkt", "prompt": "#lang racket\n;; You are given an m x n integer list grid where grid[i][j] could be:\n;; 1 representing the starting square. There is exactly one starting square.\n;; 2 representing the ending square. There is exactly one ending square.\n;; 0 representing empty squares we can walk over.\n;; -1 representing obstacles that we cannot walk over.\n;; Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.\n;; Example 1:\n;; Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\n;; Output: 2\n;; Explanation: We have the following two paths: \n;; 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n;; 2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n;; Example 2:\n;; Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]\n;; Output: 4\n;; Explanation: We have the following four paths: \n;; 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n;; 2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n;; 3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n;; 4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\n;; Example 3:\n;; Input: grid = [[0,1],[2,0]]\n;; Output: 0\n;; Explanation: There is no path that walks over every empty square exactly once.\n;; Note that the starting and ending square can be anywhere in the grid.\n;; Constraints:\n;; m == grid.length\n;; n == grid[i].length\n;; 1 <= m, n <= 20\n;; 1 <= m * n <= 20\n;; -1 <= grid[i][j] <= 2\n;; There is exactly one starting cell and one ending cell.\n(define (uniquePathsIII grid)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_771_uniquePathsIII.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate uniquePathsIII))\n    (check-within (candidate (list (list 0))) 0 0.001)\n    (check-within (candidate (list (list 1 0 0 0) (list 0 0 -1 0) (list 0 0 0 2))) 0 0.001)\n    (check-within (candidate (list (list 0 1) (list 2 0))) 0 0.001)\n    (check-within (candidate (list (list 1 0 0 0 0) (list 0 0 0 0 0) (list 0 0 0 0 -1) (list 0 0 0 0 2))) 0 0.001)\n    (check-within (candidate (list (list 0) (list 0) (list 0))) 0 0.001)\n    (check-within (candidate (list (list 1 -1 0 0) (list 0 0 0 0) (list 0 0 0 2))) 0 0.001)\n    (check-within (candidate (list (list 1 0 0 0) (list 0 0 0 0) (list 0 0 0 2) (list 0 0 0 -1))) 0 0.001)\n    (check-within (candidate (list (list 0) (list 0))) 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_77_isScramble", "language": "rkt", "prompt": "#lang racket\n;; We can scramble a string s to get a string t using the following algorithm:\n;; If the length of the string is 1, stop.\n;; If the length of the string is > 1, do the following:\n;; Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\n;; Randomly\u00a0decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\n;; Apply step 1 recursively on each of the two substrings x and y.\n;; Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.\n;; Example 1:\n;; Input: s1 = \"great\", s2 = \"rgeat\"\n;; Output: true\n;; Explanation: One possible scenario applied on s1 is:\n;; \"great\" --> \"gr/eat\" // divide at random index.\n;; \"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n;; \"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n;; \"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n;; \"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n;; \"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\n;; The algorithm stops now, and the result string is \"rgeat\" which is s2.\n;; As one possible scenario led s1 to be scrambled to s2, we return true.\n;; Example 2:\n;; Input: s1 = \"abcde\", s2 = \"caebd\"\n;; Output: false\n;; Example 3:\n;; Input: s1 = \"a\", s2 = \"a\"\n;; Output: true\n;; Constraints:\n;; s1.length == s2.length\n;; 1 <= s1.length <= 30\n;; s1 and s2 consist of lowercase English letters.\n(define (isScramble s1 s2)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_77_isScramble.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate isScramble))\n    (check-within (candidate \"aaaa\" \"aaa\") #f 0.001)\n    (check-within (candidate \"abcde\" \"ebcda\") #t 0.001)\n    (check-within (candidate \"abb\" \"bba\") #t 0.001)\n    (check-within (candidate \"web\" \"bwe\") #t 0.001)\n    (check-within (candidate \"bac\" \"bca\") #t 0.001)\n    (check-within (candidate \"datastructure\" \"tastructureda\") #t 0.001)\n    (check-within (candidate \"rat\" \"tar\") #t 0.001)\n    (check-within (candidate \"t\" \"t\") #t 0.001)\n    (check-within (candidate \"asd\" \"dsa\") #t 0.001)\n    (check-within (candidate \"abbc\" \"acbb\") #t 0.001)\n    (check-within (candidate \"documentation\" \"entationdocum\") #t 0.001)\n    (check-within (candidate \"aabbc\" \"aabc\") #f 0.001)\n    (check-within (candidate \"abcdefghijklmnopqrstuvwxyz\" \"zxywvutsrqponmlkjihgfedcba\") #t 0.001)\n    (check-within (candidate \"language\" \"uagelagn\") #t 0.001)\n    (check-within (candidate \"performance\" \"rmanceperfo\") #t 0.001)\n    (check-within (candidate \"dbs\" \"sdb\") #t 0.001)\n    (check-within (candidate \"\" \"a\") #f 0.001)\n    (check-within (candidate \"algorithm\" \"gorithmal\") #t 0.001)\n    (check-within (candidate \"ab\" \"ab\") #t 0.001)\n    (check-within (candidate \"optimization\" \"izationoptim\") #t 0.001)\n    (check-within (candidate \"abcd\" \"cbad\") #t 0.001)\n    (check-within (candidate \"great\" \"rgeat\") #t 0.001)\n    (check-within (candidate \"abcdefghij\" \"efghijcadb\") #f 0.001)\n    (check-within (candidate \"javascript\" \"tjavascrip\") #t 0.001)\n    (check-within (candidate \"abcde\" \"caebd\") #f 0.001)\n    (check-within (candidate \"hello\" \"ohlel\") #t 0.001)\n    (check-within (candidate \"internet\" \"terninet\") #t 0.001)\n    (check-within (candidate \"anagram\" \"nagaram\") #t 0.001)\n    (check-within (candidate \"tpg\" \"pgt\") #t 0.001)\n    (check-within (candidate \"abc\" \"cba\") #t 0.001)\n    (check-within (candidate \"integration\" \"grationinte\") #t 0.001)\n    (check-within (candidate \"bcdefg\" \"fcbegda\") #f 0.001)\n    (check-within (candidate \"testing\" \"gintest\") #t 0.001)\n    (check-within (candidate \"tt\" \"ttt\") #f 0.001)\n    (check-within (candidate \"aaa\" \"aab\") #f 0.001)\n    (check-within (candidate \"asd\" \"das\") #t 0.001)\n    (check-within (candidate \"database\" \"basedata\") #t 0.001)\n    (check-within (candidate \"babb\" \"bbab\") #t 0.001)\n    (check-within (candidate \"javascript\" \"riptjavasc\") #t 0.001)\n    (check-within (candidate \"a\" \"b\") #f 0.001)\n    (check-within (candidate \"a\" \"\") #f 0.001)\n    (check-within (candidate \"computer\" \"putercom\") #t 0.001)\n    (check-within (candidate \"xyxyxyzz\" \"xxyyzzzx\") #f 0.001)\n    (check-within (candidate \"design\" \"sgined\") #t 0.001)\n    (check-within (candidate \"physics\" \"fysicep\") #f 0.001)\n    (check-within (candidate \"deployment\" \"mentdeploy\") #t 0.001)\n    (check-within (candidate \"specification\" \"cationfispeci\") #t 0.001)\n    (check-within (candidate \"bca\" \"bca\") #t 0.001)\n    (check-within (candidate \"python\" \"ythonp\") #t 0.001)\n    (check-within (candidate \"tt\" \"tt\") #t 0.001)\n    (check-within (candidate \"aacde\" \"deeca\") #f 0.001)\n    (check-within (candidate \"javascript\" \"jvascripted\") #f 0.001)\n    (check-within (candidate \"security\" \"uritysec\") #t 0.001)\n    (check-within (candidate \"maintenance\" \"enancemaint\") #t 0.001)\n    (check-within (candidate \"implementation\" \"ationimplement\") #t 0.001)\n    (check-within (candidate \"world\" \"rldwo\") #t 0.001)\n    (check-within (candidate \"abcd\" \"abcd\") #t 0.001)\n    (check-within (candidate \"tt\" \"t\") #f 0.001)\n    (check-within (candidate \"debugging\" \"uggingdeb\") #t 0.001)\n    (check-within (candidate \"abcd\" \"dacb\") #t 0.001)\n    (check-within (candidate \"network\" \"worknet\") #t 0.001)\n    (check-within (candidate \"a\" \"a\") #t 0.001)\n    (check-within (candidate \"\" \"\") #t 0.001)\n    (check-within (candidate \"banana\" \"ananab\") #t 0.001)\n    (check-within (candidate \"asd\" \"dab\") #f 0.001)\n    (check-within (candidate \"abcd\" \"badc\") #t 0.001)\n    (check-within (candidate \"lk\" \"ll\") #f 0.001)\n    (check-within (candidate \"javascript\" \"pseudojack\") #f 0.001)\n    (check-within (candidate \"javascript\" \"javascript\") #t 0.001)\n    (check-within (candidate \"abcd\" \"dcba\") #t 0.001)\n    (check-within (candidate \"abcd\" \"abdc\") #t 0.001)\n    (check-within (candidate \"programming\" \"mingprogram\") #t 0.001)\n    (check-within (candidate \"visualization\" \"tionvisualiza\") #t 0.001)\n    (check-within (candidate \"abcd\" \"cdba\") #t 0.001)\n    (check-within (candidate \"ttt\" \"tt\") #f 0.001)\n    (check-within (candidate \"asd\" \"ads\") #t 0.001)\n    (check-within (candidate \"javascript\" \"javasript\") #f 0.001)\n    (check-within (candidate \"abc\" \"ac\") #f 0.001)\n    (check-within (candidate \"ab\" \"ba\") #t 0.001)\n    (check-within (candidate \"development\" \"opmentdevel\") #t 0.001)\n    (check-within (candidate \"abcdefg\" \"fbegcda\") #f 0.001)\n    (check-within (candidate \"abcdd\" \"abddc\") #t 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_781_min_k_bit_flips", "language": "rkt", "prompt": "#lang racket\n;; You are given a binary list nums and an integer k.\n;; A k-bit flip is choosing a sublist of length k from nums and simultaneously changing every 0 in the sublist to 1, and every 1 in the sublist to 0.\n;; Return the minimum number of k-bit flips required so that there is no 0 in the list. If it is not possible, return -1.\n;; A sublist is a contiguous part of a list.\n;; Example 1:\n;; Input: nums = [0,1,0], k = 1\n;; Output: 2\n;; Explanation: Flip nums[0], then flip nums[2].\n;; Example 2:\n;; Input: nums = [1,1,0], k = 2\n;; Output: -1\n;; Explanation: No matter how we flip sublists of size 2, we cannot make the list become [1,1,1].\n;; Example 3:\n;; Input: nums = [0,0,0,1,0,1,1,0], k = 3\n;; Output: 3\n;; Explanation: \n;; Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]\n;; Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]\n;; Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]\n;; Constraints:\n;; 1 <= nums.length <= 105\n;; 1 <= k <= nums.length\n(define (min_k_bit_flips nums k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_781_min_k_bit_flips.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate min_k_bit_flips))\n    (check-within (candidate (list 0 1 1 0 1 0 0 1 1 1 1 1 1 1 1) 3) -1 0.001)\n    (check-within (candidate (list 0 1 0 1 0 1 1 0) 1) 4 0.001)\n    (check-within (candidate (list 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1) 3) -1 0.001)\n    (check-within (candidate (list 0 0 0 1 0 1 1 0) 3) 3 0.001)\n    (check-within (candidate (list 1 0 1 0 1 0 1 0) 2) 4 0.001)\n    (check-within (candidate (list 1 1 0) 2) -1 0.001)\n    (check-within (candidate (list 0 1 0) 1) 2 0.001)\n    (check-within (candidate (list 0 0 1 1 0 1 0 1) 3) 4 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_786_mergeStones", "language": "rkt", "prompt": "#lang racket\n;; There are n piles of stones arranged in a row. The ith pile has stones[i] stones.\n;; A move consists of merging exactly k consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these k piles.\n;; Return the minimum cost to merge all piles of stones into one pile. If it is impossible, return -1.\n;; Example 1:\n;; Input: stones = [3,2,4,1], k = 2\n;; Output: 20\n;; Explanation: We start with [3, 2, 4, 1].\n;; We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1].\n;; We merge [4, 1] for a cost of 5, and we are left with [5, 5].\n;; We merge [5, 5] for a cost of 10, and we are left with [10].\n;; The total cost was 20, and this is the minimum possible.\n;; Example 2:\n;; Input: stones = [3,2,4,1], k = 3\n;; Output: -1\n;; Explanation: After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.\n;; Example 3:\n;; Input: stones = [3,5,1,2,6], k = 3\n;; Output: 25\n;; Explanation: We start with [3, 5, 1, 2, 6].\n;; We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6].\n;; We merge [3, 8, 6] for a cost of 17, and we are left with [17].\n;; The total cost was 25, and this is the minimum possible.\n;; Constraints:\n;; n == stones.length\n;; 1 <= n <= 30\n;; 1 <= stones[i] <= 100\n;; 2 <= k <= 30\n(define (mergeStones stones k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_786_mergeStones.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate mergeStones))\n    (check-within (candidate (list 3 2 4 1) 2) 20 0.001)\n    (check-within (candidate (list 3 2 4 1) 2) 20 0.001)\n    (check-within (candidate (list (list 1 2) (list 2 3) (list 3 4) (list 4 1) (list 1 3) (list 2 4)) 5) -1 0.001)\n    (check-within (candidate (list 3 2 4 1) 3) -1 0.001)\n    (check-within (candidate (list 3 2 4 1) 3) -1 0.001)\n    (check-within (candidate (list 3 2 4 1) 2) 20 0.001)\n    (check-within (candidate (list 3 2 4 1) 2) 20 0.001)\n    (check-within (candidate (list (list 1 2) (list 3 4)) 5) -1 0.001)\n    (check-within (candidate (list 3 2 4 1) 3) -1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_839_longest_dup_substring", "language": "rkt", "prompt": "#lang racket\n;; Given a string s, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times.\u00a0The occurrences\u00a0may overlap.\n;; Return any duplicated\u00a0substring that has the longest possible length.\u00a0If s does not have a duplicated substring, the answer is \"\".\n;; Example 1:\n;; Input: s = \"banana\"\n;; Output: \"ana\"\n;; Example 2:\n;; Input: s = \"abcd\"\n;; Output: \"\"\n;; Constraints:\n;; 2 <= s.length <= 3 * 104\n;; s consists of lowercase English letters.\n(define (longest_dup_substring s)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_839_longest_dup_substring.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate longest_dup_substring))\n    (check-within (candidate \"abcd\") \"\" 0.001)\n    (check-within (candidate \"aaaaa\") \"aaaa\" 0.001)\n    (check-within (candidate \"abcdxyzbcd\") \"bcd\" 0.001)\n    (check-within (candidate \"abcabc\") \"abc\" 0.001)\n    (check-within (candidate \"banana\") \"ana\" 0.001)\n    (check-within (candidate \"a\") \"\" 0.001)\n    (check-within (candidate \"zxcvbnmzxcvbnm\") \"zxcvbnm\" 0.001)\n    (check-within (candidate \"abcde\") \"\" 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_866_lastSubstring", "language": "rkt", "prompt": "#lang racket\n;; Given a string s, return the last substring of s in lexicographical order.\n;; Example 1:\n;; Input: s = \"abab\"\n;; Output: \"bab\"\n;; Explanation: The substrings are [\"a\", \"ab\", \"aba\", \"abab\", \"b\", \"ba\", \"bab\"]. The lexicographically maximum substring is \"bab\".\n;; Example 2:\n;; Input: s = \"leetcode\"\n;; Output: \"tcode\"\n;; Constraints:\n;; 1 <= s.length <= 4 * 105\n;; s contains only lowercase English letters.\n(define (lastSubstring s)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_866_lastSubstring.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate lastSubstring))\n    (check-within (candidate \"bbbbaaaaaaaaf\") \"f\" 0.001)\n    (check-within (candidate \"abab\") \"bab\" 0.001)\n    (check-within (candidate \"data\") \"ta\" 0.001)\n    (check-within (candidate \"coding\") \"oding\" 0.001)\n    (check-within (candidate \"ecbacbac\") \"ecbacbac\" 0.001)\n    (check-within (candidate \"bbaaaaaaaaaf\") \"f\" 0.001)\n    (check-within (candidate \"cat\") \"t\" 0.001)\n    (check-within (candidate \"abcab\") \"cab\" 0.001)\n    (check-within (candidate \"zabcz\") \"zabcz\" 0.001)\n    (check-within (candidate \"abcdefg\") \"g\" 0.001)\n    (check-within (candidate \"abcdef\") \"f\" 0.001)\n    (check-within (candidate \"aaaaaaaaa\") \"aaaaaaaaa\" 0.001)\n    (check-within (candidate \"qpqpqpq\") \"qpqpqpq\" 0.001)\n    (check-within (candidate \"a\") \"a\" 0.001)\n    (check-within (candidate \"qqqqqq\") \"qqqqqq\" 0.001)\n    (check-within (candidate \"qpqpqpqp\") \"qpqpqpqp\" 0.001)\n    (check-within (candidate \"qpqpqp\") \"qpqpqp\" 0.001)\n    (check-within (candidate \"abababab\") \"bababab\" 0.001)\n    (check-within (candidate \"helloworld\") \"world\" 0.001)\n    (check-within (candidate \"hbhbhbhbhbhbhbhb\") \"hbhbhbhbhbhbhbhb\" 0.001)\n    (check-within (candidate \"aaaaaaaaaaf\") \"f\" 0.001)\n    (check-within (candidate \"aaab\") \"b\" 0.001)\n    (check-within (candidate \"python\") \"ython\" 0.001)\n    (check-within (candidate \"leetcode\") \"tcode\" 0.001)\n    (check-within (candidate \"abcabc\") \"cabc\" 0.001)\n    (check-within (candidate \"aaa\") \"aaa\" 0.001)\n    (check-within (candidate \"hello\") \"o\" 0.001)\n    (check-within (candidate \"aaaaaaab\") \"b\" 0.001)\n    (check-within (candidate \"aa\") \"aa\" 0.001)\n    (check-within (candidate \"eee\") \"eee\" 0.001)\n    (check-within (candidate \"cbda\") \"da\" 0.001)\n    (check-within (candidate \"banana\") \"nana\" 0.001)\n    (check-within (candidate \"bbbbaaaaaaaaaf\") \"f\" 0.001)\n    (check-within (candidate \"zzzzz\") \"zzzzz\" 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_871_shortest_common_supersequence", "language": "rkt", "prompt": "#lang racket\n;; Given two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences. If there are multiple valid strings, return any of them.\n;; A string s is a subsequence of string t if deleting some number of characters from t (possibly 0) results in the string s.\n;; Example 1:\n;; Input: str1 = \"abac\", str2 = \"cab\"\n;; Output: \"cabac\"\n;; Explanation: \n;; str1 = \"abac\" is a subsequence of \"cabac\" because we can delete the first \"c\".\n;; str2 = \"cab\" is a subsequence of \"cabac\" because we can delete the last \"ac\".\n;; The answer provided is the shortest such string that satisfies these properties.\n;; Example 2:\n;; Input: str1 = \"aaaaaaaa\", str2 = \"aaaaaaaa\"\n;; Output: \"aaaaaaaa\"\n;; Constraints:\n;; 1 <= str1.length, str2.length <= 1000\n;; str1 and str2 consist of lowercase English letters.\n(define (shortest_common_supersequence str1 str2)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_871_shortest_common_supersequence.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate shortest_common_supersequence))\n    (check-within (candidate \"aaabbb\" \"bbbccc\") \"aaabbbccc\" 0.001)\n    (check-within (candidate \"abc\" \"\") \"abc\" 0.001)\n    (check-within (candidate \"\" \"\") \"\" 0.001)\n    (check-within (candidate \"aaabbb\" \"bbbccc\") \"aaabbbccc\" 0.001)\n    (check-within (candidate \"abcd\" \"bcd\") \"abcd\" 0.001)\n    (check-within (candidate \"aaaaaaaa\" \"aaaaaaaa\") \"aaaaaaaa\" 0.001)\n    (check-within (candidate \"abc\" \"bcd\") \"abcd\" 0.001)\n    (check-within (candidate \"abac\" \"cabac\") \"cabac\" 0.001)\n    (check-within (candidate \"abc\" \"cde\") \"abcde\" 0.001)\n    (check-within (candidate \"abac\" \"cab\") \"cabac\" 0.001)\n    (check-within (candidate \"baaa\" \"aaa\") \"baaa\" 0.001)\n    (check-within (candidate \"abcabc\" \"abcabc\") \"abcabc\" 0.001)\n    (check-within (candidate \"abc\" \"abc\") \"abc\" 0.001)\n    (check-within (candidate \"ab\" \"bc\") \"abc\" 0.001)\n    (check-within (candidate \"\" \"aaaa\") \"aaaa\" 0.001)\n    (check-within (candidate \"\" \"a\") \"a\" 0.001)\n    (check-within (candidate \"abcdefghij\" \"defghijabc\") \"abcdefghijabc\" 0.001)\n    (check-within (candidate \"abcde\" \"cde\") \"abcde\" 0.001)\n    (check-within (candidate \"abcdefgh\" \"abcdefgh\") \"abcdefgh\" 0.001)\n    (check-within (candidate \"\" \"def\") \"def\" 0.001)\n    (check-within (candidate \"aaabbb\" \"bbb\") \"aaabbb\" 0.001)\n    (check-within (candidate \"abcdef\" \"abcdef\") \"abcdef\" 0.001)\n    (check-within (candidate \"aaaaaa\" \"aaaaaa\") \"aaaaaa\" 0.001)\n    (check-within (candidate \"aaaaaaaa\" \"aaaaaaaa\") \"aaaaaaaa\" 0.001)\n    (check-within (candidate \"ab\" \"ab\") \"ab\" 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_876_find_num_of_valid_words", "language": "rkt", "prompt": "#lang racket\n;; With respect to a given puzzle string, a word is valid if both the following conditions are satisfied:\n;; word contains the first letter of puzzle.\n;; For each letter in word, that letter is in puzzle.\n;; For example, if the puzzle is \"abcdefg\", then valid words are \"faced\", \"cabbage\", and \"baggage\", while\n;; invalid words are \"beefed\" (does not include 'a') and \"based\" (includes 's' which is not in the puzzle).\n;; Return a list answer, where answer[i] is the number of words in the given word list words that is valid with respect to the puzzle puzzles[i].\n;; Example 1:\n;; Input: words = [\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"], puzzles = [\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"]\n;; Output: [1,1,3,2,4,0]\n;; Explanation: \n;; 1 valid word for \"aboveyz\" : \"aaaa\" \n;; 1 valid word for \"abrodyz\" : \"aaaa\"\n;; 3 valid words for \"abslute\" : \"aaaa\", \"asas\", \"able\"\n;; 2 valid words for \"absoryz\" : \"aaaa\", \"asas\"\n;; 4 valid words for \"actresz\" : \"aaaa\", \"asas\", \"actt\", \"access\"\n;; There are no valid words for \"gaswxyz\" cause none of the words in the list contains letter 'g'.\n;; Example 2:\n;; Input: words = [\"apple\",\"pleas\",\"please\"], puzzles = [\"aelwxyz\",\"aelpxyz\",\"aelpsxy\",\"saelpxy\",\"xaelpsy\"]\n;; Output: [0,1,3,2,0]\n;; Constraints:\n;; 1 <= words.length <= 105\n;; 4 <= words[i].length <= 50\n;; 1 <= puzzles.length <= 104\n;; puzzles[i].length == 7\n;; words[i] and puzzles[i] consist of lowercase English letters.\n;; Each puzzles[i] does not contain repeated characters.\n(define (find_num_of_valid_words words puzzles)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_876_find_num_of_valid_words.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_num_of_valid_words))\n    (check-within (candidate (list \"a\" \"b\" \"c\" \"d\") (list \"abcd\" \"dcba\" \"badc\" \"cdab\" \"e\")) (list 1 1 1 1 0) 0.001)\n    (check-within (candidate (list \"apple\" \"pleas\" \"please\") (list \"aelwxyz\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\" \"dcba\")) (list 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) 0.001)\n    (check-within (candidate (list \"ab\" \"cd\" \"ef\" \"gh\") (list \"abcdefg\" \"abcdefgh\" \"badcfehg\" \"hgfedcba\")) (list 1 1 1 1) 0.001)\n    (check-within (candidate (list \"aaaa\" \"asas\" \"able\" \"ability\" \"actt\" \"actor\" \"access\") (list \"aboveyz\")) (list 1) 0.001)\n    (check-within (candidate (list \"aaaa\" \"asas\" \"able\" \"ability\" \"actt\" \"actor\" \"access\") (list \"aboveyz\" \"abrodyz\" \"abslute\" \"absoryz\" \"actresz\" \"gaswxyz\")) (list 1 1 3 2 4 0) 0.001)\n    (check-within (candidate (list \"apple\" \"pleas\" \"please\") (list \"aelwxyz\" \"aelpxyz\" \"aelpsxy\" \"saelpxy\" \"xaelpsy\")) (list 0 1 3 2 0) 0.001)\n    (check-within (candidate (list \"apple\" \"pleas\" \"please\") (list \"aelwxyz\")) (list 0) 0.001)\n    (check-within (candidate (list \"apple\") (list \"apple\" \"pleas\" \"please\")) (list 1 1 1) 0.001)\n    (check-within (candidate (list \"a\" \"b\" \"c\" \"d\") (list \"abcd\" \"dcba\" \"badc\" \"cdab\")) (list 1 1 1 1) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_886_criticalConnections", "language": "rkt", "prompt": "#lang racket\n;; There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network.\n;; A critical connection is a connection that, if removed, will make some servers unable to reach some other server.\n;; Return all critical connections in the network in any order.\n;; Example 1:\n;; Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]\n;; Output: [[1,3]]\n;; Explanation: [[3,1]] is also accepted.\n;; Example 2:\n;; Input: n = 2, connections = [[0,1]]\n;; Output: [[0,1]]\n;; Constraints:\n;; 2 <= n <= 105\n;; n - 1 <= connections.length <= 105\n;; 0 <= ai, bi <= n - 1\n;; ai != bi\n;; There are no repeated connections.\n(define (criticalConnections n connections)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_886_criticalConnections.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate criticalConnections))\n    (check-within (candidate 4 (list (list 0 1) (list 1 2) (list 2 3) (list 3 0))) (list ) 0.001)\n    (check-within (candidate 2 (list (list 0 1))) (list (list 0 1)) 0.001)\n    (check-within (candidate 3 (list (list 0 1) (list 1 2) (list 2 0))) (list ) 0.001)\n    (check-within (candidate 6 (list (list 0 1) (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 0))) (list ) 0.001)\n    (check-within (candidate 6 (list (list 0 1) (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 0) (list 0 3) (list 1 4) (list 3 2))) (list ) 0.001)\n    (check-within (candidate 4 (list (list 0 1) (list 1 2) (list 2 0) (list 1 3))) (list (list 1 3)) 0.001)\n    (check-within (candidate 1 (list )) (list ) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_898_countSteppingNumbers", "language": "rkt", "prompt": "#lang racket\n;; Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\n;; A stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\n;; Return an integer denoting the count of stepping numbers in the inclusive range [low, high]. \n;; Since the answer may be very large, return it modulo 109 + 7.\n;; Note: A stepping number should not have a leading zero.\n;; Example 1:\n;; Input: low = \"1\", high = \"11\"\n;; Output: 10\n;; Explanation: The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.\n;; Example 2:\n;; Input: low = \"90\", high = \"101\"\n;; Output: 2\n;; Explanation: The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2. \n;; Constraints:\n;; 1 <= int(low) <= int(high) < 10100\n;; 1 <= low.length, high.length <= 100\n;; low and high consist of only digits.\n;; low and high don't have any leading zeros.\n(define (countSteppingNumbers low high)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_898_countSteppingNumbers.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate countSteppingNumbers))\n    (check-within (candidate 0 21) (list 0 1 2 3 4 5 6 7 8 9 10 12 21) 0.001)\n    (check-within (candidate 1 3) (list 1 2 3) 0.001)\n    (check-within (candidate 100 200) (list 101 121 123) 0.001)\n    (check-within (candidate 10 15) (list 10 12) 0.001)\n    (check-within (candidate 10 10) (list 10) 0.001)\n    (check-within (candidate 5000 5000) (list ) 0.001)\n    (check-within (candidate 1 1) (list 1) 0.001)\n    (check-within (candidate 100 100) (list ) 0.001)\n    (check-within (candidate 2 3) (list 2 3) 0.001)\n    (check-within (candidate 0 1) (list 0 1) 0.001)\n    (check-within (candidate 1000000000000000000 1000000000000000000) (list ) 0.001)\n    (check-within (candidate 90 200) (list 98 101 121 123) 0.001)\n    (check-within (candidate 90 101) (list 98 101) 0.001)\n    (check-within (candidate 0 0) (list 0) 0.001)\n    (check-within (candidate 10 25) (list 10 12 21 23) 0.001)\n    (check-within (candidate 111 111) (list ) 0.001)\n    (check-within (candidate 1000 1000) (list ) 0.001)\n    (check-within (candidate 1 2) (list 1 2) 0.001)\n    (check-within (candidate 1000000000 1000000000) (list ) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_905_minFallingPathSum", "language": "rkt", "prompt": "#lang racket\n;; Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.\n;; A falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.\n;; Example 1:\n;; Input: grid = [[1,2,3],[4,5,6],[7,8,9]]\n;; Output: 13\n;; Explanation: \n;; The possible falling paths are:\n;; [1,5,9], [1,5,7], [1,6,7], [1,6,8],\n;; [2,4,8], [2,4,9], [2,6,7], [2,6,8],\n;; [3,4,8], [3,4,9], [3,5,7], [3,5,9]\n;; The falling path with the smallest sum is\u00a0[1,5,7], so the answer is\u00a013.\n;; Example 2:\n;; Input: grid = [[7]]\n;; Output: 7\n;; Constraints:\n;; n == grid.length == grid[i].length\n;; 1 <= n <= 200\n;; -99 <= grid[i][j] <= 99\n(define (minFallingPathSum grid)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_905_minFallingPathSum.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate minFallingPathSum))\n    (check-within (candidate (list (list 1 2 3 4 5 6 7 8 9 10))) 1 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9))) 13 0.001)\n    (check-within (candidate (list (list 1 2))) 1 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6))) 6 0.001)\n    (check-within (candidate (list (list 1 100 1) (list 1 100 1) (list 1 100 1))) 3 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9))) 13 0.001)\n    (check-within (candidate (list (list 1 2 3) (list 4 5 6) (list 7 8 9))) 13 0.001)\n    (check-within (candidate (list (list 1))) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_914_jobScheduling", "language": "rkt", "prompt": "#lang racket\n;; We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\n;; You're given the startTime, endTime and profit lists, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n;; If you choose a job that ends at time X you will be able to start another job that starts at time X.\n;; Example 1:\n;; Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n;; Output: 120\n;; Explanation: The subset chosen is the first and fourth job. \n;; Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.\n;; Example 2:\n;; Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\n;; Output: 150\n;; Explanation: The subset chosen is the first, fourth and fifth job. \n;; Profit obtained 150 = 20 + 70 + 60.\n;; Example 3:\n;; Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\n;; Output: 6\n;; Constraints:\n;; 1 <= startTime.length == endTime.length == profit.length <= 5 * 104\n;; 1 <= startTime[i] < endTime[i] <= 109\n;; 1 <= profit[i] <= 104\n(define (jobScheduling startTime endTime profit)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_914_jobScheduling.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate jobScheduling))\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1) (list 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2) (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)) 15 0.001)\n    (check-within (candidate (list 1 1 1 1 1) (list 2 2 2 2 2) (list 1 2 3 4 5)) 5 0.001)\n    (check-within (candidate (list 1 1 1) (list 2 3 4) (list 5 6 4)) 6 0.001)\n    (check-within (candidate (list 1 3 5 7 9) (list 2 4 6 8 10) (list 100 200 300 400 500)) 1500 0.001)\n    (check-within (candidate (list 1 3 0 5 3) (list 2 4 1 6 5) (list 50 10 40 70 60)) 130 0.001)\n    (check-within (candidate (list 1 1 1 1 1) (list 3 3 3 3 3) (list 5 6 7 8 9)) 9 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_91_numDistinct", "language": "rkt", "prompt": "#lang racket\n;; Given two strings s and t, return the number of distinct subsequences of s which equals t\u00a0modulo\u00a0109\u2009+\u20097.\n;; Example 1:\n;; Input: s = \"rabbbit\", t = \"rabbit\"\n;; Output: 3\n;; Explanation:\n;; As shown below, there are 3 ways you can generate \"rabbit\" from s.\n;; rabbbit\n;; rabbbit\n;; rabbbit\n;; Example 2:\n;; Input: s = \"babgbag\", t = \"bag\"\n;; Output: 5\n;; Explanation:\n;; As shown below, there are 5 ways you can generate \"bag\" from s.\n;; babgbag\n;; babgbag\n;; babgbag\n;; babgbag\n;; babgbag\n;; Constraints:\n;; 1 <= s.length, t.length <= 1000\n;; s and t consist of English letters.\n(define (numDistinct s t)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_91_numDistinct.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate numDistinct))\n    (check-within (candidate \"abc\" \"abcabc\") 0 0.001)\n    (check-within (candidate \"xyz\" \"xy\") 1 0.001)\n    (check-within (candidate \"xyz\" \"x\") 1 0.001)\n    (check-within (candidate \"xyz\" \"yz\") 1 0.001)\n    (check-within (candidate \"xyz\" \"x\") 1 0.001)\n    (check-within (candidate \"xyz\" \"y\") 1 0.001)\n    (check-within (candidate \"abcabc\" \"ab\") 3 0.001)\n    (check-within (candidate \"abcabc\" \"bc\") 3 0.001)\n    (check-within (candidate \"rabbbit\" \"rabbit\") 3 0.001)\n    (check-within (candidate \"aaaaaa\" \"aa\") 15 0.001)\n    (check-within (candidate \"abcabcabcabcabcabc\" \"abcabcabcabcabcabc\") 1 0.001)\n    (check-within (candidate \"xyz\" \"xy\") 1 0.001)\n    (check-within (candidate \"\" \"\") 1 0.001)\n    (check-within (candidate \"xyz\" \"xz\") 1 0.001)\n    (check-within (candidate \"a\" \"\") 1 0.001)\n    (check-within (candidate \"abcabc\" \"abcabca\") 0 0.001)\n    (check-within (candidate \"xyz\" \"w\") 0 0.001)\n    (check-within (candidate \"xyz\" \"y\") 1 0.001)\n    (check-within (candidate \"xyz\" \"xyz\") 1 0.001)\n    (check-within (candidate \"abcabcabcabcabcabc\" \"abcabcabcabcabcabca\") 0 0.001)\n    (check-within (candidate \"babgbag\" \"bag\") 5 0.001)\n    (check-within (candidate \"abcabcabcabcabcabc\" \"a\") 6 0.001)\n    (check-within (candidate \"abcabcabcabcabcabc\" \"abcabcabcabcabcabc\") 1 0.001)\n    (check-within (candidate \"xyz\" \"z\") 1 0.001)\n    (check-within (candidate \"abcabc\" \"abcabc\") 1 0.001)\n    (check-within (candidate \"abcde\" \"ace\") 1 0.001)\n    (check-within (candidate \"a\" \"\") 1 0.001)\n    (check-within (candidate \"abcabcabcabcabcabc\" \"a\") 6 0.001)\n    (check-within (candidate \"abcabc\" \"abcabca\") 0 0.001)\n    (check-within (candidate \"abcabcabcabcabcabc\" \"abcabcabcabcabcabca\") 0 0.001)\n    (check-within (candidate \"xyz\" \"w\") 0 0.001)\n    (check-within (candidate \"xyz\" \"xz\") 1 0.001)\n    (check-within (candidate \"abcabc\" \"bc\") 3 0.001)\n    (check-within (candidate \"abcabc\" \"b\") 2 0.001)\n    (check-within (candidate \"xyz\" \"z\") 1 0.001)\n    (check-within (candidate \"babgbag\" \"bag\") 5 0.001)\n    (check-within (candidate \"abcabc\" \"a\") 2 0.001)\n    (check-within (candidate \"abcabc\" \"c\") 2 0.001)\n    (check-within (candidate \"\" \"\") 1 0.001)\n    (check-within (candidate \"abcde\" \"ace\") 1 0.001)\n    (check-within (candidate \"abcabc\" \"a\") 2 0.001)\n    (check-within (candidate \"rabbbit\" \"rabbit\") 3 0.001)\n    (check-within (candidate \"xyz\" \"xyz\") 1 0.001)\n    (check-within (candidate \"abc\" \"abcabc\") 0 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_925_isGoodArray", "language": "rkt", "prompt": "#lang racket\n;; Given a list nums of\u00a0positive integers. Your task is to select some subset of nums, multiply each element by an integer and add all these numbers.\u00a0The list is said to be\u00a0good\u00a0if you can obtain a sum of\u00a01\u00a0from the list by any possible subset and multiplicand.\n;; Return\u00a0#t\u00a0if the list is good\u00a0otherwise\u00a0return\u00a0#f.\n;; Example 1:\n;; Input: nums = [12,5,7,23]\n;; Output: true\n;; Explanation: Pick numbers 5 and 7.\n;; 5*3 + 7*(-2) = 1\n;; Example 2:\n;; Input: nums = [29,6,10]\n;; Output: true\n;; Explanation: Pick numbers 29, 6 and 10.\n;; 29*1 + 6*(-3) + 10*(-1) = 1\n;; Example 3:\n;; Input: nums = [3,6]\n;; Output: false\n;; Constraints:\n;; 1 <= nums.length <= 10^5\n;; 1 <= nums[i] <= 10^9\n(define (isGoodArray nums)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_925_isGoodArray.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate isGoodArray))\n    (check-within (candidate (list 27 54 81 108)) #f 0.001)\n    (check-within (candidate (list 17 34 51 68)) #f 0.001)\n    (check-within (candidate (list 13 26 39 52)) #f 0.001)\n    (check-within (candidate (list 18 36 54 72)) #f 0.001)\n    (check-within (candidate (range 1 10000)) #t 0.001)\n    (check-within (candidate (list 29 58 87 116)) #f 0.001)\n    (check-within (candidate (list 10 14 20 24 30 34 40 44 50 54)) #f 0.001)\n    (check-within (candidate (list 24 48 72 96)) #f 0.001)\n    (check-within (candidate (list 12 24 36 48 60 72 84 96 108 120)) #f 0.001)\n    (check-within (candidate (list 12 15 18 21 24 27 30 33 36 39)) #f 0.001)\n    (check-within (candidate (list 6 12 18 24 30 36 42 48 54 60)) #f 0.001)\n    (check-within (candidate (list 11 22 33 44)) #f 0.001)\n    (check-within (candidate (list 3 6)) #f 0.001)\n    (check-within (candidate (list 29 6 10)) #t 0.001)\n    (check-within (candidate (list 3 6 9 12)) #f 0.001)\n    (check-within (candidate (list 34 68 102 136)) #f 0.001)\n    (check-within (candidate (list 2 2 2 2 2 2 2)) #f 0.001)\n    (check-within (candidate (list 22 44 66 88)) #f 0.001)\n    (check-within (candidate (list 19 38 57 76)) #f 0.001)\n    (check-within (candidate (list 1 2 3)) #t 0.001)\n    (check-within (candidate (list 1000 1000 2 3)) #t 0.001)\n    (check-within (candidate (list 25 50 75 100)) #f 0.001)\n    (check-within (candidate (list 33 66 99 132 165 198 231 264 297 330)) #f 0.001)\n    (check-within (candidate (list 21 42 63 84 1 3)) #t 0.001)\n    (check-within (candidate (list 1000 1000 2 3 4 6)) #t 0.001)\n    (check-within (candidate (list 12 5 7 23)) #t 0.001)\n    (check-within (candidate (list 1)) #t 0.001)\n    (check-within (candidate (list 10 20 30 40 50)) #f 0.001)\n    (check-within (candidate (list 28 56 84 112)) #f 0.001)\n    (check-within (candidate (list 30 60 90 120)) #f 0.001)\n    (check-within (candidate (list 4 8 16)) #f 0.001)\n    (check-within (candidate (list 9 18 27 36)) #f 0.001)\n    (check-within (candidate (list 26 52 78 104)) #f 0.001)\n    (check-within (candidate (list 21 42 63 84 2 6)) #t 0.001)\n    (check-within (candidate (list 15 30 45 60)) #f 0.001)\n    (check-within (candidate (list 46 92 138 184 230 276 322 368 414 460 506 552 600)) #f 0.001)\n    (check-within (candidate (list 12 24 36 48)) #f 0.001)\n    (check-within (candidate (list 20 40 60 80)) #f 0.001)\n    (check-within (candidate (list 20 30 40 48)) #f 0.001)\n    (check-within (candidate (list 2)) #f 0.001)\n    (check-within (candidate (list 7 14 21)) #f 0.001)\n    (check-within (candidate (list 21 42 63 84)) #f 0.001)\n    (check-within (candidate (list 16 32 48 64)) #f 0.001)\n    (check-within (candidate (list 3 6 9 12 15 18 21 24 27 30)) #f 0.001)\n    (check-within (candidate (list 14 28 42 56)) #f 0.001)\n    (check-within (candidate (list 10 20 30 40)) #f 0.001)\n    (check-within (candidate (list 23 46 69 92)) #f 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_929_maxValueAfterReverse", "language": "rkt", "prompt": "#lang racket\n;; You are given an integer list nums. The value of this list is defined as the sum of |nums[i] - nums[i + 1]| for all 0 <= i < nums.length - 1.\n;; You are allowed to select any sublist of the given list and reverse it. You can perform this operation only once.\n;; Find maximum possible value of the final list.\n;; Example 1:\n;; Input: nums = [2,3,1,5,4]\n;; Output: 10\n;; Explanation: By reversing the sublist [3,1,5] the list becomes [2,5,1,3,4] whose value is 10.\n;; Example 2:\n;; Input: nums = [2,4,9,24,2,1,10]\n;; Output: 68\n;; Constraints:\n;; 1 <= nums.length <= 3 * 104\n;; -105 <= nums[i] <= 105\n(define (maxValueAfterReverse nums)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_929_maxValueAfterReverse.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maxValueAfterReverse))\n    (check-within (candidate (list 2 4 9 24 2 1 10)) 68 0.001)\n    (check-within (candidate (list 5 5 5 5 5)) 0 0.001)\n    (check-within (candidate (list 2 4 9 24 2 1 10)) 68 0.001)\n    (check-within (candidate (list 10 20 30 40 50)) 80 0.001)\n    (check-within (candidate (list 1 1 1 1 1)) 0 0.001)\n    (check-within (candidate (list 2 3 1 5 4)) 10 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_960_shortestPath", "language": "rkt", "prompt": "#lang racket\n;; You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacle). You can move up, down, left, or right from and to an empty cell in one step.\n;; Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1) given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1.\n;; Example 1:\n;; Input: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1\n;; Output: 6\n;; Explanation: \n;; The shortest path without eliminating any obstacle is 10.\n;; The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).\n;; Example 2:\n;; Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1\n;; Output: -1\n;; Explanation: We need to eliminate at least two obstacles to find such a walk.\n;; Constraints:\n;; m == grid.length\n;; n == grid[i].length\n;; 1 <= m, n <= 40\n;; 1 <= k <= m * n\n;; grid[i][j] is either 0 or 1.\n;; grid[0][0] == grid[m - 1][n - 1] == 0\n(define (shortestPath grid k)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_960_shortestPath.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate shortestPath))\n    (check-within (candidate (list (list 0 0 0)) 2) 2 0.001)\n    (check-within (candidate (list (list 0 1 1 1 0)) 3) 4 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 1 1 0) (list 0 0 0)) 1) 4 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 0 1 1) (list 0 0 0)) 1) 4 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 1 1 0) (list 0 0 0) (list 0 1 1) (list 0 0 0)) 1) 6 0.001)\n    (check-within (candidate (list (list 0 1) (list 1 0)) 1) 2 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 0 0 0) (list 0 1 0) (list 0 1 0) (list 0 0 0)) 1) 6 0.001)\n    (check-within (candidate (list (list 0 1 1 0)) 1) -1 0.001)\n    (check-within (candidate (list (list 0) (list 0) (list 0)) 1) 2 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 1 1 1) (list 0 0 0)) 2) 4 0.001)\n    (check-within (candidate (list (list 0 0 0 0 0 0) (list 0 0 0 1 0 0) (list 0 0 0 1 0 0) (list 0 0 1 1 0 0) (list 0 0 1 1 0 0) (list 0 0 0 0 0 0)) 2) 10 0.001)\n    (check-within (candidate (list (list 0) (list 1) (list 1) (list 0)) 1) -1 0.001)\n    (check-within (candidate (list (list 0 0 0 0 0) (list 1 1 1 1 1) (list 0 0 0 0 0)) 1) 6 0.001)\n    (check-within (candidate (list (list 0 0) (list 0 1) (list 0 0) (list 0 1) (list 0 0)) 0) 5 0.001)\n    (check-within (candidate (list (list 0 0 0)) 1) 2 0.001)\n    (check-within (candidate (list (list 0 0 0)) 0) 2 0.001)\n    (check-within (candidate (list (list 0 1 1 0 0)) 2) 4 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 0 1 0) (list 0 0 0)) 2) 4 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 1 1 0) (list 0 0 0) (list 0 1 1) (list 0 0 0)) 2) 6 0.001)\n    (check-within (candidate (list (list 0 1 1) (list 1 1 1) (list 1 0 0)) 1) -1 0.001)\n    (check-within (candidate (list (list 0) (list 1) (list 1) (list 1) (list 0)) 3) 4 0.001)\n    (check-within (candidate (list (list 0) (list 1) (list 0)) 1) 2 0.001)\n    (check-within (candidate (list (list 0 1 0) (list 1 1 0) (list 0 0 0)) 1) 4 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 1 0 0) (list 0 0 0)) 0) 4 0.001)\n    (check-within (candidate (list (list 0 1 0)) 2) 2 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 0 0 0) (list 0 1 1) (list 0 0 0) (list 0 0 0)) 1) 6 0.001)\n    (check-within (candidate (list (list 0 0 0) (list 1 1 0) (list 0 0 0)) 2) 4 0.001)\n    (check-within (candidate (list (list 0 1 0 0 0) (list 0 1 0 1 0) (list 0 1 0 1 0) (list 0 1 0 0 0) (list 0 0 0 0 0)) 0) 8 0.001)\n    (check-within (candidate (list (list 0 1 0)) 1) 2 0.001)\n    (check-within (candidate (list (list 0 1 0 1 0)) 2) 4 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_965_criticalConnections", "language": "rkt", "prompt": "#lang racket\n;; There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network.\n;; A critical connection is a connection that, if removed, will make some servers unable to reach some other server.\n;; Return all critical connections in the network in any order.\n;; Example 1:\n;; Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]\n;; Output: [[1,3]]\n;; Explanation: [[3,1]] is also accepted.\n;; Example 2:\n;; Input: n = 2, connections = [[0,1]]\n;; Output: [[0,1]]\n;; Constraints:\n;; 2 <= n <= 105\n;; n - 1 <= connections.length <= 105\n;; 0 <= ai, bi <= n - 1\n;; ai != bi\n;; There are no repeated connections.\n(define (criticalConnections n connections)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_965_criticalConnections.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate criticalConnections))\n    (check-within (candidate 3 (list (list 0 1) (list 1 2) (list 2 0))) (list ) 0.001)\n    (check-within (candidate 4 (list (list 0 1) (list 1 2) (list 2 0) (list 1 3))) (list (list 1 3)) 0.001)\n    (check-within (candidate 8 (list (list 0 1) (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 7) (list 7 0))) (list ) 0.001)\n    (check-within (candidate 8 (list (list 0 1) (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 7) (list 7 0) (list 1 7))) (list ) 0.001)\n    (check-within (candidate 5 (list (list 0 1) (list 1 2) (list 2 3) (list 3 4) (list 4 0) (list 0 3))) (list ) 0.001)\n    (check-within (candidate 4 (list (list 0 1) (list 1 2) (list 2 3) (list 3 0) (list 2 0))) (list ) 0.001)\n    (check-within (candidate 6 (list (list 0 1) (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 0))) (list ) 0.001)\n    (check-within (candidate 5 (list (list 0 1) (list 1 2) (list 2 3) (list 3 0) (list 0 4) (list 4 1) (list 1 4))) (list ) 0.001)\n    (check-within (candidate 7 (list (list 0 1) (list 1 2) (list 2 3) (list 3 4) (list 4 5) (list 5 6) (list 6 0))) (list ) 0.001)\n    (check-within (candidate 5 (list (list 0 1) (list 1 2) (list 2 3) (list 3 4) (list 4 0))) (list ) 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
{"name": "LeetCode_998_maxEqualFreq", "language": "rkt", "prompt": "#lang racket\n;; Given a list nums of positive integers, return the longest possible length of a list prefix of nums, such that it is possible to remove exactly one element from this prefix so that every number that has appeared in it will have the same number of occurrences.\n;; If after removing one element there are no remaining elements, it's still considered that every appeared number has the same number of ocurrences (0).\n;; Example 1:\n;; Input: nums = [2,2,1,1,5,3,3,5]\n;; Output: 7\n;; Explanation: For the sublist [2,2,1,1,5,3,3] of length 7, if we remove nums[4] = 5, we will get [2,2,1,1,3,3], so that each number will appear exactly twice.\n;; Example 2:\n;; Input: nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]\n;; Output: 13\n;; Constraints:\n;; 2 <= nums.length <= 105\n;; 1 <= nums[i] <= 105\n(define (maxEqualFreq nums)\n", "doctests": "keep", "original": "/home/elleven/code/MultiPL-E/datasets/../datasets/leetcode-hard/LeetCode_998_maxEqualFreq.py", "prompt_terminology": "reworded", "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maxEqualFreq))\n    (check-within (candidate (list 10 20 30 40 50 60 70 80 90 100)) 1 0.001)\n    (check-within (candidate (list 2 2 2 2 2 2 3 1)) 7 0.001)\n    (check-within (candidate (list 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2)) 11 0.001)\n    (check-within (candidate (list 1 2 3 4 5 6 7 8 9 10)) 1 0.001)\n))\n\n(test-humaneval)", "stop_tokens": ["\n(define ", "\n#|", "\n;", "\n("]}
